[1 of 2] Compiling Main             ( Gy08.hs, Gy08.o )

==================== Desugar (after optimization) ====================
Result size of Desugar (after optimization)
  = {terms: 12,452, types: 20,190, coercions: 1,860, joins: 0/263}

-- RHS size: {terms: 6, types: 6, coercions: 0, joins: 0/0}
$cnull_a43V :: forall a. Single a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)}]
$cnull_a43V
  = \ (@a_a43Y) (ds_d4Ut :: Single a_a43Y) ->
      case ds_d4Ut of { Single _ [Occ=Dead] -> GHC.Types.False }

-- RHS size: {terms: 11, types: 11, coercions: 0, joins: 0/0}
$cfoldr_a42J :: forall a b. (a -> b -> b) -> b -> Single a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)}]
$cfoldr_a42J
  = \ (@a_a42M)
      (@b_a42N)
      (f_a2hm :: a_a42M -> b_a42N -> b_a42N)
      (z_a2hn :: b_a42N)
      (ds_d4Us :: Single a_a42M) ->
      case ds_d4Us of { Single a1_a2ho -> f_a2hm a1_a2ho z_a2hn }

-- RHS size: {terms: 10, types: 11, coercions: 0, joins: 0/0}
$cfoldMap_a42l :: forall m a. Monoid m => (a -> m) -> Single a -> m
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)}]
$cfoldMap_a42l
  = \ (@m_a42o)
      (@a_a42p)
      _ [Occ=Dead]
      (f_a2hp :: a_a42p -> m_a42o)
      (ds_d4Ur :: Single a_a42p) ->
      case ds_d4Ur of { Single a1_a2hq -> f_a2hp a1_a2hq }

Rec {
-- RHS size: {terms: 18, types: 1, coercions: 0, joins: 0/0}
Main.$fFoldableSingle [InlPrag=CONLIKE] :: Foldable Single
[LclIdX[DFunId],
 Unf=DFun: \ ->
       Data.Foldable.C:Foldable TYPE: Single
                                $cfold_a429
                                $cfoldMap_a42l
                                $cfoldMap'_a42v
                                $cfoldr_a42J
                                $cfoldr'_a42R
                                $cfoldl_a433
                                $cfoldl'_a43f
                                $cfoldr1_a43r
                                $cfoldl1_a43B
                                $ctoList_a43L
                                $cnull_a43V
                                $clength_a442
                                $celem_a44c
                                $cmaximum_a44o
                                $cminimum_a44A
                                $csum_a44M
                                $cproduct_a44Y]
Main.$fFoldableSingle
  = Data.Foldable.C:Foldable
      @Single
      $cfold_a429
      $cfoldMap_a42l
      $cfoldMap'_a42v
      $cfoldr_a42J
      $cfoldr'_a42R
      $cfoldl_a433
      $cfoldl'_a43f
      $cfoldr1_a43r
      $cfoldl1_a43B
      $ctoList_a43L
      $cnull_a43V
      $clength_a442
      $celem_a44c
      $cmaximum_a44o
      $cminimum_a44A
      $csum_a44M
      $cproduct_a44Y

-- RHS size: {terms: 14, types: 18, coercions: 25, joins: 0/0}
$csum_a44M [Occ=LoopBreaker] :: forall a. Num a => Single a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 120 60}]
$csum_a44M
  = \ (@a_a44P) ($dNum_a44Q :: Num a_a44P) ->
      ((\ (@(t_a4WR :: * -> *))
          ($dFoldable_a4WS :: Foldable t_a4WR)
          (@a_a4WT)
          ($dNum_a4WU :: Num a_a4WT) ->
          Data.Foldable.foldMap'
            @t_a4WR
            $dFoldable_a4WS
            @(base:Data.Semigroup.Internal.Sum a_a4WT)
            @a_a4WT
            (base:Data.Semigroup.Internal.$fMonoidSum @a_a4WT $dNum_a4WU)
            ((\ (ds_a52f :: a_a4WT) -> ds_a52f)
             `cast` (<a_a4WT>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Sum[0]
                                              <a_a4WT>_R)
                     :: (a_a4WT -> a_a4WT)
                        ~R# (a_a4WT -> base:Data.Semigroup.Internal.Sum a_a4WT))))
       `cast` (forall (t :: <* -> *>_N).
               <Foldable t>_R
               %<'Many>_N ->_R forall (a :: <*>_N).
                               <Num a>_R
                               %<'Many>_N ->_R <t a>_R
                               %<'Many>_N ->_R base:Data.Semigroup.Internal.N:Sum[0] <a>_R
               :: (forall {t :: * -> *} {a}.
                   (Foldable t, Num a) =>
                   t a -> base:Data.Semigroup.Internal.Sum a)
                  ~R# (forall {t :: * -> *} {a}. (Foldable t, Num a) => t a -> a)))
        @Single Main.$fFoldableSingle @a_a44P $dNum_a44Q

-- RHS size: {terms: 24, types: 25, coercions: 8, joins: 0/2}
$cminimum_a44A [Occ=LoopBreaker]
  :: forall a. Ord a => Single a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 260 60}]
$cminimum_a44A
  = \ (@a_a44D) ($dOrd_a44E :: Ord a_a44D) ->
      let {
        d_a52o :: a_a44D
        [LclId,
         Str=b,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 110 0}]
        d_a52o
          = errorWithoutStackTrace
              @GHC.Types.LiftedRep
              @a_a44D
              (GHC.Base.build
                 @Char
                 (\ (@b_a52t) ->
                    GHC.CString.unpackFoldrCString#
                      @b_a52t "minimum: empty structure"#)) } in
      let {
        g_a52v :: Single a_a44D -> base:Data.Functor.Utils.Min a_a44D
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 80 0}]
        g_a52v
          = Data.Foldable.foldMap'
              @Single
              Main.$fFoldableSingle
              @(base:Data.Functor.Utils.Min a_a44D)
              @a_a44D
              (base:Data.Functor.Utils.$fMonoidMin @a_a44D $dOrd_a44E)
              ((\ (ds_a53M :: a_a44D) -> GHC.Maybe.Just @a_a44D ds_a53M)
               `cast` (<a_a44D>_R
                       %<'Many>_N ->_R Sym (base:Data.Functor.Utils.N:Min[0]) <a_a44D>_N
                       :: (a_a44D -> GHC.Maybe.Maybe a_a44D)
                          ~R# (a_a44D -> base:Data.Functor.Utils.Min a_a44D))) } in
      \ (x_a53N :: Single a_a44D) ->
        case (g_a52v x_a53N)
             `cast` (base:Data.Functor.Utils.N:Min[0] <a_a44D>_N
                     :: base:Data.Functor.Utils.Min a_a44D ~R# GHC.Maybe.Maybe a_a44D)
        of {
          GHC.Maybe.Nothing -> d_a52o;
          GHC.Maybe.Just v_a54h -> v_a54h
        }

-- RHS size: {terms: 24, types: 25, coercions: 8, joins: 0/2}
$cmaximum_a44o [Occ=LoopBreaker]
  :: forall a. Ord a => Single a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 260 60}]
$cmaximum_a44o
  = \ (@a_a44r) ($dOrd_a44s :: Ord a_a44r) ->
      let {
        d_a54n :: a_a44r
        [LclId,
         Str=b,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 110 0}]
        d_a54n
          = errorWithoutStackTrace
              @GHC.Types.LiftedRep
              @a_a44r
              (GHC.Base.build
                 @Char
                 (\ (@b_a54o) ->
                    GHC.CString.unpackFoldrCString#
                      @b_a54o "maximum: empty structure"#)) } in
      let {
        g_a54p :: Single a_a44r -> base:Data.Functor.Utils.Max a_a44r
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 80 0}]
        g_a54p
          = Data.Foldable.foldMap'
              @Single
              Main.$fFoldableSingle
              @(base:Data.Functor.Utils.Max a_a44r)
              @a_a44r
              (base:Data.Functor.Utils.$fMonoidMax @a_a44r $dOrd_a44s)
              ((\ (ds_a54r :: a_a44r) -> GHC.Maybe.Just @a_a44r ds_a54r)
               `cast` (<a_a44r>_R
                       %<'Many>_N ->_R Sym (base:Data.Functor.Utils.N:Max[0]) <a_a44r>_N
                       :: (a_a44r -> GHC.Maybe.Maybe a_a44r)
                          ~R# (a_a44r -> base:Data.Functor.Utils.Max a_a44r))) } in
      \ (x_a54s :: Single a_a44r) ->
        case (g_a54p x_a54s)
             `cast` (base:Data.Functor.Utils.N:Max[0] <a_a44r>_N
                     :: base:Data.Functor.Utils.Max a_a44r ~R# GHC.Maybe.Maybe a_a44r)
        of {
          GHC.Maybe.Nothing -> d_a54n;
          GHC.Maybe.Just v_a54x -> v_a54x
        }

-- RHS size: {terms: 15, types: 17, coercions: 26, joins: 0/0}
$celem_a44c [Occ=LoopBreaker]
  :: forall a. Eq a => a -> Single a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 130 60}]
$celem_a44c
  = \ (@a_a44f) ($dEq_a44g :: Eq a_a44f) ->
      ((\ (@(t_a54z :: * -> *))
          ($dFoldable_a54A :: Foldable t_a54z)
          (@a_a54B)
          ($dEq_a54C :: Eq a_a54B)
          (eta_a54D :: a_a54B) ->
          foldMap
            @t_a54z
            $dFoldable_a54A
            @base:Data.Semigroup.Internal.Any
            @a_a54B
            base:Data.Semigroup.Internal.$fMonoidAny
            ((== @a_a54B $dEq_a54C eta_a54D)
             `cast` (<a_a54B>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Any[0])
                     :: (a_a54B -> Bool)
                        ~R# (a_a54B -> base:Data.Semigroup.Internal.Any))))
       `cast` (forall (t :: <* -> *>_N).
               <Foldable t>_R
               %<'Many>_N ->_R forall (a :: <*>_N).
                               <Eq a>_R
                               %<'Many>_N ->_R <a>_R
                               %<'Many>_N ->_R <t a>_R
                               %<'Many>_N ->_R base:Data.Semigroup.Internal.N:Any[0]
               :: (forall {t :: * -> *} {a}.
                   (Foldable t, Eq a) =>
                   a -> t a -> base:Data.Semigroup.Internal.Any)
                  ~R# (forall {t :: * -> *} {a}.
                       (Foldable t, Eq a) =>
                       a -> t a -> Bool)))
        @Single Main.$fFoldableSingle @a_a44f $dEq_a44g

-- RHS size: {terms: 14, types: 8, coercions: 0, joins: 0/0}
$clength_a442 [Occ=LoopBreaker] :: forall a. Single a -> Int
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=False, ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 91 0}]
$clength_a442
  = \ (@a_a445) ->
      Data.Foldable.foldl'
        @Single
        Main.$fFoldableSingle
        @Int
        @a_a445
        (\ (c_a54K :: Int) _ [Occ=Dead] ->
           case c_a54K of { GHC.Types.I# x_a54N ->
           GHC.Types.I# (GHC.Prim.+# x_a54N 1#)
           })
        (GHC.Types.I# 0#)

-- RHS size: {terms: 11, types: 12, coercions: 0, joins: 0/0}
$ctoList_a43L [Occ=LoopBreaker] :: forall a. Single a -> [a]
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 70 40}]
$ctoList_a43L
  = \ (@a_a43O) (t1_a54S :: Single a_a43O) ->
      GHC.Base.build
        @a_a43O
        (\ (@b_a54T)
           (c_a54U [OS=OneShot] :: a_a43O -> b_a54T -> b_a54T)
           (n_a54V [OS=OneShot] :: b_a54T) ->
           foldr
             @Single
             Main.$fFoldableSingle
             @a_a43O
             @b_a54T
             c_a54U
             n_a54V
             t1_a54S)

-- RHS size: {terms: 27, types: 26, coercions: 0, joins: 0/0}
$cfoldl1_a43B [Occ=LoopBreaker]
  :: forall a. (a -> a -> a) -> Single a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0] 260 0}]
$cfoldl1_a43B
  = \ (@a_a43E)
      (f_a54Z :: a_a43E -> a_a43E -> a_a43E)
      (xs_a550 :: Single a_a43E) ->
      case foldl
             @Single
             Main.$fFoldableSingle
             @(GHC.Maybe.Maybe a_a43E)
             @a_a43E
             (\ (m_a551 :: GHC.Maybe.Maybe a_a43E) (y_a552 :: a_a43E) ->
                GHC.Maybe.Just
                  @a_a43E
                  (case m_a551 of {
                     GHC.Maybe.Nothing -> y_a552;
                     GHC.Maybe.Just x_a555 -> f_a54Z x_a555 y_a552
                   }))
             (GHC.Maybe.Nothing @a_a43E)
             xs_a550
      of {
        GHC.Maybe.Nothing ->
          errorWithoutStackTrace
            @GHC.Types.LiftedRep
            @a_a43E
            (GHC.Base.build
               @Char
               (\ (@b_a558) ->
                  GHC.CString.unpackFoldrCString#
                    @b_a558 "foldl1: empty structure"#));
        GHC.Maybe.Just v_a559 -> v_a559
      }

-- RHS size: {terms: 27, types: 26, coercions: 0, joins: 0/0}
$cfoldr1_a43r [Occ=LoopBreaker]
  :: forall a. (a -> a -> a) -> Single a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0] 260 0}]
$cfoldr1_a43r
  = \ (@a_a43u)
      (f_a55f :: a_a43u -> a_a43u -> a_a43u)
      (xs_a55g :: Single a_a43u) ->
      case foldr
             @Single
             Main.$fFoldableSingle
             @a_a43u
             @(GHC.Maybe.Maybe a_a43u)
             (\ (x_a55h :: a_a43u) (m_a55i :: GHC.Maybe.Maybe a_a43u) ->
                GHC.Maybe.Just
                  @a_a43u
                  (case m_a55i of {
                     GHC.Maybe.Nothing -> x_a55h;
                     GHC.Maybe.Just y_a55l -> f_a55f x_a55h y_a55l
                   }))
             (GHC.Maybe.Nothing @a_a43u)
             xs_a55g
      of {
        GHC.Maybe.Nothing ->
          errorWithoutStackTrace
            @GHC.Types.LiftedRep
            @a_a43u
            (GHC.Base.build
               @Char
               (\ (@b_a55o) ->
                  GHC.CString.unpackFoldrCString#
                    @b_a55o "foldr1: empty structure"#));
        GHC.Maybe.Just v_a55p -> v_a55p
      }

-- RHS size: {terms: 20, types: 18, coercions: 0, joins: 0/0}
$cfoldl'_a43f [Occ=LoopBreaker]
  :: forall b a. (b -> a -> b) -> b -> Single a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 150 0}]
$cfoldl'_a43f
  = \ (@b_a43i)
      (@a_a43j)
      (f_a55w :: b_a43i -> a_a43j -> b_a43i)
      (z0_a55x :: b_a43i)
      (xs_a55y :: Single a_a43j) ->
      foldr
        @Single
        Main.$fFoldableSingle
        @a_a43j
        @(b_a43i -> b_a43i)
        (\ (ds_a55z :: a_a43j)
           (ds1_a55A :: b_a43i -> b_a43i)
           (v_a55B [OS=OneShot] :: b_a43i) ->
           case v_a55B of z_a55C { __DEFAULT ->
           ds1_a55A (f_a55w z_a55C ds_a55z)
           })
        (id @b_a43i)
        xs_a55y
        z0_a55x

-- RHS size: {terms: 16, types: 18, coercions: 10, joins: 0/0}
$cfoldl_a433 [Occ=LoopBreaker]
  :: forall b a. (b -> a -> b) -> b -> Single a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 130 0}]
$cfoldl_a433
  = \ (@b_a436)
      (@a_a437)
      (eta_a55I :: b_a436 -> a_a437 -> b_a436)
      (eta1_a55J :: b_a436)
      (eta2_a55K :: Single a_a437) ->
      ((foldMap
          @Single
          Main.$fFoldableSingle
          @(base:Data.Semigroup.Internal.Dual
              (base:Data.Semigroup.Internal.Endo b_a436))
          @a_a437
          (base:Data.Semigroup.Internal.$fMonoidDual
             @(base:Data.Semigroup.Internal.Endo b_a436)
             (base:Data.Semigroup.Internal.$fMonoidEndo @b_a436))
          ((\ (x_a55N :: a_a437) (y_a55O :: b_a436) ->
              eta_a55I y_a55O x_a55N)
           `cast` (<a_a437>_R
                   %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Dual[0]
                                            (base:Data.Semigroup.Internal.N:Endo[0] <b_a436>_R))
                   :: (a_a437 -> b_a436 -> b_a436)
                      ~R# (a_a437
                           -> base:Data.Semigroup.Internal.Dual
                                (base:Data.Semigroup.Internal.Endo b_a436))))
          eta2_a55K)
       `cast` (base:Data.Semigroup.Internal.N:Dual[0]
                   (base:Data.Semigroup.Internal.N:Endo[0] <b_a436>_R)
               :: base:Data.Semigroup.Internal.Dual
                    (base:Data.Semigroup.Internal.Endo b_a436)
                  ~R# (b_a436 -> b_a436)))
        eta1_a55J

-- RHS size: {terms: 20, types: 18, coercions: 0, joins: 0/0}
$cfoldr'_a42R [Occ=LoopBreaker]
  :: forall a b. (a -> b -> b) -> b -> Single a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 150 0}]
$cfoldr'_a42R
  = \ (@a_a42U)
      (@b_a42V)
      (f_a55X :: a_a42U -> b_a42V -> b_a42V)
      (z0_a55Y :: b_a42V)
      (xs_a55Z :: Single a_a42U) ->
      foldl
        @Single
        Main.$fFoldableSingle
        @(b_a42V -> b_a42V)
        @a_a42U
        (\ (ds_a560 :: b_a42V -> b_a42V)
           (ds1_a561 :: a_a42U)
           (v_a562 [OS=OneShot] :: b_a42V) ->
           case v_a562 of z_a563 { __DEFAULT ->
           ds_a560 (f_a55X ds1_a561 z_a563)
           })
        (id @b_a42V)
        xs_a55Z
        z0_a55Y

-- RHS size: {terms: 18, types: 16, coercions: 0, joins: 0/1}
$cfoldMap'_a42v [Occ=LoopBreaker]
  :: forall m a. Monoid m => (a -> m) -> Single a -> m
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 60] 170 0}]
$cfoldMap'_a42v
  = \ (@m_a42y)
      (@a_a42z)
      ($dMonoid_a42A :: Monoid m_a42y)
      (eta_a569 :: a_a42z -> m_a42y) ->
      let {
        $dSemigroup_a56a :: Semigroup m_a42y
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dSemigroup_a56a = GHC.Base.$p1Monoid @m_a42y $dMonoid_a42A } in
      Data.Foldable.foldl'
        @Single
        Main.$fFoldableSingle
        @m_a42y
        @a_a42z
        (\ (acc_a56b :: m_a42y) (a1_a56c :: a_a42z) ->
           <> @m_a42y $dSemigroup_a56a acc_a56b (eta_a569 a1_a56c))
        (mempty @m_a42y $dMonoid_a42A)

-- RHS size: {terms: 14, types: 18, coercions: 25, joins: 0/0}
$cproduct_a44Y [Occ=LoopBreaker]
  :: forall a. Num a => Single a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 120 60}]
$cproduct_a44Y
  = \ (@a_a451) ($dNum_a452 :: Num a_a451) ->
      ((\ (@(t_a56d :: * -> *))
          ($dFoldable_a56e :: Foldable t_a56d)
          (@a_a56f)
          ($dNum_a56g :: Num a_a56f) ->
          Data.Foldable.foldMap'
            @t_a56d
            $dFoldable_a56e
            @(base:Data.Semigroup.Internal.Product a_a56f)
            @a_a56f
            (base:Data.Semigroup.Internal.$fMonoidProduct @a_a56f $dNum_a56g)
            ((\ (ds_a56i :: a_a56f) -> ds_a56i)
             `cast` (<a_a56f>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Product[0]
                                              <a_a56f>_R)
                     :: (a_a56f -> a_a56f)
                        ~R# (a_a56f -> base:Data.Semigroup.Internal.Product a_a56f))))
       `cast` (forall (t :: <* -> *>_N).
               <Foldable t>_R
               %<'Many>_N ->_R forall (a :: <*>_N).
                               <Num a>_R
                               %<'Many>_N ->_R <t a>_R
                               %<'Many>_N ->_R base:Data.Semigroup.Internal.N:Product[0] <a>_R
               :: (forall {t :: * -> *} {a}.
                   (Foldable t, Num a) =>
                   t a -> base:Data.Semigroup.Internal.Product a)
                  ~R# (forall {t :: * -> *} {a}. (Foldable t, Num a) => t a -> a)))
        @Single Main.$fFoldableSingle @a_a451 $dNum_a452

-- RHS size: {terms: 6, types: 7, coercions: 0, joins: 0/0}
$cfold_a429 [Occ=LoopBreaker]
  :: forall m. Monoid m => Single m -> m
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 40 0}]
$cfold_a429
  = \ (@m_a42c) ($dMonoid_a42d :: Monoid m_a42c) ->
      foldMap
        @Single
        Main.$fFoldableSingle
        @m_a42c
        @m_a42c
        $dMonoid_a42d
        (id @m_a42c)
end Rec }

-- RHS size: {terms: 9, types: 9, coercions: 0, joins: 0/0}
$c<$_a41W :: forall a b. a -> Single b -> Single a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)}]
$c<$_a41W
  = \ (@a_a41Z)
      (@b_a420)
      (z_a2hk :: a_a41Z)
      (ds_d4Up :: Single b_a420) ->
      case ds_d4Up of { Single _ [Occ=Dead] ->
      Main.Single @a_a41Z z_a2hk
      }

-- RHS size: {terms: 10, types: 10, coercions: 0, joins: 0/0}
$cfmap_a41M :: forall a b. (a -> b) -> Single a -> Single b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 20] 40 10}]
$cfmap_a41M
  = \ (@a_a41P)
      (@b_a41Q)
      (f_a2hi :: a_a41P -> b_a41Q)
      (ds_d4Un :: Single a_a41P) ->
      case ds_d4Un of { Single a1_a2hj ->
      Main.Single @b_a41Q (f_a2hi a1_a2hj)
      }

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Main.$fFunctorSingle [InlPrag=CONLIKE] :: Functor Single
[LclIdX[DFunId],
 Unf=DFun: \ ->
       GHC.Base.C:Functor TYPE: Single $cfmap_a41M $c<$_a41W]
Main.$fFunctorSingle
  = GHC.Base.C:Functor @Single $cfmap_a41M $c<$_a41W

Rec {
-- RHS size: {terms: 7, types: 1, coercions: 0, joins: 0/0}
Main.$fTraversableSingle [InlPrag=CONLIKE] :: Traversable Single
[LclIdX[DFunId],
 Unf=DFun: \ ->
       Data.Traversable.C:Traversable TYPE: Single
                                      Main.$fFunctorSingle
                                      Main.$fFoldableSingle
                                      $ctraverse_a4r0
                                      $csequenceA_a4rg
                                      $cmapM_a4ru
                                      $csequence_a4rK]
Main.$fTraversableSingle
  = Data.Traversable.C:Traversable
      @Single
      Main.$fFunctorSingle
      Main.$fFoldableSingle
      $ctraverse_a4r0
      $csequenceA_a4rg
      $cmapM_a4ru
      $csequence_a4rK

-- RHS size: {terms: 8, types: 11, coercions: 0, joins: 0/0}
$cmapM_a4ru [Occ=LoopBreaker]
  :: forall (m :: * -> *) a b.
     Monad m =>
     (a -> m b) -> Single a -> m (Single b)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30] 50 0}]
$cmapM_a4ru
  = \ (@(m_a4rx :: * -> *))
      (@a_a4ry)
      (@b_a4rz)
      ($dMonad_a4rA :: Monad m_a4rx) ->
      traverse
        @Single
        Main.$fTraversableSingle
        @m_a4rx
        @a_a4ry
        @b_a4rz
        (GHC.Base.$p1Monad @m_a4rx $dMonad_a4rA)

-- RHS size: {terms: 7, types: 12, coercions: 0, joins: 0/0}
$csequenceA_a4rg [Occ=LoopBreaker]
  :: forall (f :: * -> *) a.
     Applicative f =>
     Single (f a) -> f (Single a)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 40 0}]
$csequenceA_a4rg
  = \ (@(f_a4rj :: * -> *))
      (@a_a4rk)
      ($dApplicative_a4rl :: Applicative f_a4rj) ->
      traverse
        @Single
        Main.$fTraversableSingle
        @f_a4rj
        @(f_a4rj a_a4rk)
        @a_a4rk
        $dApplicative_a4rl
        (id @(f_a4rj a_a4rk))

-- RHS size: {terms: 7, types: 9, coercions: 0, joins: 0/0}
$csequence_a4rK [Occ=LoopBreaker]
  :: forall (m :: * -> *) a. Monad m => Single (m a) -> m (Single a)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30] 50 0}]
$csequence_a4rK
  = \ (@(m_a4rN :: * -> *))
      (@a_a4rO)
      ($dMonad_a4rP :: Monad m_a4rN) ->
      sequenceA
        @Single
        Main.$fTraversableSingle
        @m_a4rN
        @a_a4rO
        (GHC.Base.$p1Monad @m_a4rN $dMonad_a4rP)

-- RHS size: {terms: 18, types: 30, coercions: 0, joins: 0/2}
$ctraverse_a4r0 [Occ=LoopBreaker]
  :: forall (f :: * -> *) a b.
     Applicative f =>
     (a -> f b) -> Single a -> f (Single b)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 150 60}]
$ctraverse_a4r0
  = \ (@(f_a4r3 :: * -> *))
      (@a_a4r4)
      (@b_a4r5)
      ($dApplicative_a4r6 :: Applicative f_a4r3)
      (eta1_a56N :: a_a4r4 -> f_a4r3 b_a4r5) ->
      let {
        f1_a56O :: Single (f_a4r3 b_a4r5) -> f_a4r3 (Single b_a4r5)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 30 0}]
        f1_a56O
          = sequenceA
              @Single
              Main.$fTraversableSingle
              @f_a4r3
              @b_a4r5
              $dApplicative_a4r6 } in
      let {
        g_a56P :: Single a_a4r4 -> Single (f_a4r3 b_a4r5)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 50 0}]
        g_a56P
          = fmap
              @Single
              (Data.Traversable.$p1Traversable @Single Main.$fTraversableSingle)
              @a_a4r4
              @(f_a4r3 b_a4r5)
              eta1_a56N } in
      \ (x_a56Q :: Single a_a4r4) -> f1_a56O (g_a56P x_a56Q)
end Rec }

-- RHS size: {terms: 22, types: 14, coercions: 0, joins: 0/0}
$cshowsPrec_a41i :: forall a. Show a => Int -> Single a -> ShowS
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 0 20] 240 0}]
$cshowsPrec_a41i
  = \ (@a_a41f)
      ($dShow_a41g :: Show a_a41f)
      (a_a2hg :: Int)
      (ds_d4Ui :: Single a_a41f) ->
      case ds_d4Ui of { Single b1_a2hh ->
      showParen
        (>= @Int GHC.Classes.$fOrdInt a_a2hg (GHC.Types.I# 11#))
        (. @String
           @String
           @String
           (showString (GHC.CString.unpackCString# "Single "#))
           (showsPrec @a_a41f $dShow_a41g (GHC.Types.I# 11#) b1_a2hh))
      }

Rec {
-- RHS size: {terms: 9, types: 8, coercions: 0, joins: 0/0}
Main.$fShowSingle [InlPrag=CONLIKE]
  :: forall a. Show a => Show (Single a)
[LclIdX[DFunId],
 Unf=DFun: \ (@a_a1Al) (v_B1 :: Show a_a1Al) ->
       GHC.Show.C:Show TYPE: Single a_a1Al
                       $cshowsPrec_a41i @a_a1Al v_B1
                       $cshow_a41v @a_a1Al v_B1
                       $cshowList_a41C @a_a1Al v_B1]
Main.$fShowSingle
  = \ (@a_a41f) ($dShow_a41g :: Show a_a41f) ->
      GHC.Show.C:Show
        @(Single a_a41f)
        ($cshowsPrec_a41i @a_a41f $dShow_a41g)
        ($cshow_a41v @a_a41f $dShow_a41g)
        ($cshowList_a41C @a_a41f $dShow_a41g)

-- RHS size: {terms: 14, types: 15, coercions: 0, joins: 0/1}
$cshowList_a41C [Occ=LoopBreaker]
  :: forall a. Show a => [Single a] -> ShowS
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 130 60}]
$cshowList_a41C
  = \ (@a_a41f) ($dShow_a41g :: Show a_a41f) ->
      let {
        $dShow_a56S :: Show (Single a_a41f)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dShow_a56S = Main.$fShowSingle @a_a41f $dShow_a41g } in
      \ (ls_a56T :: [Single a_a41f]) (s_a56U :: String) ->
        GHC.Show.showList__
          @(Single a_a41f)
          (showsPrec @(Single a_a41f) $dShow_a56S (GHC.Types.I# 0#))
          ls_a56T
          s_a56U

-- RHS size: {terms: 12, types: 12, coercions: 0, joins: 0/1}
$cshow_a41v [Occ=LoopBreaker]
  :: forall a. Show a => Single a -> String
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 100 60}]
$cshow_a41v
  = \ (@a_a41f) ($dShow_a41g :: Show a_a41f) ->
      let {
        $dShow_a56X :: Show (Single a_a41f)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dShow_a56X = Main.$fShowSingle @a_a41f $dShow_a41g } in
      \ (x_a56Y :: Single a_a41f) ->
        showsPrec
          @(Single a_a41f)
          $dShow_a56X
          (GHC.Types.I# 0#)
          x_a56Y
          (GHC.Types.[] @Char)
end Rec }

-- RHS size: {terms: 14, types: 14, coercions: 0, joins: 0/0}
$c==_a40X :: forall a. Eq a => Single a -> Single a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 20 20] 60 0}]
$c==_a40X
  = \ (@a_a40U)
      ($dEq_a40V :: Eq a_a40U)
      (ds_d4Ua :: Single a_a40U)
      (ds_d4Ub :: Single a_a40U) ->
      case ds_d4Ua of { Single a1_a2he ->
      case ds_d4Ub of { Single b1_a2hf ->
      == @a_a40U $dEq_a40V a1_a2he b1_a2hf
      }
      }

Rec {
-- RHS size: {terms: 7, types: 7, coercions: 0, joins: 0/0}
Main.$fEqSingle [InlPrag=CONLIKE]
  :: forall a. Eq a => Eq (Single a)
[LclIdX[DFunId],
 Unf=DFun: \ (@a_a1Af) (v_B1 :: Eq a_a1Af) ->
       GHC.Classes.C:Eq TYPE: Single a_a1Af
                        $c==_a40X @a_a1Af v_B1
                        $c/=_a416 @a_a1Af v_B1]
Main.$fEqSingle
  = \ (@a_a40U) ($dEq_a40V :: Eq a_a40U) ->
      GHC.Classes.C:Eq
        @(Single a_a40U)
        ($c==_a40X @a_a40U $dEq_a40V)
        ($c/=_a416 @a_a40U $dEq_a40V)

-- RHS size: {terms: 16, types: 14, coercions: 0, joins: 0/1}
$c/=_a416 [Occ=LoopBreaker]
  :: forall a. Eq a => Single a -> Single a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 110 60}]
$c/=_a416
  = \ (@a_a40U) ($dEq_a40V :: Eq a_a40U) ->
      let {
        $dEq_a570 :: Eq (Single a_a40U)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dEq_a570 = Main.$fEqSingle @a_a40U $dEq_a40V } in
      \ (x_a571 :: Single a_a40U) (y_a572 :: Single a_a40U) ->
        case == @(Single a_a40U) $dEq_a570 x_a571 y_a572 of {
          False -> GHC.Types.True;
          True -> GHC.Types.False
        }
end Rec }

-- RHS size: {terms: 6, types: 7, coercions: 0, joins: 0/0}
$cnull_a3ZD :: forall a. Tuple a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)}]
$cnull_a3ZD
  = \ (@a_a3ZG) (ds_d4U3 :: Tuple a_a3ZG) ->
      case ds_d4U3 of { Tuple _ [Occ=Dead] _ [Occ=Dead] ->
      GHC.Types.False
      }

-- RHS size: {terms: 13, types: 12, coercions: 0, joins: 0/0}
$cfoldr_a3Yr :: forall a b. (a -> b -> b) -> b -> Tuple a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 20] 70 0}]
$cfoldr_a3Yr
  = \ (@a_a3Yu)
      (@b_a3Yv)
      (f_a2h7 :: a_a3Yu -> b_a3Yv -> b_a3Yv)
      (z_a2h8 :: b_a3Yv)
      (ds_d4U2 :: Tuple a_a3Yu) ->
      case ds_d4U2 of { Tuple a1_a2h9 a2_a2ha ->
      f_a2h7 a1_a2h9 (f_a2h7 a2_a2ha z_a2h8)
      }

-- RHS size: {terms: 14, types: 13, coercions: 0, joins: 0/0}
$cfoldMap_a3Y1 :: forall m a. Monoid m => (a -> m) -> Tuple a -> m
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 60 20] 90 0}]
$cfoldMap_a3Y1
  = \ (@m_a3Y4)
      (@a_a3Y5)
      ($dMonoid_a3Y6 :: Monoid m_a3Y4)
      (f_a2hb :: a_a3Y5 -> m_a3Y4)
      (ds_d4U1 :: Tuple a_a3Y5) ->
      case ds_d4U1 of { Tuple a1_a2hc a2_a2hd ->
      mappend @m_a3Y4 $dMonoid_a3Y6 (f_a2hb a1_a2hc) (f_a2hb a2_a2hd)
      }

Rec {
-- RHS size: {terms: 18, types: 1, coercions: 0, joins: 0/0}
Main.$fFoldableTuple [InlPrag=CONLIKE] :: Foldable Tuple
[LclIdX[DFunId],
 Unf=DFun: \ ->
       Data.Foldable.C:Foldable TYPE: Tuple
                                $cfold_a3XP
                                $cfoldMap_a3Y1
                                $cfoldMap'_a3Yd
                                $cfoldr_a3Yr
                                $cfoldr'_a3Yz
                                $cfoldl_a3YL
                                $cfoldl'_a3YX
                                $cfoldr1_a3Z9
                                $cfoldl1_a3Zj
                                $ctoList_a3Zt
                                $cnull_a3ZD
                                $clength_a3ZK
                                $celem_a3ZU
                                $cmaximum_a406
                                $cminimum_a40i
                                $csum_a40u
                                $cproduct_a40G]
Main.$fFoldableTuple
  = Data.Foldable.C:Foldable
      @Tuple
      $cfold_a3XP
      $cfoldMap_a3Y1
      $cfoldMap'_a3Yd
      $cfoldr_a3Yr
      $cfoldr'_a3Yz
      $cfoldl_a3YL
      $cfoldl'_a3YX
      $cfoldr1_a3Z9
      $cfoldl1_a3Zj
      $ctoList_a3Zt
      $cnull_a3ZD
      $clength_a3ZK
      $celem_a3ZU
      $cmaximum_a406
      $cminimum_a40i
      $csum_a40u
      $cproduct_a40G

-- RHS size: {terms: 14, types: 18, coercions: 25, joins: 0/0}
$csum_a40u [Occ=LoopBreaker] :: forall a. Num a => Tuple a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 120 60}]
$csum_a40u
  = \ (@a_a40x) ($dNum_a40y :: Num a_a40x) ->
      ((\ (@(t_a4WR :: * -> *))
          ($dFoldable_a4WS :: Foldable t_a4WR)
          (@a_a4WT)
          ($dNum_a4WU :: Num a_a4WT) ->
          Data.Foldable.foldMap'
            @t_a4WR
            $dFoldable_a4WS
            @(base:Data.Semigroup.Internal.Sum a_a4WT)
            @a_a4WT
            (base:Data.Semigroup.Internal.$fMonoidSum @a_a4WT $dNum_a4WU)
            ((\ (ds_a52f :: a_a4WT) -> ds_a52f)
             `cast` (<a_a4WT>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Sum[0]
                                              <a_a4WT>_R)
                     :: (a_a4WT -> a_a4WT)
                        ~R# (a_a4WT -> base:Data.Semigroup.Internal.Sum a_a4WT))))
       `cast` (forall (t :: <* -> *>_N).
               <Foldable t>_R
               %<'Many>_N ->_R forall (a :: <*>_N).
                               <Num a>_R
                               %<'Many>_N ->_R <t a>_R
                               %<'Many>_N ->_R base:Data.Semigroup.Internal.N:Sum[0] <a>_R
               :: (forall {t :: * -> *} {a}.
                   (Foldable t, Num a) =>
                   t a -> base:Data.Semigroup.Internal.Sum a)
                  ~R# (forall {t :: * -> *} {a}. (Foldable t, Num a) => t a -> a)))
        @Tuple Main.$fFoldableTuple @a_a40x $dNum_a40y

-- RHS size: {terms: 24, types: 25, coercions: 8, joins: 0/2}
$cminimum_a40i [Occ=LoopBreaker] :: forall a. Ord a => Tuple a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 260 60}]
$cminimum_a40i
  = \ (@a_a40l) ($dOrd_a40m :: Ord a_a40l) ->
      let {
        d_a52o :: a_a40l
        [LclId,
         Str=b,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 110 0}]
        d_a52o
          = errorWithoutStackTrace
              @GHC.Types.LiftedRep
              @a_a40l
              (GHC.Base.build
                 @Char
                 (\ (@b_a52t) ->
                    GHC.CString.unpackFoldrCString#
                      @b_a52t "minimum: empty structure"#)) } in
      let {
        g_a52v :: Tuple a_a40l -> base:Data.Functor.Utils.Min a_a40l
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 80 0}]
        g_a52v
          = Data.Foldable.foldMap'
              @Tuple
              Main.$fFoldableTuple
              @(base:Data.Functor.Utils.Min a_a40l)
              @a_a40l
              (base:Data.Functor.Utils.$fMonoidMin @a_a40l $dOrd_a40m)
              ((\ (ds_a53M :: a_a40l) -> GHC.Maybe.Just @a_a40l ds_a53M)
               `cast` (<a_a40l>_R
                       %<'Many>_N ->_R Sym (base:Data.Functor.Utils.N:Min[0]) <a_a40l>_N
                       :: (a_a40l -> GHC.Maybe.Maybe a_a40l)
                          ~R# (a_a40l -> base:Data.Functor.Utils.Min a_a40l))) } in
      \ (x_a53N :: Tuple a_a40l) ->
        case (g_a52v x_a53N)
             `cast` (base:Data.Functor.Utils.N:Min[0] <a_a40l>_N
                     :: base:Data.Functor.Utils.Min a_a40l ~R# GHC.Maybe.Maybe a_a40l)
        of {
          GHC.Maybe.Nothing -> d_a52o;
          GHC.Maybe.Just v_a54h -> v_a54h
        }

-- RHS size: {terms: 24, types: 25, coercions: 8, joins: 0/2}
$cmaximum_a406 [Occ=LoopBreaker] :: forall a. Ord a => Tuple a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 260 60}]
$cmaximum_a406
  = \ (@a_a409) ($dOrd_a40a :: Ord a_a409) ->
      let {
        d_a54n :: a_a409
        [LclId,
         Str=b,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 110 0}]
        d_a54n
          = errorWithoutStackTrace
              @GHC.Types.LiftedRep
              @a_a409
              (GHC.Base.build
                 @Char
                 (\ (@b_a54o) ->
                    GHC.CString.unpackFoldrCString#
                      @b_a54o "maximum: empty structure"#)) } in
      let {
        g_a54p :: Tuple a_a409 -> base:Data.Functor.Utils.Max a_a409
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 80 0}]
        g_a54p
          = Data.Foldable.foldMap'
              @Tuple
              Main.$fFoldableTuple
              @(base:Data.Functor.Utils.Max a_a409)
              @a_a409
              (base:Data.Functor.Utils.$fMonoidMax @a_a409 $dOrd_a40a)
              ((\ (ds_a54r :: a_a409) -> GHC.Maybe.Just @a_a409 ds_a54r)
               `cast` (<a_a409>_R
                       %<'Many>_N ->_R Sym (base:Data.Functor.Utils.N:Max[0]) <a_a409>_N
                       :: (a_a409 -> GHC.Maybe.Maybe a_a409)
                          ~R# (a_a409 -> base:Data.Functor.Utils.Max a_a409))) } in
      \ (x_a54s :: Tuple a_a409) ->
        case (g_a54p x_a54s)
             `cast` (base:Data.Functor.Utils.N:Max[0] <a_a409>_N
                     :: base:Data.Functor.Utils.Max a_a409 ~R# GHC.Maybe.Maybe a_a409)
        of {
          GHC.Maybe.Nothing -> d_a54n;
          GHC.Maybe.Just v_a54x -> v_a54x
        }

-- RHS size: {terms: 15, types: 17, coercions: 26, joins: 0/0}
$celem_a3ZU [Occ=LoopBreaker]
  :: forall a. Eq a => a -> Tuple a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 130 60}]
$celem_a3ZU
  = \ (@a_a3ZX) ($dEq_a3ZY :: Eq a_a3ZX) ->
      ((\ (@(t_a54z :: * -> *))
          ($dFoldable_a54A :: Foldable t_a54z)
          (@a_a54B)
          ($dEq_a54C :: Eq a_a54B)
          (eta_a54D :: a_a54B) ->
          foldMap
            @t_a54z
            $dFoldable_a54A
            @base:Data.Semigroup.Internal.Any
            @a_a54B
            base:Data.Semigroup.Internal.$fMonoidAny
            ((== @a_a54B $dEq_a54C eta_a54D)
             `cast` (<a_a54B>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Any[0])
                     :: (a_a54B -> Bool)
                        ~R# (a_a54B -> base:Data.Semigroup.Internal.Any))))
       `cast` (forall (t :: <* -> *>_N).
               <Foldable t>_R
               %<'Many>_N ->_R forall (a :: <*>_N).
                               <Eq a>_R
                               %<'Many>_N ->_R <a>_R
                               %<'Many>_N ->_R <t a>_R
                               %<'Many>_N ->_R base:Data.Semigroup.Internal.N:Any[0]
               :: (forall {t :: * -> *} {a}.
                   (Foldable t, Eq a) =>
                   a -> t a -> base:Data.Semigroup.Internal.Any)
                  ~R# (forall {t :: * -> *} {a}.
                       (Foldable t, Eq a) =>
                       a -> t a -> Bool)))
        @Tuple Main.$fFoldableTuple @a_a3ZX $dEq_a3ZY

-- RHS size: {terms: 14, types: 8, coercions: 0, joins: 0/0}
$clength_a3ZK [Occ=LoopBreaker] :: forall a. Tuple a -> Int
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=False, ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 91 0}]
$clength_a3ZK
  = \ (@a_a3ZN) ->
      Data.Foldable.foldl'
        @Tuple
        Main.$fFoldableTuple
        @Int
        @a_a3ZN
        (\ (c_a54K :: Int) _ [Occ=Dead] ->
           case c_a54K of { GHC.Types.I# x_a54N ->
           GHC.Types.I# (GHC.Prim.+# x_a54N 1#)
           })
        (GHC.Types.I# 0#)

-- RHS size: {terms: 11, types: 12, coercions: 0, joins: 0/0}
$ctoList_a3Zt [Occ=LoopBreaker] :: forall a. Tuple a -> [a]
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 70 40}]
$ctoList_a3Zt
  = \ (@a_a3Zw) (t1_a54S :: Tuple a_a3Zw) ->
      GHC.Base.build
        @a_a3Zw
        (\ (@b_a54T)
           (c_a54U [OS=OneShot] :: a_a3Zw -> b_a54T -> b_a54T)
           (n_a54V [OS=OneShot] :: b_a54T) ->
           foldr
             @Tuple Main.$fFoldableTuple @a_a3Zw @b_a54T c_a54U n_a54V t1_a54S)

-- RHS size: {terms: 27, types: 26, coercions: 0, joins: 0/0}
$cfoldl1_a3Zj [Occ=LoopBreaker]
  :: forall a. (a -> a -> a) -> Tuple a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0] 260 0}]
$cfoldl1_a3Zj
  = \ (@a_a3Zm)
      (f_a54Z :: a_a3Zm -> a_a3Zm -> a_a3Zm)
      (xs_a550 :: Tuple a_a3Zm) ->
      case foldl
             @Tuple
             Main.$fFoldableTuple
             @(GHC.Maybe.Maybe a_a3Zm)
             @a_a3Zm
             (\ (m_a551 :: GHC.Maybe.Maybe a_a3Zm) (y_a552 :: a_a3Zm) ->
                GHC.Maybe.Just
                  @a_a3Zm
                  (case m_a551 of {
                     GHC.Maybe.Nothing -> y_a552;
                     GHC.Maybe.Just x_a555 -> f_a54Z x_a555 y_a552
                   }))
             (GHC.Maybe.Nothing @a_a3Zm)
             xs_a550
      of {
        GHC.Maybe.Nothing ->
          errorWithoutStackTrace
            @GHC.Types.LiftedRep
            @a_a3Zm
            (GHC.Base.build
               @Char
               (\ (@b_a558) ->
                  GHC.CString.unpackFoldrCString#
                    @b_a558 "foldl1: empty structure"#));
        GHC.Maybe.Just v_a559 -> v_a559
      }

-- RHS size: {terms: 27, types: 26, coercions: 0, joins: 0/0}
$cfoldr1_a3Z9 [Occ=LoopBreaker]
  :: forall a. (a -> a -> a) -> Tuple a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0] 260 0}]
$cfoldr1_a3Z9
  = \ (@a_a3Zc)
      (f_a55f :: a_a3Zc -> a_a3Zc -> a_a3Zc)
      (xs_a55g :: Tuple a_a3Zc) ->
      case foldr
             @Tuple
             Main.$fFoldableTuple
             @a_a3Zc
             @(GHC.Maybe.Maybe a_a3Zc)
             (\ (x_a55h :: a_a3Zc) (m_a55i :: GHC.Maybe.Maybe a_a3Zc) ->
                GHC.Maybe.Just
                  @a_a3Zc
                  (case m_a55i of {
                     GHC.Maybe.Nothing -> x_a55h;
                     GHC.Maybe.Just y_a55l -> f_a55f x_a55h y_a55l
                   }))
             (GHC.Maybe.Nothing @a_a3Zc)
             xs_a55g
      of {
        GHC.Maybe.Nothing ->
          errorWithoutStackTrace
            @GHC.Types.LiftedRep
            @a_a3Zc
            (GHC.Base.build
               @Char
               (\ (@b_a55o) ->
                  GHC.CString.unpackFoldrCString#
                    @b_a55o "foldr1: empty structure"#));
        GHC.Maybe.Just v_a55p -> v_a55p
      }

-- RHS size: {terms: 20, types: 18, coercions: 0, joins: 0/0}
$cfoldl'_a3YX [Occ=LoopBreaker]
  :: forall b a. (b -> a -> b) -> b -> Tuple a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 150 0}]
$cfoldl'_a3YX
  = \ (@b_a3Z0)
      (@a_a3Z1)
      (f_a55w :: b_a3Z0 -> a_a3Z1 -> b_a3Z0)
      (z0_a55x :: b_a3Z0)
      (xs_a55y :: Tuple a_a3Z1) ->
      foldr
        @Tuple
        Main.$fFoldableTuple
        @a_a3Z1
        @(b_a3Z0 -> b_a3Z0)
        (\ (ds_a55z :: a_a3Z1)
           (ds1_a55A :: b_a3Z0 -> b_a3Z0)
           (v_a55B [OS=OneShot] :: b_a3Z0) ->
           case v_a55B of z_a55C { __DEFAULT ->
           ds1_a55A (f_a55w z_a55C ds_a55z)
           })
        (id @b_a3Z0)
        xs_a55y
        z0_a55x

-- RHS size: {terms: 16, types: 18, coercions: 10, joins: 0/0}
$cfoldl_a3YL [Occ=LoopBreaker]
  :: forall b a. (b -> a -> b) -> b -> Tuple a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 130 0}]
$cfoldl_a3YL
  = \ (@b_a3YO)
      (@a_a3YP)
      (eta_a55I :: b_a3YO -> a_a3YP -> b_a3YO)
      (eta1_a55J :: b_a3YO)
      (eta2_a55K :: Tuple a_a3YP) ->
      ((foldMap
          @Tuple
          Main.$fFoldableTuple
          @(base:Data.Semigroup.Internal.Dual
              (base:Data.Semigroup.Internal.Endo b_a3YO))
          @a_a3YP
          (base:Data.Semigroup.Internal.$fMonoidDual
             @(base:Data.Semigroup.Internal.Endo b_a3YO)
             (base:Data.Semigroup.Internal.$fMonoidEndo @b_a3YO))
          ((\ (x_a55N :: a_a3YP) (y_a55O :: b_a3YO) ->
              eta_a55I y_a55O x_a55N)
           `cast` (<a_a3YP>_R
                   %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Dual[0]
                                            (base:Data.Semigroup.Internal.N:Endo[0] <b_a3YO>_R))
                   :: (a_a3YP -> b_a3YO -> b_a3YO)
                      ~R# (a_a3YP
                           -> base:Data.Semigroup.Internal.Dual
                                (base:Data.Semigroup.Internal.Endo b_a3YO))))
          eta2_a55K)
       `cast` (base:Data.Semigroup.Internal.N:Dual[0]
                   (base:Data.Semigroup.Internal.N:Endo[0] <b_a3YO>_R)
               :: base:Data.Semigroup.Internal.Dual
                    (base:Data.Semigroup.Internal.Endo b_a3YO)
                  ~R# (b_a3YO -> b_a3YO)))
        eta1_a55J

-- RHS size: {terms: 20, types: 18, coercions: 0, joins: 0/0}
$cfoldr'_a3Yz [Occ=LoopBreaker]
  :: forall a b. (a -> b -> b) -> b -> Tuple a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 150 0}]
$cfoldr'_a3Yz
  = \ (@a_a3YC)
      (@b_a3YD)
      (f_a55X :: a_a3YC -> b_a3YD -> b_a3YD)
      (z0_a55Y :: b_a3YD)
      (xs_a55Z :: Tuple a_a3YC) ->
      foldl
        @Tuple
        Main.$fFoldableTuple
        @(b_a3YD -> b_a3YD)
        @a_a3YC
        (\ (ds_a560 :: b_a3YD -> b_a3YD)
           (ds1_a561 :: a_a3YC)
           (v_a562 [OS=OneShot] :: b_a3YD) ->
           case v_a562 of z_a563 { __DEFAULT ->
           ds_a560 (f_a55X ds1_a561 z_a563)
           })
        (id @b_a3YD)
        xs_a55Z
        z0_a55Y

-- RHS size: {terms: 18, types: 16, coercions: 0, joins: 0/1}
$cfoldMap'_a3Yd [Occ=LoopBreaker]
  :: forall m a. Monoid m => (a -> m) -> Tuple a -> m
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 60] 170 0}]
$cfoldMap'_a3Yd
  = \ (@m_a3Yg)
      (@a_a3Yh)
      ($dMonoid_a3Yi :: Monoid m_a3Yg)
      (eta_a569 :: a_a3Yh -> m_a3Yg) ->
      let {
        $dSemigroup_a56a :: Semigroup m_a3Yg
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dSemigroup_a56a = GHC.Base.$p1Monoid @m_a3Yg $dMonoid_a3Yi } in
      Data.Foldable.foldl'
        @Tuple
        Main.$fFoldableTuple
        @m_a3Yg
        @a_a3Yh
        (\ (acc_a56b :: m_a3Yg) (a1_a56c :: a_a3Yh) ->
           <> @m_a3Yg $dSemigroup_a56a acc_a56b (eta_a569 a1_a56c))
        (mempty @m_a3Yg $dMonoid_a3Yi)

-- RHS size: {terms: 14, types: 18, coercions: 25, joins: 0/0}
$cproduct_a40G [Occ=LoopBreaker] :: forall a. Num a => Tuple a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 120 60}]
$cproduct_a40G
  = \ (@a_a40J) ($dNum_a40K :: Num a_a40J) ->
      ((\ (@(t_a56d :: * -> *))
          ($dFoldable_a56e :: Foldable t_a56d)
          (@a_a56f)
          ($dNum_a56g :: Num a_a56f) ->
          Data.Foldable.foldMap'
            @t_a56d
            $dFoldable_a56e
            @(base:Data.Semigroup.Internal.Product a_a56f)
            @a_a56f
            (base:Data.Semigroup.Internal.$fMonoidProduct @a_a56f $dNum_a56g)
            ((\ (ds_a56i :: a_a56f) -> ds_a56i)
             `cast` (<a_a56f>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Product[0]
                                              <a_a56f>_R)
                     :: (a_a56f -> a_a56f)
                        ~R# (a_a56f -> base:Data.Semigroup.Internal.Product a_a56f))))
       `cast` (forall (t :: <* -> *>_N).
               <Foldable t>_R
               %<'Many>_N ->_R forall (a :: <*>_N).
                               <Num a>_R
                               %<'Many>_N ->_R <t a>_R
                               %<'Many>_N ->_R base:Data.Semigroup.Internal.N:Product[0] <a>_R
               :: (forall {t :: * -> *} {a}.
                   (Foldable t, Num a) =>
                   t a -> base:Data.Semigroup.Internal.Product a)
                  ~R# (forall {t :: * -> *} {a}. (Foldable t, Num a) => t a -> a)))
        @Tuple Main.$fFoldableTuple @a_a40J $dNum_a40K

-- RHS size: {terms: 6, types: 7, coercions: 0, joins: 0/0}
$cfold_a3XP [Occ=LoopBreaker] :: forall m. Monoid m => Tuple m -> m
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 40 0}]
$cfold_a3XP
  = \ (@m_a3XS) ($dMonoid_a3XT :: Monoid m_a3XS) ->
      foldMap
        @Tuple
        Main.$fFoldableTuple
        @m_a3XS
        @m_a3XS
        $dMonoid_a3XT
        (id @m_a3XS)
end Rec }

-- RHS size: {terms: 10, types: 10, coercions: 0, joins: 0/0}
$c<$_a3XB :: forall a b. a -> Tuple b -> Tuple a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)}]
$c<$_a3XB
  = \ (@a_a3XE)
      (@b_a3XF)
      (z_a2h4 :: a_a3XE)
      (ds_d4TY :: Tuple b_a3XF) ->
      case ds_d4TY of { Tuple _ [Occ=Dead] _ [Occ=Dead] ->
      Main.Tuple @a_a3XE z_a2h4 z_a2h4
      }

-- RHS size: {terms: 12, types: 11, coercions: 0, joins: 0/0}
$cfmap_a3Xq :: forall a b. (a -> b) -> Tuple a -> Tuple b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 20] 60 10}]
$cfmap_a3Xq
  = \ (@a_a3Xt)
      (@b_a3Xu)
      (f_a2h1 :: a_a3Xt -> b_a3Xu)
      (ds_d4TV :: Tuple a_a3Xt) ->
      case ds_d4TV of { Tuple a1_a2h2 a2_a2h3 ->
      Main.Tuple @b_a3Xu (f_a2h1 a1_a2h2) (f_a2h1 a2_a2h3)
      }

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Main.$fFunctorTuple [InlPrag=CONLIKE] :: Functor Tuple
[LclIdX[DFunId],
 Unf=DFun: \ ->
       GHC.Base.C:Functor TYPE: Tuple $cfmap_a3Xq $c<$_a3XB]
Main.$fFunctorTuple
  = GHC.Base.C:Functor @Tuple $cfmap_a3Xq $c<$_a3XB

Rec {
-- RHS size: {terms: 7, types: 1, coercions: 0, joins: 0/0}
Main.$fTraversableTuple [InlPrag=CONLIKE] :: Traversable Tuple
[LclIdX[DFunId],
 Unf=DFun: \ ->
       Data.Traversable.C:Traversable TYPE: Tuple
                                      Main.$fFunctorTuple
                                      Main.$fFoldableTuple
                                      $ctraverse_a4pR
                                      $csequenceA_a4q7
                                      $cmapM_a4ql
                                      $csequence_a4qB]
Main.$fTraversableTuple
  = Data.Traversable.C:Traversable
      @Tuple
      Main.$fFunctorTuple
      Main.$fFoldableTuple
      $ctraverse_a4pR
      $csequenceA_a4q7
      $cmapM_a4ql
      $csequence_a4qB

-- RHS size: {terms: 8, types: 11, coercions: 0, joins: 0/0}
$cmapM_a4ql [Occ=LoopBreaker]
  :: forall (m :: * -> *) a b.
     Monad m =>
     (a -> m b) -> Tuple a -> m (Tuple b)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30] 50 0}]
$cmapM_a4ql
  = \ (@(m_a4qo :: * -> *))
      (@a_a4qp)
      (@b_a4qq)
      ($dMonad_a4qr :: Monad m_a4qo) ->
      traverse
        @Tuple
        Main.$fTraversableTuple
        @m_a4qo
        @a_a4qp
        @b_a4qq
        (GHC.Base.$p1Monad @m_a4qo $dMonad_a4qr)

-- RHS size: {terms: 7, types: 12, coercions: 0, joins: 0/0}
$csequenceA_a4q7 [Occ=LoopBreaker]
  :: forall (f :: * -> *) a.
     Applicative f =>
     Tuple (f a) -> f (Tuple a)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 40 0}]
$csequenceA_a4q7
  = \ (@(f_a4qa :: * -> *))
      (@a_a4qb)
      ($dApplicative_a4qc :: Applicative f_a4qa) ->
      traverse
        @Tuple
        Main.$fTraversableTuple
        @f_a4qa
        @(f_a4qa a_a4qb)
        @a_a4qb
        $dApplicative_a4qc
        (id @(f_a4qa a_a4qb))

-- RHS size: {terms: 7, types: 9, coercions: 0, joins: 0/0}
$csequence_a4qB [Occ=LoopBreaker]
  :: forall (m :: * -> *) a. Monad m => Tuple (m a) -> m (Tuple a)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30] 50 0}]
$csequence_a4qB
  = \ (@(m_a4qE :: * -> *))
      (@a_a4qF)
      ($dMonad_a4qG :: Monad m_a4qE) ->
      sequenceA
        @Tuple
        Main.$fTraversableTuple
        @m_a4qE
        @a_a4qF
        (GHC.Base.$p1Monad @m_a4qE $dMonad_a4qG)

-- RHS size: {terms: 18, types: 30, coercions: 0, joins: 0/2}
$ctraverse_a4pR [Occ=LoopBreaker]
  :: forall (f :: * -> *) a b.
     Applicative f =>
     (a -> f b) -> Tuple a -> f (Tuple b)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 150 60}]
$ctraverse_a4pR
  = \ (@(f_a4pU :: * -> *))
      (@a_a4pV)
      (@b_a4pW)
      ($dApplicative_a4pX :: Applicative f_a4pU)
      (eta1_a56N :: a_a4pV -> f_a4pU b_a4pW) ->
      let {
        f1_a56O :: Tuple (f_a4pU b_a4pW) -> f_a4pU (Tuple b_a4pW)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 30 0}]
        f1_a56O
          = sequenceA
              @Tuple
              Main.$fTraversableTuple
              @f_a4pU
              @b_a4pW
              $dApplicative_a4pX } in
      let {
        g_a56P :: Tuple a_a4pV -> Tuple (f_a4pU b_a4pW)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 50 0}]
        g_a56P
          = fmap
              @Tuple
              (Data.Traversable.$p1Traversable @Tuple Main.$fTraversableTuple)
              @a_a4pV
              @(f_a4pU b_a4pW)
              eta1_a56N } in
      \ (x_a56Q :: Tuple a_a4pV) -> f1_a56O (g_a56P x_a56Q)
end Rec }

-- RHS size: {terms: 30, types: 22, coercions: 0, joins: 0/0}
$cshowsPrec_a3WO :: forall a. Show a => Int -> Tuple a -> ShowS
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 20] 350 0}]
$cshowsPrec_a3WO
  = \ (@a_a3WL)
      ($dShow_a3WM :: Show a_a3WL)
      (a_a2gY :: Int)
      (ds_d4TQ :: Tuple a_a3WL) ->
      case ds_d4TQ of { Tuple b1_a2gZ b2_a2h0 ->
      showParen
        (>= @Int GHC.Classes.$fOrdInt a_a2gY (GHC.Types.I# 11#))
        (. @String
           @String
           @String
           (showString (GHC.CString.unpackCString# "Tuple "#))
           (. @String
              @String
              @String
              (showsPrec @a_a3WL $dShow_a3WM (GHC.Types.I# 11#) b1_a2gZ)
              (. @String
                 @String
                 @String
                 GHC.Show.showSpace
                 (showsPrec @a_a3WL $dShow_a3WM (GHC.Types.I# 11#) b2_a2h0))))
      }

Rec {
-- RHS size: {terms: 9, types: 8, coercions: 0, joins: 0/0}
Main.$fShowTuple [InlPrag=CONLIKE]
  :: forall a. Show a => Show (Tuple a)
[LclIdX[DFunId],
 Unf=DFun: \ (@a_a1zZ) (v_B1 :: Show a_a1zZ) ->
       GHC.Show.C:Show TYPE: Tuple a_a1zZ
                       $cshowsPrec_a3WO @a_a1zZ v_B1
                       $cshow_a3X9 @a_a1zZ v_B1
                       $cshowList_a3Xg @a_a1zZ v_B1]
Main.$fShowTuple
  = \ (@a_a3WL) ($dShow_a3WM :: Show a_a3WL) ->
      GHC.Show.C:Show
        @(Tuple a_a3WL)
        ($cshowsPrec_a3WO @a_a3WL $dShow_a3WM)
        ($cshow_a3X9 @a_a3WL $dShow_a3WM)
        ($cshowList_a3Xg @a_a3WL $dShow_a3WM)

-- RHS size: {terms: 14, types: 15, coercions: 0, joins: 0/1}
$cshowList_a3Xg [Occ=LoopBreaker]
  :: forall a. Show a => [Tuple a] -> ShowS
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 130 60}]
$cshowList_a3Xg
  = \ (@a_a3WL) ($dShow_a3WM :: Show a_a3WL) ->
      let {
        $dShow_a56S :: Show (Tuple a_a3WL)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dShow_a56S = Main.$fShowTuple @a_a3WL $dShow_a3WM } in
      \ (ls_a56T :: [Tuple a_a3WL]) (s_a56U :: String) ->
        GHC.Show.showList__
          @(Tuple a_a3WL)
          (showsPrec @(Tuple a_a3WL) $dShow_a56S (GHC.Types.I# 0#))
          ls_a56T
          s_a56U

-- RHS size: {terms: 12, types: 12, coercions: 0, joins: 0/1}
$cshow_a3X9 [Occ=LoopBreaker]
  :: forall a. Show a => Tuple a -> String
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 100 60}]
$cshow_a3X9
  = \ (@a_a3WL) ($dShow_a3WM :: Show a_a3WL) ->
      let {
        $dShow_a56X :: Show (Tuple a_a3WL)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dShow_a56X = Main.$fShowTuple @a_a3WL $dShow_a3WM } in
      \ (x_a56Y :: Tuple a_a3WL) ->
        showsPrec
          @(Tuple a_a3WL)
          $dShow_a56X
          (GHC.Types.I# 0#)
          x_a56Y
          (GHC.Types.[] @Char)
end Rec }

-- RHS size: {terms: 19, types: 17, coercions: 0, joins: 0/0}
$c==_a3Wr :: forall a. Eq a => Tuple a -> Tuple a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 20 20] 130 0}]
$c==_a3Wr
  = \ (@a_a3Wo)
      ($dEq_a3Wp :: Eq a_a3Wo)
      (ds_d4TI :: Tuple a_a3Wo)
      (ds_d4TJ :: Tuple a_a3Wo) ->
      case ds_d4TI of { Tuple a1_a2gU a2_a2gV ->
      case ds_d4TJ of { Tuple b1_a2gW b2_a2gX ->
      &&
        (== @a_a3Wo $dEq_a3Wp a1_a2gU b1_a2gW)
        (== @a_a3Wo $dEq_a3Wp a2_a2gV b2_a2gX)
      }
      }

Rec {
-- RHS size: {terms: 7, types: 7, coercions: 0, joins: 0/0}
Main.$fEqTuple [InlPrag=CONLIKE] :: forall a. Eq a => Eq (Tuple a)
[LclIdX[DFunId],
 Unf=DFun: \ (@a_a1zT) (v_B1 :: Eq a_a1zT) ->
       GHC.Classes.C:Eq TYPE: Tuple a_a1zT
                        $c==_a3Wr @a_a1zT v_B1
                        $c/=_a3WC @a_a1zT v_B1]
Main.$fEqTuple
  = \ (@a_a3Wo) ($dEq_a3Wp :: Eq a_a3Wo) ->
      GHC.Classes.C:Eq
        @(Tuple a_a3Wo)
        ($c==_a3Wr @a_a3Wo $dEq_a3Wp)
        ($c/=_a3WC @a_a3Wo $dEq_a3Wp)

-- RHS size: {terms: 16, types: 14, coercions: 0, joins: 0/1}
$c/=_a3WC [Occ=LoopBreaker]
  :: forall a. Eq a => Tuple a -> Tuple a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 110 60}]
$c/=_a3WC
  = \ (@a_a3Wo) ($dEq_a3Wp :: Eq a_a3Wo) ->
      let {
        $dEq_a570 :: Eq (Tuple a_a3Wo)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dEq_a570 = Main.$fEqTuple @a_a3Wo $dEq_a3Wp } in
      \ (x_a571 :: Tuple a_a3Wo) (y_a572 :: Tuple a_a3Wo) ->
        case == @(Tuple a_a3Wo) $dEq_a570 x_a571 y_a572 of {
          False -> GHC.Types.True;
          True -> GHC.Types.False
        }
end Rec }

-- RHS size: {terms: 6, types: 10, coercions: 0, joins: 0/0}
$cnull_a3V7 :: forall a. Quintuple a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)}]
$cnull_a3V7
  = \ (@a_a3Va) (ds_d4Ty :: Quintuple a_a3Va) ->
      case ds_d4Ty of
      { Quintuple _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead]
                  _ [Occ=Dead] ->
      GHC.Types.False
      }

-- RHS size: {terms: 19, types: 15, coercions: 0, joins: 0/0}
$cfoldr_a3TV :: forall a b. (a -> b -> b) -> b -> Quintuple a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 20] 160 0}]
$cfoldr_a3TV
  = \ (@a_a3TY)
      (@b_a3TZ)
      (f_a2gH :: a_a3TY -> b_a3TZ -> b_a3TZ)
      (z_a2gI :: b_a3TZ)
      (ds_d4Tx :: Quintuple a_a3TY) ->
      case ds_d4Tx of
      { Quintuple a1_a2gJ a2_a2gK a3_a2gL a4_a2gM a5_a2gN ->
      f_a2gH
        a1_a2gJ
        (f_a2gH
           a2_a2gK (f_a2gH a3_a2gL (f_a2gH a4_a2gM (f_a2gH a5_a2gN z_a2gI))))
      }

-- RHS size: {terms: 26, types: 19, coercions: 0, joins: 0/0}
$cfoldMap_a3Tp
  :: forall m a. Monoid m => (a -> m) -> Quintuple a -> m
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [120 60 20] 270 0}]
$cfoldMap_a3Tp
  = \ (@m_a3Ts)
      (@a_a3Tt)
      ($dMonoid_a3Tu :: Monoid m_a3Ts)
      (f_a2gO :: a_a3Tt -> m_a3Ts)
      (ds_d4Tw :: Quintuple a_a3Tt) ->
      case ds_d4Tw of
      { Quintuple a1_a2gP a2_a2gQ a3_a2gR a4_a2gS a5_a2gT ->
      mappend
        @m_a3Ts
        $dMonoid_a3Tu
        (f_a2gO a1_a2gP)
        (mappend
           @m_a3Ts
           $dMonoid_a3Tu
           (f_a2gO a2_a2gQ)
           (mappend
              @m_a3Ts
              $dMonoid_a3Tu
              (f_a2gO a3_a2gR)
              (mappend @m_a3Ts $dMonoid_a3Tu (f_a2gO a4_a2gS) (f_a2gO a5_a2gT))))
      }

Rec {
-- RHS size: {terms: 18, types: 1, coercions: 0, joins: 0/0}
Main.$fFoldableQuintuple [InlPrag=CONLIKE] :: Foldable Quintuple
[LclIdX[DFunId],
 Unf=DFun: \ ->
       Data.Foldable.C:Foldable TYPE: Quintuple
                                $cfold_a3Td
                                $cfoldMap_a3Tp
                                $cfoldMap'_a3TH
                                $cfoldr_a3TV
                                $cfoldr'_a3U3
                                $cfoldl_a3Uf
                                $cfoldl'_a3Ur
                                $cfoldr1_a3UD
                                $cfoldl1_a3UN
                                $ctoList_a3UX
                                $cnull_a3V7
                                $clength_a3Ve
                                $celem_a3Vo
                                $cmaximum_a3VA
                                $cminimum_a3VM
                                $csum_a3VY
                                $cproduct_a3Wa]
Main.$fFoldableQuintuple
  = Data.Foldable.C:Foldable
      @Quintuple
      $cfold_a3Td
      $cfoldMap_a3Tp
      $cfoldMap'_a3TH
      $cfoldr_a3TV
      $cfoldr'_a3U3
      $cfoldl_a3Uf
      $cfoldl'_a3Ur
      $cfoldr1_a3UD
      $cfoldl1_a3UN
      $ctoList_a3UX
      $cnull_a3V7
      $clength_a3Ve
      $celem_a3Vo
      $cmaximum_a3VA
      $cminimum_a3VM
      $csum_a3VY
      $cproduct_a3Wa

-- RHS size: {terms: 14, types: 18, coercions: 25, joins: 0/0}
$csum_a3VY [Occ=LoopBreaker] :: forall a. Num a => Quintuple a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 120 60}]
$csum_a3VY
  = \ (@a_a3W1) ($dNum_a3W2 :: Num a_a3W1) ->
      ((\ (@(t_a4WR :: * -> *))
          ($dFoldable_a4WS :: Foldable t_a4WR)
          (@a_a4WT)
          ($dNum_a4WU :: Num a_a4WT) ->
          Data.Foldable.foldMap'
            @t_a4WR
            $dFoldable_a4WS
            @(base:Data.Semigroup.Internal.Sum a_a4WT)
            @a_a4WT
            (base:Data.Semigroup.Internal.$fMonoidSum @a_a4WT $dNum_a4WU)
            ((\ (ds_a52f :: a_a4WT) -> ds_a52f)
             `cast` (<a_a4WT>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Sum[0]
                                              <a_a4WT>_R)
                     :: (a_a4WT -> a_a4WT)
                        ~R# (a_a4WT -> base:Data.Semigroup.Internal.Sum a_a4WT))))
       `cast` (forall (t :: <* -> *>_N).
               <Foldable t>_R
               %<'Many>_N ->_R forall (a :: <*>_N).
                               <Num a>_R
                               %<'Many>_N ->_R <t a>_R
                               %<'Many>_N ->_R base:Data.Semigroup.Internal.N:Sum[0] <a>_R
               :: (forall {t :: * -> *} {a}.
                   (Foldable t, Num a) =>
                   t a -> base:Data.Semigroup.Internal.Sum a)
                  ~R# (forall {t :: * -> *} {a}. (Foldable t, Num a) => t a -> a)))
        @Quintuple Main.$fFoldableQuintuple @a_a3W1 $dNum_a3W2

-- RHS size: {terms: 24, types: 25, coercions: 8, joins: 0/2}
$cminimum_a3VM [Occ=LoopBreaker]
  :: forall a. Ord a => Quintuple a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 260 60}]
$cminimum_a3VM
  = \ (@a_a3VP) ($dOrd_a3VQ :: Ord a_a3VP) ->
      let {
        d_a52o :: a_a3VP
        [LclId,
         Str=b,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 110 0}]
        d_a52o
          = errorWithoutStackTrace
              @GHC.Types.LiftedRep
              @a_a3VP
              (GHC.Base.build
                 @Char
                 (\ (@b_a52t) ->
                    GHC.CString.unpackFoldrCString#
                      @b_a52t "minimum: empty structure"#)) } in
      let {
        g_a52v :: Quintuple a_a3VP -> base:Data.Functor.Utils.Min a_a3VP
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 80 0}]
        g_a52v
          = Data.Foldable.foldMap'
              @Quintuple
              Main.$fFoldableQuintuple
              @(base:Data.Functor.Utils.Min a_a3VP)
              @a_a3VP
              (base:Data.Functor.Utils.$fMonoidMin @a_a3VP $dOrd_a3VQ)
              ((\ (ds_a53M :: a_a3VP) -> GHC.Maybe.Just @a_a3VP ds_a53M)
               `cast` (<a_a3VP>_R
                       %<'Many>_N ->_R Sym (base:Data.Functor.Utils.N:Min[0]) <a_a3VP>_N
                       :: (a_a3VP -> GHC.Maybe.Maybe a_a3VP)
                          ~R# (a_a3VP -> base:Data.Functor.Utils.Min a_a3VP))) } in
      \ (x_a53N :: Quintuple a_a3VP) ->
        case (g_a52v x_a53N)
             `cast` (base:Data.Functor.Utils.N:Min[0] <a_a3VP>_N
                     :: base:Data.Functor.Utils.Min a_a3VP ~R# GHC.Maybe.Maybe a_a3VP)
        of {
          GHC.Maybe.Nothing -> d_a52o;
          GHC.Maybe.Just v_a54h -> v_a54h
        }

-- RHS size: {terms: 24, types: 25, coercions: 8, joins: 0/2}
$cmaximum_a3VA [Occ=LoopBreaker]
  :: forall a. Ord a => Quintuple a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 260 60}]
$cmaximum_a3VA
  = \ (@a_a3VD) ($dOrd_a3VE :: Ord a_a3VD) ->
      let {
        d_a54n :: a_a3VD
        [LclId,
         Str=b,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 110 0}]
        d_a54n
          = errorWithoutStackTrace
              @GHC.Types.LiftedRep
              @a_a3VD
              (GHC.Base.build
                 @Char
                 (\ (@b_a54o) ->
                    GHC.CString.unpackFoldrCString#
                      @b_a54o "maximum: empty structure"#)) } in
      let {
        g_a54p :: Quintuple a_a3VD -> base:Data.Functor.Utils.Max a_a3VD
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 80 0}]
        g_a54p
          = Data.Foldable.foldMap'
              @Quintuple
              Main.$fFoldableQuintuple
              @(base:Data.Functor.Utils.Max a_a3VD)
              @a_a3VD
              (base:Data.Functor.Utils.$fMonoidMax @a_a3VD $dOrd_a3VE)
              ((\ (ds_a54r :: a_a3VD) -> GHC.Maybe.Just @a_a3VD ds_a54r)
               `cast` (<a_a3VD>_R
                       %<'Many>_N ->_R Sym (base:Data.Functor.Utils.N:Max[0]) <a_a3VD>_N
                       :: (a_a3VD -> GHC.Maybe.Maybe a_a3VD)
                          ~R# (a_a3VD -> base:Data.Functor.Utils.Max a_a3VD))) } in
      \ (x_a54s :: Quintuple a_a3VD) ->
        case (g_a54p x_a54s)
             `cast` (base:Data.Functor.Utils.N:Max[0] <a_a3VD>_N
                     :: base:Data.Functor.Utils.Max a_a3VD ~R# GHC.Maybe.Maybe a_a3VD)
        of {
          GHC.Maybe.Nothing -> d_a54n;
          GHC.Maybe.Just v_a54x -> v_a54x
        }

-- RHS size: {terms: 15, types: 17, coercions: 26, joins: 0/0}
$celem_a3Vo [Occ=LoopBreaker]
  :: forall a. Eq a => a -> Quintuple a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 130 60}]
$celem_a3Vo
  = \ (@a_a3Vr) ($dEq_a3Vs :: Eq a_a3Vr) ->
      ((\ (@(t_a54z :: * -> *))
          ($dFoldable_a54A :: Foldable t_a54z)
          (@a_a54B)
          ($dEq_a54C :: Eq a_a54B)
          (eta_a54D :: a_a54B) ->
          foldMap
            @t_a54z
            $dFoldable_a54A
            @base:Data.Semigroup.Internal.Any
            @a_a54B
            base:Data.Semigroup.Internal.$fMonoidAny
            ((== @a_a54B $dEq_a54C eta_a54D)
             `cast` (<a_a54B>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Any[0])
                     :: (a_a54B -> Bool)
                        ~R# (a_a54B -> base:Data.Semigroup.Internal.Any))))
       `cast` (forall (t :: <* -> *>_N).
               <Foldable t>_R
               %<'Many>_N ->_R forall (a :: <*>_N).
                               <Eq a>_R
                               %<'Many>_N ->_R <a>_R
                               %<'Many>_N ->_R <t a>_R
                               %<'Many>_N ->_R base:Data.Semigroup.Internal.N:Any[0]
               :: (forall {t :: * -> *} {a}.
                   (Foldable t, Eq a) =>
                   a -> t a -> base:Data.Semigroup.Internal.Any)
                  ~R# (forall {t :: * -> *} {a}.
                       (Foldable t, Eq a) =>
                       a -> t a -> Bool)))
        @Quintuple Main.$fFoldableQuintuple @a_a3Vr $dEq_a3Vs

-- RHS size: {terms: 14, types: 8, coercions: 0, joins: 0/0}
$clength_a3Ve [Occ=LoopBreaker] :: forall a. Quintuple a -> Int
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=False, ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 91 0}]
$clength_a3Ve
  = \ (@a_a3Vh) ->
      Data.Foldable.foldl'
        @Quintuple
        Main.$fFoldableQuintuple
        @Int
        @a_a3Vh
        (\ (c_a54K :: Int) _ [Occ=Dead] ->
           case c_a54K of { GHC.Types.I# x_a54N ->
           GHC.Types.I# (GHC.Prim.+# x_a54N 1#)
           })
        (GHC.Types.I# 0#)

-- RHS size: {terms: 11, types: 12, coercions: 0, joins: 0/0}
$ctoList_a3UX [Occ=LoopBreaker] :: forall a. Quintuple a -> [a]
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 70 40}]
$ctoList_a3UX
  = \ (@a_a3V0) (t1_a54S :: Quintuple a_a3V0) ->
      GHC.Base.build
        @a_a3V0
        (\ (@b_a54T)
           (c_a54U [OS=OneShot] :: a_a3V0 -> b_a54T -> b_a54T)
           (n_a54V [OS=OneShot] :: b_a54T) ->
           foldr
             @Quintuple
             Main.$fFoldableQuintuple
             @a_a3V0
             @b_a54T
             c_a54U
             n_a54V
             t1_a54S)

-- RHS size: {terms: 27, types: 26, coercions: 0, joins: 0/0}
$cfoldl1_a3UN [Occ=LoopBreaker]
  :: forall a. (a -> a -> a) -> Quintuple a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0] 260 0}]
$cfoldl1_a3UN
  = \ (@a_a3UQ)
      (f_a54Z :: a_a3UQ -> a_a3UQ -> a_a3UQ)
      (xs_a550 :: Quintuple a_a3UQ) ->
      case foldl
             @Quintuple
             Main.$fFoldableQuintuple
             @(GHC.Maybe.Maybe a_a3UQ)
             @a_a3UQ
             (\ (m_a551 :: GHC.Maybe.Maybe a_a3UQ) (y_a552 :: a_a3UQ) ->
                GHC.Maybe.Just
                  @a_a3UQ
                  (case m_a551 of {
                     GHC.Maybe.Nothing -> y_a552;
                     GHC.Maybe.Just x_a555 -> f_a54Z x_a555 y_a552
                   }))
             (GHC.Maybe.Nothing @a_a3UQ)
             xs_a550
      of {
        GHC.Maybe.Nothing ->
          errorWithoutStackTrace
            @GHC.Types.LiftedRep
            @a_a3UQ
            (GHC.Base.build
               @Char
               (\ (@b_a558) ->
                  GHC.CString.unpackFoldrCString#
                    @b_a558 "foldl1: empty structure"#));
        GHC.Maybe.Just v_a559 -> v_a559
      }

-- RHS size: {terms: 27, types: 26, coercions: 0, joins: 0/0}
$cfoldr1_a3UD [Occ=LoopBreaker]
  :: forall a. (a -> a -> a) -> Quintuple a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0] 260 0}]
$cfoldr1_a3UD
  = \ (@a_a3UG)
      (f_a55f :: a_a3UG -> a_a3UG -> a_a3UG)
      (xs_a55g :: Quintuple a_a3UG) ->
      case foldr
             @Quintuple
             Main.$fFoldableQuintuple
             @a_a3UG
             @(GHC.Maybe.Maybe a_a3UG)
             (\ (x_a55h :: a_a3UG) (m_a55i :: GHC.Maybe.Maybe a_a3UG) ->
                GHC.Maybe.Just
                  @a_a3UG
                  (case m_a55i of {
                     GHC.Maybe.Nothing -> x_a55h;
                     GHC.Maybe.Just y_a55l -> f_a55f x_a55h y_a55l
                   }))
             (GHC.Maybe.Nothing @a_a3UG)
             xs_a55g
      of {
        GHC.Maybe.Nothing ->
          errorWithoutStackTrace
            @GHC.Types.LiftedRep
            @a_a3UG
            (GHC.Base.build
               @Char
               (\ (@b_a55o) ->
                  GHC.CString.unpackFoldrCString#
                    @b_a55o "foldr1: empty structure"#));
        GHC.Maybe.Just v_a55p -> v_a55p
      }

-- RHS size: {terms: 20, types: 18, coercions: 0, joins: 0/0}
$cfoldl'_a3Ur [Occ=LoopBreaker]
  :: forall b a. (b -> a -> b) -> b -> Quintuple a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 150 0}]
$cfoldl'_a3Ur
  = \ (@b_a3Uu)
      (@a_a3Uv)
      (f_a55w :: b_a3Uu -> a_a3Uv -> b_a3Uu)
      (z0_a55x :: b_a3Uu)
      (xs_a55y :: Quintuple a_a3Uv) ->
      foldr
        @Quintuple
        Main.$fFoldableQuintuple
        @a_a3Uv
        @(b_a3Uu -> b_a3Uu)
        (\ (ds_a55z :: a_a3Uv)
           (ds1_a55A :: b_a3Uu -> b_a3Uu)
           (v_a55B [OS=OneShot] :: b_a3Uu) ->
           case v_a55B of z_a55C { __DEFAULT ->
           ds1_a55A (f_a55w z_a55C ds_a55z)
           })
        (id @b_a3Uu)
        xs_a55y
        z0_a55x

-- RHS size: {terms: 16, types: 18, coercions: 10, joins: 0/0}
$cfoldl_a3Uf [Occ=LoopBreaker]
  :: forall b a. (b -> a -> b) -> b -> Quintuple a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 130 0}]
$cfoldl_a3Uf
  = \ (@b_a3Ui)
      (@a_a3Uj)
      (eta_a55I :: b_a3Ui -> a_a3Uj -> b_a3Ui)
      (eta1_a55J :: b_a3Ui)
      (eta2_a55K :: Quintuple a_a3Uj) ->
      ((foldMap
          @Quintuple
          Main.$fFoldableQuintuple
          @(base:Data.Semigroup.Internal.Dual
              (base:Data.Semigroup.Internal.Endo b_a3Ui))
          @a_a3Uj
          (base:Data.Semigroup.Internal.$fMonoidDual
             @(base:Data.Semigroup.Internal.Endo b_a3Ui)
             (base:Data.Semigroup.Internal.$fMonoidEndo @b_a3Ui))
          ((\ (x_a55N :: a_a3Uj) (y_a55O :: b_a3Ui) ->
              eta_a55I y_a55O x_a55N)
           `cast` (<a_a3Uj>_R
                   %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Dual[0]
                                            (base:Data.Semigroup.Internal.N:Endo[0] <b_a3Ui>_R))
                   :: (a_a3Uj -> b_a3Ui -> b_a3Ui)
                      ~R# (a_a3Uj
                           -> base:Data.Semigroup.Internal.Dual
                                (base:Data.Semigroup.Internal.Endo b_a3Ui))))
          eta2_a55K)
       `cast` (base:Data.Semigroup.Internal.N:Dual[0]
                   (base:Data.Semigroup.Internal.N:Endo[0] <b_a3Ui>_R)
               :: base:Data.Semigroup.Internal.Dual
                    (base:Data.Semigroup.Internal.Endo b_a3Ui)
                  ~R# (b_a3Ui -> b_a3Ui)))
        eta1_a55J

-- RHS size: {terms: 20, types: 18, coercions: 0, joins: 0/0}
$cfoldr'_a3U3 [Occ=LoopBreaker]
  :: forall a b. (a -> b -> b) -> b -> Quintuple a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 150 0}]
$cfoldr'_a3U3
  = \ (@a_a3U6)
      (@b_a3U7)
      (f_a55X :: a_a3U6 -> b_a3U7 -> b_a3U7)
      (z0_a55Y :: b_a3U7)
      (xs_a55Z :: Quintuple a_a3U6) ->
      foldl
        @Quintuple
        Main.$fFoldableQuintuple
        @(b_a3U7 -> b_a3U7)
        @a_a3U6
        (\ (ds_a560 :: b_a3U7 -> b_a3U7)
           (ds1_a561 :: a_a3U6)
           (v_a562 [OS=OneShot] :: b_a3U7) ->
           case v_a562 of z_a563 { __DEFAULT ->
           ds_a560 (f_a55X ds1_a561 z_a563)
           })
        (id @b_a3U7)
        xs_a55Z
        z0_a55Y

-- RHS size: {terms: 18, types: 16, coercions: 0, joins: 0/1}
$cfoldMap'_a3TH [Occ=LoopBreaker]
  :: forall m a. Monoid m => (a -> m) -> Quintuple a -> m
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 60] 170 0}]
$cfoldMap'_a3TH
  = \ (@m_a3TK)
      (@a_a3TL)
      ($dMonoid_a3TM :: Monoid m_a3TK)
      (eta_a569 :: a_a3TL -> m_a3TK) ->
      let {
        $dSemigroup_a56a :: Semigroup m_a3TK
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dSemigroup_a56a = GHC.Base.$p1Monoid @m_a3TK $dMonoid_a3TM } in
      Data.Foldable.foldl'
        @Quintuple
        Main.$fFoldableQuintuple
        @m_a3TK
        @a_a3TL
        (\ (acc_a56b :: m_a3TK) (a1_a56c :: a_a3TL) ->
           <> @m_a3TK $dSemigroup_a56a acc_a56b (eta_a569 a1_a56c))
        (mempty @m_a3TK $dMonoid_a3TM)

-- RHS size: {terms: 14, types: 18, coercions: 25, joins: 0/0}
$cproduct_a3Wa [Occ=LoopBreaker]
  :: forall a. Num a => Quintuple a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 120 60}]
$cproduct_a3Wa
  = \ (@a_a3Wd) ($dNum_a3We :: Num a_a3Wd) ->
      ((\ (@(t_a56d :: * -> *))
          ($dFoldable_a56e :: Foldable t_a56d)
          (@a_a56f)
          ($dNum_a56g :: Num a_a56f) ->
          Data.Foldable.foldMap'
            @t_a56d
            $dFoldable_a56e
            @(base:Data.Semigroup.Internal.Product a_a56f)
            @a_a56f
            (base:Data.Semigroup.Internal.$fMonoidProduct @a_a56f $dNum_a56g)
            ((\ (ds_a56i :: a_a56f) -> ds_a56i)
             `cast` (<a_a56f>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Product[0]
                                              <a_a56f>_R)
                     :: (a_a56f -> a_a56f)
                        ~R# (a_a56f -> base:Data.Semigroup.Internal.Product a_a56f))))
       `cast` (forall (t :: <* -> *>_N).
               <Foldable t>_R
               %<'Many>_N ->_R forall (a :: <*>_N).
                               <Num a>_R
                               %<'Many>_N ->_R <t a>_R
                               %<'Many>_N ->_R base:Data.Semigroup.Internal.N:Product[0] <a>_R
               :: (forall {t :: * -> *} {a}.
                   (Foldable t, Num a) =>
                   t a -> base:Data.Semigroup.Internal.Product a)
                  ~R# (forall {t :: * -> *} {a}. (Foldable t, Num a) => t a -> a)))
        @Quintuple Main.$fFoldableQuintuple @a_a3Wd $dNum_a3We

-- RHS size: {terms: 6, types: 7, coercions: 0, joins: 0/0}
$cfold_a3Td [Occ=LoopBreaker]
  :: forall m. Monoid m => Quintuple m -> m
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 40 0}]
$cfold_a3Td
  = \ (@m_a3Tg) ($dMonoid_a3Th :: Monoid m_a3Tg) ->
      foldMap
        @Quintuple
        Main.$fFoldableQuintuple
        @m_a3Tg
        @m_a3Tg
        $dMonoid_a3Th
        (id @m_a3Tg)
end Rec }

-- RHS size: {terms: 13, types: 13, coercions: 0, joins: 0/0}
$c<$_a3SW :: forall a b. a -> Quintuple b -> Quintuple a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)}]
$c<$_a3SW
  = \ (@a_a3SZ)
      (@b_a3T0)
      (z_a2gB :: a_a3SZ)
      (ds_d4Tq :: Quintuple b_a3T0) ->
      case ds_d4Tq of
      { Quintuple _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead]
                  _ [Occ=Dead] ->
      Main.Quintuple @a_a3SZ z_a2gB z_a2gB z_a2gB z_a2gB z_a2gB
      }

-- RHS size: {terms: 18, types: 14, coercions: 0, joins: 0/0}
$cfmap_a3SI :: forall a b. (a -> b) -> Quintuple a -> Quintuple b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 20] 120 10}]
$cfmap_a3SI
  = \ (@a_a3SL)
      (@b_a3SM)
      (f_a2gv :: a_a3SL -> b_a3SM)
      (ds_d4Tk :: Quintuple a_a3SL) ->
      case ds_d4Tk of
      { Quintuple a1_a2gw a2_a2gx a3_a2gy a4_a2gz a5_a2gA ->
      Main.Quintuple
        @b_a3SM
        (f_a2gv a1_a2gw)
        (f_a2gv a2_a2gx)
        (f_a2gv a3_a2gy)
        (f_a2gv a4_a2gz)
        (f_a2gv a5_a2gA)
      }

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Main.$fFunctorQuintuple [InlPrag=CONLIKE] :: Functor Quintuple
[LclIdX[DFunId],
 Unf=DFun: \ ->
       GHC.Base.C:Functor TYPE: Quintuple $cfmap_a3SI $c<$_a3SW]
Main.$fFunctorQuintuple
  = GHC.Base.C:Functor @Quintuple $cfmap_a3SI $c<$_a3SW

Rec {
-- RHS size: {terms: 7, types: 1, coercions: 0, joins: 0/0}
Main.$fTraversableQuintuple [InlPrag=CONLIKE]
  :: Traversable Quintuple
[LclIdX[DFunId],
 Unf=DFun: \ ->
       Data.Traversable.C:Traversable TYPE: Quintuple
                                      Main.$fFunctorQuintuple
                                      Main.$fFoldableQuintuple
                                      $ctraverse_a4oI
                                      $csequenceA_a4oY
                                      $cmapM_a4pc
                                      $csequence_a4ps]
Main.$fTraversableQuintuple
  = Data.Traversable.C:Traversable
      @Quintuple
      Main.$fFunctorQuintuple
      Main.$fFoldableQuintuple
      $ctraverse_a4oI
      $csequenceA_a4oY
      $cmapM_a4pc
      $csequence_a4ps

-- RHS size: {terms: 8, types: 11, coercions: 0, joins: 0/0}
$cmapM_a4pc [Occ=LoopBreaker]
  :: forall (m :: * -> *) a b.
     Monad m =>
     (a -> m b) -> Quintuple a -> m (Quintuple b)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30] 50 0}]
$cmapM_a4pc
  = \ (@(m_a4pf :: * -> *))
      (@a_a4pg)
      (@b_a4ph)
      ($dMonad_a4pi :: Monad m_a4pf) ->
      traverse
        @Quintuple
        Main.$fTraversableQuintuple
        @m_a4pf
        @a_a4pg
        @b_a4ph
        (GHC.Base.$p1Monad @m_a4pf $dMonad_a4pi)

-- RHS size: {terms: 7, types: 12, coercions: 0, joins: 0/0}
$csequenceA_a4oY [Occ=LoopBreaker]
  :: forall (f :: * -> *) a.
     Applicative f =>
     Quintuple (f a) -> f (Quintuple a)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 40 0}]
$csequenceA_a4oY
  = \ (@(f_a4p1 :: * -> *))
      (@a_a4p2)
      ($dApplicative_a4p3 :: Applicative f_a4p1) ->
      traverse
        @Quintuple
        Main.$fTraversableQuintuple
        @f_a4p1
        @(f_a4p1 a_a4p2)
        @a_a4p2
        $dApplicative_a4p3
        (id @(f_a4p1 a_a4p2))

-- RHS size: {terms: 7, types: 9, coercions: 0, joins: 0/0}
$csequence_a4ps [Occ=LoopBreaker]
  :: forall (m :: * -> *) a.
     Monad m =>
     Quintuple (m a) -> m (Quintuple a)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30] 50 0}]
$csequence_a4ps
  = \ (@(m_a4pv :: * -> *))
      (@a_a4pw)
      ($dMonad_a4px :: Monad m_a4pv) ->
      sequenceA
        @Quintuple
        Main.$fTraversableQuintuple
        @m_a4pv
        @a_a4pw
        (GHC.Base.$p1Monad @m_a4pv $dMonad_a4px)

-- RHS size: {terms: 18, types: 30, coercions: 0, joins: 0/2}
$ctraverse_a4oI [Occ=LoopBreaker]
  :: forall (f :: * -> *) a b.
     Applicative f =>
     (a -> f b) -> Quintuple a -> f (Quintuple b)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 150 60}]
$ctraverse_a4oI
  = \ (@(f_a4oL :: * -> *))
      (@a_a4oM)
      (@b_a4oN)
      ($dApplicative_a4oO :: Applicative f_a4oL)
      (eta1_a56N :: a_a4oM -> f_a4oL b_a4oN) ->
      let {
        f1_a56O :: Quintuple (f_a4oL b_a4oN) -> f_a4oL (Quintuple b_a4oN)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 30 0}]
        f1_a56O
          = sequenceA
              @Quintuple
              Main.$fTraversableQuintuple
              @f_a4oL
              @b_a4oN
              $dApplicative_a4oO } in
      let {
        g_a56P :: Quintuple a_a4oM -> Quintuple (f_a4oL b_a4oN)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 50 0}]
        g_a56P
          = fmap
              @Quintuple
              (Data.Traversable.$p1Traversable
                 @Quintuple Main.$fTraversableQuintuple)
              @a_a4oM
              @(f_a4oL b_a4oN)
              eta1_a56N } in
      \ (x_a56Q :: Quintuple a_a4oM) -> f1_a56O (g_a56P x_a56Q)
end Rec }

-- RHS size: {terms: 54, types: 46, coercions: 0, joins: 0/0}
$cshowsPrec_a3RI :: forall a. Show a => Int -> Quintuple a -> ShowS
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [150 0 20] 690 0}]
$cshowsPrec_a3RI
  = \ (@a_a3RF)
      ($dShow_a3RG :: Show a_a3RF)
      (a_a2gp :: Int)
      (ds_d4Tf :: Quintuple a_a3RF) ->
      case ds_d4Tf of
      { Quintuple b1_a2gq b2_a2gr b3_a2gs b4_a2gt b5_a2gu ->
      showParen
        (>= @Int GHC.Classes.$fOrdInt a_a2gp (GHC.Types.I# 11#))
        (. @String
           @String
           @String
           (showString (GHC.CString.unpackCString# "Quintuple "#))
           (. @String
              @String
              @String
              (showsPrec @a_a3RF $dShow_a3RG (GHC.Types.I# 11#) b1_a2gq)
              (. @String
                 @String
                 @String
                 GHC.Show.showSpace
                 (. @String
                    @String
                    @String
                    (showsPrec @a_a3RF $dShow_a3RG (GHC.Types.I# 11#) b2_a2gr)
                    (. @String
                       @String
                       @String
                       GHC.Show.showSpace
                       (. @String
                          @String
                          @String
                          (showsPrec @a_a3RF $dShow_a3RG (GHC.Types.I# 11#) b3_a2gs)
                          (. @String
                             @String
                             @String
                             GHC.Show.showSpace
                             (. @String
                                @String
                                @String
                                (showsPrec @a_a3RF $dShow_a3RG (GHC.Types.I# 11#) b4_a2gt)
                                (. @String
                                   @String
                                   @String
                                   GHC.Show.showSpace
                                   (showsPrec
                                      @a_a3RF $dShow_a3RG (GHC.Types.I# 11#) b5_a2gu))))))))))
      }

Rec {
-- RHS size: {terms: 9, types: 8, coercions: 0, joins: 0/0}
Main.$fShowQuintuple [InlPrag=CONLIKE]
  :: forall a. Show a => Show (Quintuple a)
[LclIdX[DFunId],
 Unf=DFun: \ (@a_a1zD) (v_B1 :: Show a_a1zD) ->
       GHC.Show.C:Show TYPE: Quintuple a_a1zD
                       $cshowsPrec_a3RI @a_a1zD v_B1
                       $cshow_a3Sr @a_a1zD v_B1
                       $cshowList_a3Sy @a_a1zD v_B1]
Main.$fShowQuintuple
  = \ (@a_a3RF) ($dShow_a3RG :: Show a_a3RF) ->
      GHC.Show.C:Show
        @(Quintuple a_a3RF)
        ($cshowsPrec_a3RI @a_a3RF $dShow_a3RG)
        ($cshow_a3Sr @a_a3RF $dShow_a3RG)
        ($cshowList_a3Sy @a_a3RF $dShow_a3RG)

-- RHS size: {terms: 14, types: 15, coercions: 0, joins: 0/1}
$cshowList_a3Sy [Occ=LoopBreaker]
  :: forall a. Show a => [Quintuple a] -> ShowS
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 130 60}]
$cshowList_a3Sy
  = \ (@a_a3RF) ($dShow_a3RG :: Show a_a3RF) ->
      let {
        $dShow_a56S :: Show (Quintuple a_a3RF)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dShow_a56S = Main.$fShowQuintuple @a_a3RF $dShow_a3RG } in
      \ (ls_a56T :: [Quintuple a_a3RF]) (s_a56U :: String) ->
        GHC.Show.showList__
          @(Quintuple a_a3RF)
          (showsPrec @(Quintuple a_a3RF) $dShow_a56S (GHC.Types.I# 0#))
          ls_a56T
          s_a56U

-- RHS size: {terms: 12, types: 12, coercions: 0, joins: 0/1}
$cshow_a3Sr [Occ=LoopBreaker]
  :: forall a. Show a => Quintuple a -> String
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 100 60}]
$cshow_a3Sr
  = \ (@a_a3RF) ($dShow_a3RG :: Show a_a3RF) ->
      let {
        $dShow_a56X :: Show (Quintuple a_a3RF)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dShow_a56X = Main.$fShowQuintuple @a_a3RF $dShow_a3RG } in
      \ (x_a56Y :: Quintuple a_a3RF) ->
        showsPrec
          @(Quintuple a_a3RF)
          $dShow_a56X
          (GHC.Types.I# 0#)
          x_a56Y
          (GHC.Types.[] @Char)
end Rec }

-- RHS size: {terms: 34, types: 26, coercions: 0, joins: 0/0}
$c==_a3Rf :: forall a. Eq a => Quintuple a -> Quintuple a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [150 20 20] 340 0}]
$c==_a3Rf
  = \ (@a_a3Rc)
      ($dEq_a3Rd :: Eq a_a3Rc)
      (ds_d4T7 :: Quintuple a_a3Rc)
      (ds_d4T8 :: Quintuple a_a3Rc) ->
      case ds_d4T7 of
      { Quintuple a1_a2gf a2_a2gg a3_a2gh a4_a2gi a5_a2gj ->
      case ds_d4T8 of
      { Quintuple b1_a2gk b2_a2gl b3_a2gm b4_a2gn b5_a2go ->
      &&
        (== @a_a3Rc $dEq_a3Rd a1_a2gf b1_a2gk)
        (&&
           (== @a_a3Rc $dEq_a3Rd a2_a2gg b2_a2gl)
           (&&
              (== @a_a3Rc $dEq_a3Rd a3_a2gh b3_a2gm)
              (&&
                 (== @a_a3Rc $dEq_a3Rd a4_a2gi b4_a2gn)
                 (== @a_a3Rc $dEq_a3Rd a5_a2gj b5_a2go))))
      }
      }

Rec {
-- RHS size: {terms: 7, types: 7, coercions: 0, joins: 0/0}
Main.$fEqQuintuple [InlPrag=CONLIKE]
  :: forall a. Eq a => Eq (Quintuple a)
[LclIdX[DFunId],
 Unf=DFun: \ (@a_a1zx) (v_B1 :: Eq a_a1zx) ->
       GHC.Classes.C:Eq TYPE: Quintuple a_a1zx
                        $c==_a3Rf @a_a1zx v_B1
                        $c/=_a3Rw @a_a1zx v_B1]
Main.$fEqQuintuple
  = \ (@a_a3Rc) ($dEq_a3Rd :: Eq a_a3Rc) ->
      GHC.Classes.C:Eq
        @(Quintuple a_a3Rc)
        ($c==_a3Rf @a_a3Rc $dEq_a3Rd)
        ($c/=_a3Rw @a_a3Rc $dEq_a3Rd)

-- RHS size: {terms: 16, types: 14, coercions: 0, joins: 0/1}
$c/=_a3Rw [Occ=LoopBreaker]
  :: forall a. Eq a => Quintuple a -> Quintuple a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 110 60}]
$c/=_a3Rw
  = \ (@a_a3Rc) ($dEq_a3Rd :: Eq a_a3Rc) ->
      let {
        $dEq_a570 :: Eq (Quintuple a_a3Rc)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dEq_a570 = Main.$fEqQuintuple @a_a3Rc $dEq_a3Rd } in
      \ (x_a571 :: Quintuple a_a3Rc) (y_a572 :: Quintuple a_a3Rc) ->
        case == @(Quintuple a_a3Rc) $dEq_a570 x_a571 y_a572 of {
          False -> GHC.Types.True;
          True -> GHC.Types.False
        }
end Rec }

-- RHS size: {terms: 8, types: 8, coercions: 0, joins: 0/0}
$cnull_a3PU :: forall a. List a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)}]
$cnull_a3PU
  = \ (@a_a3PX) (ds_d4T0 :: List a_a3PX) ->
      case ds_d4T0 of {
        Nil -> GHC.Types.True;
        Cons _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.False
      }

Rec {
-- RHS size: {terms: 18, types: 1, coercions: 0, joins: 0/0}
Main.$fFoldableList [InlPrag=CONLIKE] :: Foldable List
[LclIdX[DFunId],
 Unf=DFun: \ ->
       Data.Foldable.C:Foldable TYPE: List
                                $cfold_a3NI
                                $cfoldMap_a3NU
                                $cfoldMap'_a3Oe
                                $cfoldr_a3Os
                                $cfoldr'_a3OQ
                                $cfoldl_a3P2
                                $cfoldl'_a3Pe
                                $cfoldr1_a3Pq
                                $cfoldl1_a3PA
                                $ctoList_a3PK
                                $cnull_a3PU
                                $clength_a3Q2
                                $celem_a3Qc
                                $cmaximum_a3Qo
                                $cminimum_a3QA
                                $csum_a3QM
                                $cproduct_a3QY]
Main.$fFoldableList
  = Data.Foldable.C:Foldable
      @List
      $cfold_a3NI
      $cfoldMap_a3NU
      $cfoldMap'_a3Oe
      $cfoldr_a3Os
      $cfoldr'_a3OQ
      $cfoldl_a3P2
      $cfoldl'_a3Pe
      $cfoldr1_a3Pq
      $cfoldl1_a3PA
      $ctoList_a3PK
      $cnull_a3PU
      $clength_a3Q2
      $celem_a3Qc
      $cmaximum_a3Qo
      $cminimum_a3QA
      $csum_a3QM
      $cproduct_a3QY

-- RHS size: {terms: 14, types: 18, coercions: 25, joins: 0/0}
$csum_a3QM [Occ=LoopBreaker] :: forall a. Num a => List a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 120 60}]
$csum_a3QM
  = \ (@a_a3QP) ($dNum_a3QQ :: Num a_a3QP) ->
      ((\ (@(t_a4WR :: * -> *))
          ($dFoldable_a4WS :: Foldable t_a4WR)
          (@a_a4WT)
          ($dNum_a4WU :: Num a_a4WT) ->
          Data.Foldable.foldMap'
            @t_a4WR
            $dFoldable_a4WS
            @(base:Data.Semigroup.Internal.Sum a_a4WT)
            @a_a4WT
            (base:Data.Semigroup.Internal.$fMonoidSum @a_a4WT $dNum_a4WU)
            ((\ (ds_a52f :: a_a4WT) -> ds_a52f)
             `cast` (<a_a4WT>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Sum[0]
                                              <a_a4WT>_R)
                     :: (a_a4WT -> a_a4WT)
                        ~R# (a_a4WT -> base:Data.Semigroup.Internal.Sum a_a4WT))))
       `cast` (forall (t :: <* -> *>_N).
               <Foldable t>_R
               %<'Many>_N ->_R forall (a :: <*>_N).
                               <Num a>_R
                               %<'Many>_N ->_R <t a>_R
                               %<'Many>_N ->_R base:Data.Semigroup.Internal.N:Sum[0] <a>_R
               :: (forall {t :: * -> *} {a}.
                   (Foldable t, Num a) =>
                   t a -> base:Data.Semigroup.Internal.Sum a)
                  ~R# (forall {t :: * -> *} {a}. (Foldable t, Num a) => t a -> a)))
        @List Main.$fFoldableList @a_a3QP $dNum_a3QQ

-- RHS size: {terms: 24, types: 25, coercions: 8, joins: 0/2}
$cminimum_a3QA [Occ=LoopBreaker] :: forall a. Ord a => List a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 260 60}]
$cminimum_a3QA
  = \ (@a_a3QD) ($dOrd_a3QE :: Ord a_a3QD) ->
      let {
        d_a52o :: a_a3QD
        [LclId,
         Str=b,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 110 0}]
        d_a52o
          = errorWithoutStackTrace
              @GHC.Types.LiftedRep
              @a_a3QD
              (GHC.Base.build
                 @Char
                 (\ (@b_a52t) ->
                    GHC.CString.unpackFoldrCString#
                      @b_a52t "minimum: empty structure"#)) } in
      let {
        g_a52v :: List a_a3QD -> base:Data.Functor.Utils.Min a_a3QD
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 80 0}]
        g_a52v
          = Data.Foldable.foldMap'
              @List
              Main.$fFoldableList
              @(base:Data.Functor.Utils.Min a_a3QD)
              @a_a3QD
              (base:Data.Functor.Utils.$fMonoidMin @a_a3QD $dOrd_a3QE)
              ((\ (ds_a53M :: a_a3QD) -> GHC.Maybe.Just @a_a3QD ds_a53M)
               `cast` (<a_a3QD>_R
                       %<'Many>_N ->_R Sym (base:Data.Functor.Utils.N:Min[0]) <a_a3QD>_N
                       :: (a_a3QD -> GHC.Maybe.Maybe a_a3QD)
                          ~R# (a_a3QD -> base:Data.Functor.Utils.Min a_a3QD))) } in
      \ (x_a53N :: List a_a3QD) ->
        case (g_a52v x_a53N)
             `cast` (base:Data.Functor.Utils.N:Min[0] <a_a3QD>_N
                     :: base:Data.Functor.Utils.Min a_a3QD ~R# GHC.Maybe.Maybe a_a3QD)
        of {
          GHC.Maybe.Nothing -> d_a52o;
          GHC.Maybe.Just v_a54h -> v_a54h
        }

-- RHS size: {terms: 24, types: 25, coercions: 8, joins: 0/2}
$cmaximum_a3Qo [Occ=LoopBreaker] :: forall a. Ord a => List a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 260 60}]
$cmaximum_a3Qo
  = \ (@a_a3Qr) ($dOrd_a3Qs :: Ord a_a3Qr) ->
      let {
        d_a54n :: a_a3Qr
        [LclId,
         Str=b,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 110 0}]
        d_a54n
          = errorWithoutStackTrace
              @GHC.Types.LiftedRep
              @a_a3Qr
              (GHC.Base.build
                 @Char
                 (\ (@b_a54o) ->
                    GHC.CString.unpackFoldrCString#
                      @b_a54o "maximum: empty structure"#)) } in
      let {
        g_a54p :: List a_a3Qr -> base:Data.Functor.Utils.Max a_a3Qr
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 80 0}]
        g_a54p
          = Data.Foldable.foldMap'
              @List
              Main.$fFoldableList
              @(base:Data.Functor.Utils.Max a_a3Qr)
              @a_a3Qr
              (base:Data.Functor.Utils.$fMonoidMax @a_a3Qr $dOrd_a3Qs)
              ((\ (ds_a54r :: a_a3Qr) -> GHC.Maybe.Just @a_a3Qr ds_a54r)
               `cast` (<a_a3Qr>_R
                       %<'Many>_N ->_R Sym (base:Data.Functor.Utils.N:Max[0]) <a_a3Qr>_N
                       :: (a_a3Qr -> GHC.Maybe.Maybe a_a3Qr)
                          ~R# (a_a3Qr -> base:Data.Functor.Utils.Max a_a3Qr))) } in
      \ (x_a54s :: List a_a3Qr) ->
        case (g_a54p x_a54s)
             `cast` (base:Data.Functor.Utils.N:Max[0] <a_a3Qr>_N
                     :: base:Data.Functor.Utils.Max a_a3Qr ~R# GHC.Maybe.Maybe a_a3Qr)
        of {
          GHC.Maybe.Nothing -> d_a54n;
          GHC.Maybe.Just v_a54x -> v_a54x
        }

-- RHS size: {terms: 15, types: 17, coercions: 26, joins: 0/0}
$celem_a3Qc [Occ=LoopBreaker]
  :: forall a. Eq a => a -> List a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 130 60}]
$celem_a3Qc
  = \ (@a_a3Qf) ($dEq_a3Qg :: Eq a_a3Qf) ->
      ((\ (@(t_a54z :: * -> *))
          ($dFoldable_a54A :: Foldable t_a54z)
          (@a_a54B)
          ($dEq_a54C :: Eq a_a54B)
          (eta_a54D :: a_a54B) ->
          foldMap
            @t_a54z
            $dFoldable_a54A
            @base:Data.Semigroup.Internal.Any
            @a_a54B
            base:Data.Semigroup.Internal.$fMonoidAny
            ((== @a_a54B $dEq_a54C eta_a54D)
             `cast` (<a_a54B>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Any[0])
                     :: (a_a54B -> Bool)
                        ~R# (a_a54B -> base:Data.Semigroup.Internal.Any))))
       `cast` (forall (t :: <* -> *>_N).
               <Foldable t>_R
               %<'Many>_N ->_R forall (a :: <*>_N).
                               <Eq a>_R
                               %<'Many>_N ->_R <a>_R
                               %<'Many>_N ->_R <t a>_R
                               %<'Many>_N ->_R base:Data.Semigroup.Internal.N:Any[0]
               :: (forall {t :: * -> *} {a}.
                   (Foldable t, Eq a) =>
                   a -> t a -> base:Data.Semigroup.Internal.Any)
                  ~R# (forall {t :: * -> *} {a}.
                       (Foldable t, Eq a) =>
                       a -> t a -> Bool)))
        @List Main.$fFoldableList @a_a3Qf $dEq_a3Qg

-- RHS size: {terms: 14, types: 8, coercions: 0, joins: 0/0}
$clength_a3Q2 [Occ=LoopBreaker] :: forall a. List a -> Int
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=False, ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 91 0}]
$clength_a3Q2
  = \ (@a_a3Q5) ->
      Data.Foldable.foldl'
        @List
        Main.$fFoldableList
        @Int
        @a_a3Q5
        (\ (c_a54K :: Int) _ [Occ=Dead] ->
           case c_a54K of { GHC.Types.I# x_a54N ->
           GHC.Types.I# (GHC.Prim.+# x_a54N 1#)
           })
        (GHC.Types.I# 0#)

-- RHS size: {terms: 11, types: 12, coercions: 0, joins: 0/0}
$ctoList_a3PK [Occ=LoopBreaker] :: forall a. List a -> [a]
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 70 40}]
$ctoList_a3PK
  = \ (@a_a3PN) (t1_a54S :: List a_a3PN) ->
      GHC.Base.build
        @a_a3PN
        (\ (@b_a54T)
           (c_a54U [OS=OneShot] :: a_a3PN -> b_a54T -> b_a54T)
           (n_a54V [OS=OneShot] :: b_a54T) ->
           foldr
             @List Main.$fFoldableList @a_a3PN @b_a54T c_a54U n_a54V t1_a54S)

-- RHS size: {terms: 27, types: 26, coercions: 0, joins: 0/0}
$cfoldl1_a3PA [Occ=LoopBreaker]
  :: forall a. (a -> a -> a) -> List a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0] 260 0}]
$cfoldl1_a3PA
  = \ (@a_a3PD)
      (f_a54Z :: a_a3PD -> a_a3PD -> a_a3PD)
      (xs_a550 :: List a_a3PD) ->
      case foldl
             @List
             Main.$fFoldableList
             @(GHC.Maybe.Maybe a_a3PD)
             @a_a3PD
             (\ (m_a551 :: GHC.Maybe.Maybe a_a3PD) (y_a552 :: a_a3PD) ->
                GHC.Maybe.Just
                  @a_a3PD
                  (case m_a551 of {
                     GHC.Maybe.Nothing -> y_a552;
                     GHC.Maybe.Just x_a555 -> f_a54Z x_a555 y_a552
                   }))
             (GHC.Maybe.Nothing @a_a3PD)
             xs_a550
      of {
        GHC.Maybe.Nothing ->
          errorWithoutStackTrace
            @GHC.Types.LiftedRep
            @a_a3PD
            (GHC.Base.build
               @Char
               (\ (@b_a558) ->
                  GHC.CString.unpackFoldrCString#
                    @b_a558 "foldl1: empty structure"#));
        GHC.Maybe.Just v_a559 -> v_a559
      }

-- RHS size: {terms: 27, types: 26, coercions: 0, joins: 0/0}
$cfoldr1_a3Pq [Occ=LoopBreaker]
  :: forall a. (a -> a -> a) -> List a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0] 260 0}]
$cfoldr1_a3Pq
  = \ (@a_a3Pt)
      (f_a55f :: a_a3Pt -> a_a3Pt -> a_a3Pt)
      (xs_a55g :: List a_a3Pt) ->
      case foldr
             @List
             Main.$fFoldableList
             @a_a3Pt
             @(GHC.Maybe.Maybe a_a3Pt)
             (\ (x_a55h :: a_a3Pt) (m_a55i :: GHC.Maybe.Maybe a_a3Pt) ->
                GHC.Maybe.Just
                  @a_a3Pt
                  (case m_a55i of {
                     GHC.Maybe.Nothing -> x_a55h;
                     GHC.Maybe.Just y_a55l -> f_a55f x_a55h y_a55l
                   }))
             (GHC.Maybe.Nothing @a_a3Pt)
             xs_a55g
      of {
        GHC.Maybe.Nothing ->
          errorWithoutStackTrace
            @GHC.Types.LiftedRep
            @a_a3Pt
            (GHC.Base.build
               @Char
               (\ (@b_a55o) ->
                  GHC.CString.unpackFoldrCString#
                    @b_a55o "foldr1: empty structure"#));
        GHC.Maybe.Just v_a55p -> v_a55p
      }

-- RHS size: {terms: 20, types: 18, coercions: 0, joins: 0/0}
$cfoldl'_a3Pe [Occ=LoopBreaker]
  :: forall b a. (b -> a -> b) -> b -> List a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 150 0}]
$cfoldl'_a3Pe
  = \ (@b_a3Ph)
      (@a_a3Pi)
      (f_a55w :: b_a3Ph -> a_a3Pi -> b_a3Ph)
      (z0_a55x :: b_a3Ph)
      (xs_a55y :: List a_a3Pi) ->
      foldr
        @List
        Main.$fFoldableList
        @a_a3Pi
        @(b_a3Ph -> b_a3Ph)
        (\ (ds_a55z :: a_a3Pi)
           (ds1_a55A :: b_a3Ph -> b_a3Ph)
           (v_a55B [OS=OneShot] :: b_a3Ph) ->
           case v_a55B of z_a55C { __DEFAULT ->
           ds1_a55A (f_a55w z_a55C ds_a55z)
           })
        (id @b_a3Ph)
        xs_a55y
        z0_a55x

-- RHS size: {terms: 16, types: 18, coercions: 10, joins: 0/0}
$cfoldl_a3P2 [Occ=LoopBreaker]
  :: forall b a. (b -> a -> b) -> b -> List a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 130 0}]
$cfoldl_a3P2
  = \ (@b_a3P5)
      (@a_a3P6)
      (eta_a55I :: b_a3P5 -> a_a3P6 -> b_a3P5)
      (eta1_a55J :: b_a3P5)
      (eta2_a55K :: List a_a3P6) ->
      ((foldMap
          @List
          Main.$fFoldableList
          @(base:Data.Semigroup.Internal.Dual
              (base:Data.Semigroup.Internal.Endo b_a3P5))
          @a_a3P6
          (base:Data.Semigroup.Internal.$fMonoidDual
             @(base:Data.Semigroup.Internal.Endo b_a3P5)
             (base:Data.Semigroup.Internal.$fMonoidEndo @b_a3P5))
          ((\ (x_a55N :: a_a3P6) (y_a55O :: b_a3P5) ->
              eta_a55I y_a55O x_a55N)
           `cast` (<a_a3P6>_R
                   %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Dual[0]
                                            (base:Data.Semigroup.Internal.N:Endo[0] <b_a3P5>_R))
                   :: (a_a3P6 -> b_a3P5 -> b_a3P5)
                      ~R# (a_a3P6
                           -> base:Data.Semigroup.Internal.Dual
                                (base:Data.Semigroup.Internal.Endo b_a3P5))))
          eta2_a55K)
       `cast` (base:Data.Semigroup.Internal.N:Dual[0]
                   (base:Data.Semigroup.Internal.N:Endo[0] <b_a3P5>_R)
               :: base:Data.Semigroup.Internal.Dual
                    (base:Data.Semigroup.Internal.Endo b_a3P5)
                  ~R# (b_a3P5 -> b_a3P5)))
        eta1_a55J

-- RHS size: {terms: 20, types: 18, coercions: 0, joins: 0/0}
$cfoldr'_a3OQ [Occ=LoopBreaker]
  :: forall a b. (a -> b -> b) -> b -> List a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 150 0}]
$cfoldr'_a3OQ
  = \ (@a_a3OT)
      (@b_a3OU)
      (f_a55X :: a_a3OT -> b_a3OU -> b_a3OU)
      (z0_a55Y :: b_a3OU)
      (xs_a55Z :: List a_a3OT) ->
      foldl
        @List
        Main.$fFoldableList
        @(b_a3OU -> b_a3OU)
        @a_a3OT
        (\ (ds_a560 :: b_a3OU -> b_a3OU)
           (ds1_a561 :: a_a3OT)
           (v_a562 [OS=OneShot] :: b_a3OU) ->
           case v_a562 of z_a563 { __DEFAULT ->
           ds_a560 (f_a55X ds1_a561 z_a563)
           })
        (id @b_a3OU)
        xs_a55Z
        z0_a55Y

-- RHS size: {terms: 17, types: 16, coercions: 0, joins: 0/0}
$cfoldr_a3Os [Occ=LoopBreaker]
  :: forall a b. (a -> b -> b) -> b -> List a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 30] 100 0}]
$cfoldr_a3Os
  = \ (@a_a3Ov)
      (@b_a3Ow)
      (f_a2g3 :: a_a3Ov -> b_a3Ow -> b_a3Ow)
      (z_a2g4 :: b_a3Ow)
      (ds_d4SZ :: List a_a3Ov) ->
      case ds_d4SZ of {
        Nil -> z_a2g4;
        Cons a1_a2g7 a2_a2g8 ->
          f_a2g3
            a1_a2g7
            (foldr
               @List Main.$fFoldableList @a_a3Ov @b_a3Ow f_a2g3 z_a2g4 a2_a2g8)
      }

-- RHS size: {terms: 18, types: 16, coercions: 0, joins: 0/1}
$cfoldMap'_a3Oe [Occ=LoopBreaker]
  :: forall m a. Monoid m => (a -> m) -> List a -> m
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 60] 170 0}]
$cfoldMap'_a3Oe
  = \ (@m_a3Oh)
      (@a_a3Oi)
      ($dMonoid_a3Oj :: Monoid m_a3Oh)
      (eta_a569 :: a_a3Oi -> m_a3Oh) ->
      let {
        $dSemigroup_a56a :: Semigroup m_a3Oh
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dSemigroup_a56a = GHC.Base.$p1Monoid @m_a3Oh $dMonoid_a3Oj } in
      Data.Foldable.foldl'
        @List
        Main.$fFoldableList
        @m_a3Oh
        @a_a3Oi
        (\ (acc_a56b :: m_a3Oh) (a1_a56c :: a_a3Oi) ->
           <> @m_a3Oh $dSemigroup_a56a acc_a56b (eta_a569 a1_a56c))
        (mempty @m_a3Oh $dMonoid_a3Oj)

-- RHS size: {terms: 20, types: 18, coercions: 0, joins: 0/0}
$cfoldMap_a3NU [Occ=LoopBreaker]
  :: forall m a. Monoid m => (a -> m) -> List a -> m
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 60 50] 150 0}]
$cfoldMap_a3NU
  = \ (@m_a3NX)
      (@a_a3NY)
      ($dMonoid_a3NZ :: Monoid m_a3NX)
      (f_a2gb :: a_a3NY -> m_a3NX)
      (ds_d4SY :: List a_a3NY) ->
      case ds_d4SY of {
        Nil -> mempty @m_a3NX $dMonoid_a3NZ;
        Cons a1_a2gd a2_a2ge ->
          mappend
            @m_a3NX
            $dMonoid_a3NZ
            (f_a2gb a1_a2gd)
            (foldMap
               @List
               Main.$fFoldableList
               @m_a3NX
               @a_a3NY
               $dMonoid_a3NZ
               f_a2gb
               a2_a2ge)
      }

-- RHS size: {terms: 14, types: 18, coercions: 25, joins: 0/0}
$cproduct_a3QY [Occ=LoopBreaker] :: forall a. Num a => List a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 120 60}]
$cproduct_a3QY
  = \ (@a_a3R1) ($dNum_a3R2 :: Num a_a3R1) ->
      ((\ (@(t_a56d :: * -> *))
          ($dFoldable_a56e :: Foldable t_a56d)
          (@a_a56f)
          ($dNum_a56g :: Num a_a56f) ->
          Data.Foldable.foldMap'
            @t_a56d
            $dFoldable_a56e
            @(base:Data.Semigroup.Internal.Product a_a56f)
            @a_a56f
            (base:Data.Semigroup.Internal.$fMonoidProduct @a_a56f $dNum_a56g)
            ((\ (ds_a56i :: a_a56f) -> ds_a56i)
             `cast` (<a_a56f>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Product[0]
                                              <a_a56f>_R)
                     :: (a_a56f -> a_a56f)
                        ~R# (a_a56f -> base:Data.Semigroup.Internal.Product a_a56f))))
       `cast` (forall (t :: <* -> *>_N).
               <Foldable t>_R
               %<'Many>_N ->_R forall (a :: <*>_N).
                               <Num a>_R
                               %<'Many>_N ->_R <t a>_R
                               %<'Many>_N ->_R base:Data.Semigroup.Internal.N:Product[0] <a>_R
               :: (forall {t :: * -> *} {a}.
                   (Foldable t, Num a) =>
                   t a -> base:Data.Semigroup.Internal.Product a)
                  ~R# (forall {t :: * -> *} {a}. (Foldable t, Num a) => t a -> a)))
        @List Main.$fFoldableList @a_a3R1 $dNum_a3R2

-- RHS size: {terms: 6, types: 7, coercions: 0, joins: 0/0}
$cfold_a3NI [Occ=LoopBreaker] :: forall m. Monoid m => List m -> m
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 40 0}]
$cfold_a3NI
  = \ (@m_a3NL) ($dMonoid_a3NM :: Monoid m_a3NL) ->
      foldMap
        @List
        Main.$fFoldableList
        @m_a3NL
        @m_a3NL
        $dMonoid_a3NM
        (id @m_a3NL)
end Rec }

Rec {
-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Main.$fFunctorList [InlPrag=CONLIKE] :: Functor List
[LclIdX[DFunId],
 Unf=DFun: \ -> GHC.Base.C:Functor TYPE: List $cfmap_a3N5 $c<$_a3Nn]
Main.$fFunctorList = GHC.Base.C:Functor @List $cfmap_a3N5 $c<$_a3Nn

-- RHS size: {terms: 15, types: 15, coercions: 0, joins: 0/0}
$c<$_a3Nn [Occ=LoopBreaker] :: forall a b. a -> List b -> List a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 30] 70 20}]
$c<$_a3Nn
  = \ (@a_a3Nq)
      (@b_a3Nr)
      (z_a2fZ :: a_a3Nq)
      (ds_d4SV :: List b_a3Nr) ->
      case ds_d4SV of {
        Nil -> Main.Nil @a_a3Nq;
        Cons _ [Occ=Dead] a2_a2g2 ->
          Main.Cons
            @a_a3Nq
            z_a2fZ
            (<$ @List Main.$fFunctorList @a_a3Nq @b_a3Nr z_a2fZ a2_a2g2)
      }

-- RHS size: {terms: 16, types: 16, coercions: 0, joins: 0/0}
$cfmap_a3N5 [Occ=LoopBreaker]
  :: forall a b. (a -> b) -> List a -> List b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 30] 90 20}]
$cfmap_a3N5
  = \ (@a_a3N8)
      (@b_a3N9)
      (f_a2fV :: a_a3N8 -> b_a3N9)
      (ds_d4SS :: List a_a3N8) ->
      case ds_d4SS of {
        Nil -> Main.Nil @b_a3N9;
        Cons a1_a2fX a2_a2fY ->
          Main.Cons
            @b_a3N9
            (f_a2fV a1_a2fX)
            (fmap @List Main.$fFunctorList @a_a3N8 @b_a3N9 f_a2fV a2_a2fY)
      }
end Rec }

Rec {
-- RHS size: {terms: 9, types: 8, coercions: 0, joins: 0/0}
Main.$fShowList [InlPrag=CONLIKE]
  :: forall a. Show a => Show (List a)
[LclIdX[DFunId],
 Unf=DFun: \ (@a_a1zh) (v_B1 :: Show a_a1zh) ->
       GHC.Show.C:Show TYPE: List a_a1zh
                       $cshowsPrec_a3Ms @a_a1zh v_B1
                       $cshow_a3MO @a_a1zh v_B1
                       $cshowList_a3MV @a_a1zh v_B1]
Main.$fShowList
  = \ (@a_a3Mp) ($dShow_a3Mq :: Show a_a3Mp) ->
      GHC.Show.C:Show
        @(List a_a3Mp)
        ($cshowsPrec_a3Ms @a_a3Mp $dShow_a3Mq)
        ($cshow_a3MO @a_a3Mp $dShow_a3Mq)
        ($cshowList_a3MV @a_a3Mp $dShow_a3Mq)

-- RHS size: {terms: 12, types: 12, coercions: 0, joins: 0/1}
$cshow_a3MO [Occ=LoopBreaker]
  :: forall a. Show a => List a -> String
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 100 60}]
$cshow_a3MO
  = \ (@a_a3Mp) ($dShow_a3Mq :: Show a_a3Mp) ->
      let {
        $dShow_a56X :: Show (List a_a3Mp)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dShow_a56X = Main.$fShowList @a_a3Mp $dShow_a3Mq } in
      \ (x_a56Y :: List a_a3Mp) ->
        showsPrec
          @(List a_a3Mp)
          $dShow_a56X
          (GHC.Types.I# 0#)
          x_a56Y
          (GHC.Types.[] @Char)

-- RHS size: {terms: 14, types: 15, coercions: 0, joins: 0/1}
$cshowList_a3MV [Occ=LoopBreaker]
  :: forall a. Show a => [List a] -> ShowS
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 130 60}]
$cshowList_a3MV
  = \ (@a_a3Mp) ($dShow_a3Mq :: Show a_a3Mp) ->
      let {
        $dShow_a56S :: Show (List a_a3Mp)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dShow_a56S = Main.$fShowList @a_a3Mp $dShow_a3Mq } in
      \ (ls_a56T :: [List a_a3Mp]) (s_a56U :: String) ->
        GHC.Show.showList__
          @(List a_a3Mp)
          (showsPrec @(List a_a3Mp) $dShow_a56S (GHC.Types.I# 0#))
          ls_a56T
          s_a56U

-- RHS size: {terms: 37, types: 28, coercions: 0, joins: 0/1}
$cshowsPrec_a3Ms [Occ=LoopBreaker]
  :: forall a. Show a => Int -> List a -> ShowS
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30] 470 60}]
$cshowsPrec_a3Ms
  = \ (@a_a3Mp) ($dShow_a3Mq :: Show a_a3Mp) ->
      let {
        $dShow_a3MM :: Show (List a_a3Mp)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dShow_a3MM = Main.$fShowList @a_a3Mp $dShow_a3Mq } in
      \ (ds_d4SM :: Int) (ds_d4SN :: List a_a3Mp) ->
        case ds_d4SN of {
          Nil -> showString (GHC.CString.unpackCString# "Nil"#);
          Cons b1_a2fT b2_a2fU ->
            showParen
              (>= @Int GHC.Classes.$fOrdInt ds_d4SM (GHC.Types.I# 11#))
              (. @String
                 @String
                 @String
                 (showString (GHC.CString.unpackCString# "Cons "#))
                 (. @String
                    @String
                    @String
                    (showsPrec @a_a3Mp $dShow_a3Mq (GHC.Types.I# 11#) b1_a2fT)
                    (. @String
                       @String
                       @String
                       GHC.Show.showSpace
                       (showsPrec
                          @(List a_a3Mp) $dShow_a3MM (GHC.Types.I# 11#) b2_a2fU))))
        }
end Rec }

Rec {
-- RHS size: {terms: 7, types: 7, coercions: 0, joins: 0/0}
Main.$fEqList [InlPrag=CONLIKE] :: forall a. Eq a => Eq (List a)
[LclIdX[DFunId],
 Unf=DFun: \ (@a_a1zb) (v_B1 :: Eq a_a1zb) ->
       GHC.Classes.C:Eq TYPE: List a_a1zb
                        $c==_a3LT @a_a1zb v_B1
                        $c/=_a3Mg @a_a1zb v_B1]
Main.$fEqList
  = \ (@a_a3LQ) ($dEq_a3LR :: Eq a_a3LQ) ->
      GHC.Classes.C:Eq
        @(List a_a3LQ)
        ($c==_a3LT @a_a3LQ $dEq_a3LR)
        ($c/=_a3Mg @a_a3LQ $dEq_a3LR)

-- RHS size: {terms: 16, types: 14, coercions: 0, joins: 0/1}
$c/=_a3Mg [Occ=LoopBreaker]
  :: forall a. Eq a => List a -> List a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 110 60}]
$c/=_a3Mg
  = \ (@a_a3LQ) ($dEq_a3LR :: Eq a_a3LQ) ->
      let {
        $dEq_a570 :: Eq (List a_a3LQ)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dEq_a570 = Main.$fEqList @a_a3LQ $dEq_a3LR } in
      \ (x_a571 :: List a_a3LQ) (y_a572 :: List a_a3LQ) ->
        case == @(List a_a3LQ) $dEq_a570 x_a571 y_a572 of {
          False -> GHC.Types.True;
          True -> GHC.Types.False
        }

-- RHS size: {terms: 46, types: 35, coercions: 0, joins: 0/1}
$c==_a3LT [Occ=LoopBreaker]
  :: forall a. Eq a => List a -> List a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30] 323 60}]
$c==_a3LT
  = \ (@a_a3LQ) ($dEq_a3LR :: Eq a_a3LQ) ->
      let {
        $dEq_a3Me :: Eq (List a_a3LQ)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dEq_a3Me = Main.$fEqList @a_a3LQ $dEq_a3LR } in
      \ (a_a2fK :: List a_a3LQ) (b_a2fL :: List a_a3LQ) ->
        case case GHC.Prim.dataToTag# @(List a_a3LQ) a_a2fK of a#_a2fM
             { __DEFAULT ->
             case GHC.Prim.dataToTag# @(List a_a3LQ) b_a2fL of b#_a2fN
             { __DEFAULT ->
             GHC.Prim./=# a#_a2fM b#_a2fN
             }
             }
        of ds_d4St
        { __DEFAULT ->
        case ds_d4St of {
          __DEFAULT ->
            case a_a2fK of {
              __DEFAULT -> GHC.Types.True;
              Cons a1_a2fO a2_a2fP ->
                case b_a2fL of {
                  __DEFAULT ->
                    case Control.Exception.Base.patError
                           @GHC.Types.LiftedRep @() "Gy08.hs:31:47-48|case"#
                    of {
                    };
                  Cons b1_a2fQ b2_a2fR ->
                    &&
                      (== @a_a3LQ $dEq_a3LR a1_a2fO b1_a2fQ)
                      (== @(List a_a3LQ) $dEq_a3Me a2_a2fP b2_a2fR)
                }
            };
          1# -> GHC.Types.False
        }
        }
end Rec }

-- RHS size: {terms: 8, types: 6, coercions: 0, joins: 0/0}
$cnull_a3Ky :: forall a. Maybe a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)}]
$cnull_a3Ky
  = \ (@a_a3KB) (ds_d4Sn :: Maybe a_a3KB) ->
      case ds_d4Sn of {
        Just _ [Occ=Dead] -> GHC.Types.False;
        Nothing -> GHC.Types.True
      }

-- RHS size: {terms: 13, types: 11, coercions: 0, joins: 0/0}
$cfoldr_a3Jl :: forall a b. (a -> b -> b) -> b -> Maybe a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 30] 50 0}]
$cfoldr_a3Jl
  = \ (@a_a3Jo)
      (@b_a3Jp)
      (f_a2fC :: a_a3Jo -> b_a3Jp -> b_a3Jp)
      (z_a2fD :: b_a3Jp)
      (ds_d4Sm :: Maybe a_a3Jo) ->
      case ds_d4Sm of {
        Just a1_a2fE -> f_a2fC a1_a2fE z_a2fD;
        Nothing -> z_a2fD
      }

-- RHS size: {terms: 13, types: 12, coercions: 0, joins: 0/0}
$cfoldMap_a3IU :: forall m a. Monoid m => (a -> m) -> Maybe a -> m
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 60 50] 60 0}]
$cfoldMap_a3IU
  = \ (@m_a3IX)
      (@a_a3IY)
      ($dMonoid_a3IZ :: Monoid m_a3IX)
      (f_a2fH :: a_a3IY -> m_a3IX)
      (ds_d4Sl :: Maybe a_a3IY) ->
      case ds_d4Sl of {
        Just a1_a2fI -> f_a2fH a1_a2fI;
        Nothing -> mempty @m_a3IX $dMonoid_a3IZ
      }

Rec {
-- RHS size: {terms: 18, types: 1, coercions: 0, joins: 0/0}
Main.$fFoldableMaybe [InlPrag=CONLIKE] :: Foldable Maybe
[LclIdX[DFunId],
 Unf=DFun: \ ->
       Data.Foldable.C:Foldable TYPE: Maybe
                                $cfold_a3II
                                $cfoldMap_a3IU
                                $cfoldMap'_a3J7
                                $cfoldr_a3Jl
                                $cfoldr'_a3Ju
                                $cfoldl_a3JG
                                $cfoldl'_a3JS
                                $cfoldr1_a3K4
                                $cfoldl1_a3Ke
                                $ctoList_a3Ko
                                $cnull_a3Ky
                                $clength_a3KG
                                $celem_a3KQ
                                $cmaximum_a3L2
                                $cminimum_a3Le
                                $csum_a3Lq
                                $cproduct_a3LC]
Main.$fFoldableMaybe
  = Data.Foldable.C:Foldable
      @Maybe
      $cfold_a3II
      $cfoldMap_a3IU
      $cfoldMap'_a3J7
      $cfoldr_a3Jl
      $cfoldr'_a3Ju
      $cfoldl_a3JG
      $cfoldl'_a3JS
      $cfoldr1_a3K4
      $cfoldl1_a3Ke
      $ctoList_a3Ko
      $cnull_a3Ky
      $clength_a3KG
      $celem_a3KQ
      $cmaximum_a3L2
      $cminimum_a3Le
      $csum_a3Lq
      $cproduct_a3LC

-- RHS size: {terms: 14, types: 18, coercions: 25, joins: 0/0}
$csum_a3Lq [Occ=LoopBreaker] :: forall a. Num a => Maybe a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 120 60}]
$csum_a3Lq
  = \ (@a_a3Lt) ($dNum_a3Lu :: Num a_a3Lt) ->
      ((\ (@(t_a4WR :: * -> *))
          ($dFoldable_a4WS :: Foldable t_a4WR)
          (@a_a4WT)
          ($dNum_a4WU :: Num a_a4WT) ->
          Data.Foldable.foldMap'
            @t_a4WR
            $dFoldable_a4WS
            @(base:Data.Semigroup.Internal.Sum a_a4WT)
            @a_a4WT
            (base:Data.Semigroup.Internal.$fMonoidSum @a_a4WT $dNum_a4WU)
            ((\ (ds_a52f :: a_a4WT) -> ds_a52f)
             `cast` (<a_a4WT>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Sum[0]
                                              <a_a4WT>_R)
                     :: (a_a4WT -> a_a4WT)
                        ~R# (a_a4WT -> base:Data.Semigroup.Internal.Sum a_a4WT))))
       `cast` (forall (t :: <* -> *>_N).
               <Foldable t>_R
               %<'Many>_N ->_R forall (a :: <*>_N).
                               <Num a>_R
                               %<'Many>_N ->_R <t a>_R
                               %<'Many>_N ->_R base:Data.Semigroup.Internal.N:Sum[0] <a>_R
               :: (forall {t :: * -> *} {a}.
                   (Foldable t, Num a) =>
                   t a -> base:Data.Semigroup.Internal.Sum a)
                  ~R# (forall {t :: * -> *} {a}. (Foldable t, Num a) => t a -> a)))
        @Maybe Main.$fFoldableMaybe @a_a3Lt $dNum_a3Lu

-- RHS size: {terms: 24, types: 25, coercions: 8, joins: 0/2}
$cminimum_a3Le [Occ=LoopBreaker] :: forall a. Ord a => Maybe a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 260 60}]
$cminimum_a3Le
  = \ (@a_a3Lh) ($dOrd_a3Li :: Ord a_a3Lh) ->
      let {
        d_a52o :: a_a3Lh
        [LclId,
         Str=b,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 110 0}]
        d_a52o
          = errorWithoutStackTrace
              @GHC.Types.LiftedRep
              @a_a3Lh
              (GHC.Base.build
                 @Char
                 (\ (@b_a52t) ->
                    GHC.CString.unpackFoldrCString#
                      @b_a52t "minimum: empty structure"#)) } in
      let {
        g_a52v :: Maybe a_a3Lh -> base:Data.Functor.Utils.Min a_a3Lh
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 80 0}]
        g_a52v
          = Data.Foldable.foldMap'
              @Maybe
              Main.$fFoldableMaybe
              @(base:Data.Functor.Utils.Min a_a3Lh)
              @a_a3Lh
              (base:Data.Functor.Utils.$fMonoidMin @a_a3Lh $dOrd_a3Li)
              ((\ (ds_a53M :: a_a3Lh) -> GHC.Maybe.Just @a_a3Lh ds_a53M)
               `cast` (<a_a3Lh>_R
                       %<'Many>_N ->_R Sym (base:Data.Functor.Utils.N:Min[0]) <a_a3Lh>_N
                       :: (a_a3Lh -> GHC.Maybe.Maybe a_a3Lh)
                          ~R# (a_a3Lh -> base:Data.Functor.Utils.Min a_a3Lh))) } in
      \ (x_a53N :: Maybe a_a3Lh) ->
        case (g_a52v x_a53N)
             `cast` (base:Data.Functor.Utils.N:Min[0] <a_a3Lh>_N
                     :: base:Data.Functor.Utils.Min a_a3Lh ~R# GHC.Maybe.Maybe a_a3Lh)
        of {
          GHC.Maybe.Nothing -> d_a52o;
          GHC.Maybe.Just v_a54h -> v_a54h
        }

-- RHS size: {terms: 24, types: 25, coercions: 8, joins: 0/2}
$cmaximum_a3L2 [Occ=LoopBreaker] :: forall a. Ord a => Maybe a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 260 60}]
$cmaximum_a3L2
  = \ (@a_a3L5) ($dOrd_a3L6 :: Ord a_a3L5) ->
      let {
        d_a54n :: a_a3L5
        [LclId,
         Str=b,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 110 0}]
        d_a54n
          = errorWithoutStackTrace
              @GHC.Types.LiftedRep
              @a_a3L5
              (GHC.Base.build
                 @Char
                 (\ (@b_a54o) ->
                    GHC.CString.unpackFoldrCString#
                      @b_a54o "maximum: empty structure"#)) } in
      let {
        g_a54p :: Maybe a_a3L5 -> base:Data.Functor.Utils.Max a_a3L5
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 80 0}]
        g_a54p
          = Data.Foldable.foldMap'
              @Maybe
              Main.$fFoldableMaybe
              @(base:Data.Functor.Utils.Max a_a3L5)
              @a_a3L5
              (base:Data.Functor.Utils.$fMonoidMax @a_a3L5 $dOrd_a3L6)
              ((\ (ds_a54r :: a_a3L5) -> GHC.Maybe.Just @a_a3L5 ds_a54r)
               `cast` (<a_a3L5>_R
                       %<'Many>_N ->_R Sym (base:Data.Functor.Utils.N:Max[0]) <a_a3L5>_N
                       :: (a_a3L5 -> GHC.Maybe.Maybe a_a3L5)
                          ~R# (a_a3L5 -> base:Data.Functor.Utils.Max a_a3L5))) } in
      \ (x_a54s :: Maybe a_a3L5) ->
        case (g_a54p x_a54s)
             `cast` (base:Data.Functor.Utils.N:Max[0] <a_a3L5>_N
                     :: base:Data.Functor.Utils.Max a_a3L5 ~R# GHC.Maybe.Maybe a_a3L5)
        of {
          GHC.Maybe.Nothing -> d_a54n;
          GHC.Maybe.Just v_a54x -> v_a54x
        }

-- RHS size: {terms: 15, types: 17, coercions: 26, joins: 0/0}
$celem_a3KQ [Occ=LoopBreaker]
  :: forall a. Eq a => a -> Maybe a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 130 60}]
$celem_a3KQ
  = \ (@a_a3KT) ($dEq_a3KU :: Eq a_a3KT) ->
      ((\ (@(t_a54z :: * -> *))
          ($dFoldable_a54A :: Foldable t_a54z)
          (@a_a54B)
          ($dEq_a54C :: Eq a_a54B)
          (eta_a54D :: a_a54B) ->
          foldMap
            @t_a54z
            $dFoldable_a54A
            @base:Data.Semigroup.Internal.Any
            @a_a54B
            base:Data.Semigroup.Internal.$fMonoidAny
            ((== @a_a54B $dEq_a54C eta_a54D)
             `cast` (<a_a54B>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Any[0])
                     :: (a_a54B -> Bool)
                        ~R# (a_a54B -> base:Data.Semigroup.Internal.Any))))
       `cast` (forall (t :: <* -> *>_N).
               <Foldable t>_R
               %<'Many>_N ->_R forall (a :: <*>_N).
                               <Eq a>_R
                               %<'Many>_N ->_R <a>_R
                               %<'Many>_N ->_R <t a>_R
                               %<'Many>_N ->_R base:Data.Semigroup.Internal.N:Any[0]
               :: (forall {t :: * -> *} {a}.
                   (Foldable t, Eq a) =>
                   a -> t a -> base:Data.Semigroup.Internal.Any)
                  ~R# (forall {t :: * -> *} {a}.
                       (Foldable t, Eq a) =>
                       a -> t a -> Bool)))
        @Maybe Main.$fFoldableMaybe @a_a3KT $dEq_a3KU

-- RHS size: {terms: 14, types: 8, coercions: 0, joins: 0/0}
$clength_a3KG [Occ=LoopBreaker] :: forall a. Maybe a -> Int
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=False, ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 91 0}]
$clength_a3KG
  = \ (@a_a3KJ) ->
      Data.Foldable.foldl'
        @Maybe
        Main.$fFoldableMaybe
        @Int
        @a_a3KJ
        (\ (c_a54K :: Int) _ [Occ=Dead] ->
           case c_a54K of { GHC.Types.I# x_a54N ->
           GHC.Types.I# (GHC.Prim.+# x_a54N 1#)
           })
        (GHC.Types.I# 0#)

-- RHS size: {terms: 11, types: 12, coercions: 0, joins: 0/0}
$ctoList_a3Ko [Occ=LoopBreaker] :: forall a. Maybe a -> [a]
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 70 40}]
$ctoList_a3Ko
  = \ (@a_a3Kr) (t1_a54S :: Maybe a_a3Kr) ->
      GHC.Base.build
        @a_a3Kr
        (\ (@b_a54T)
           (c_a54U [OS=OneShot] :: a_a3Kr -> b_a54T -> b_a54T)
           (n_a54V [OS=OneShot] :: b_a54T) ->
           foldr
             @Maybe Main.$fFoldableMaybe @a_a3Kr @b_a54T c_a54U n_a54V t1_a54S)

-- RHS size: {terms: 27, types: 26, coercions: 0, joins: 0/0}
$cfoldl1_a3Ke [Occ=LoopBreaker]
  :: forall a. (a -> a -> a) -> Maybe a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0] 260 0}]
$cfoldl1_a3Ke
  = \ (@a_a3Kh)
      (f_a54Z :: a_a3Kh -> a_a3Kh -> a_a3Kh)
      (xs_a550 :: Maybe a_a3Kh) ->
      case foldl
             @Maybe
             Main.$fFoldableMaybe
             @(GHC.Maybe.Maybe a_a3Kh)
             @a_a3Kh
             (\ (m_a551 :: GHC.Maybe.Maybe a_a3Kh) (y_a552 :: a_a3Kh) ->
                GHC.Maybe.Just
                  @a_a3Kh
                  (case m_a551 of {
                     GHC.Maybe.Nothing -> y_a552;
                     GHC.Maybe.Just x_a555 -> f_a54Z x_a555 y_a552
                   }))
             (GHC.Maybe.Nothing @a_a3Kh)
             xs_a550
      of {
        GHC.Maybe.Nothing ->
          errorWithoutStackTrace
            @GHC.Types.LiftedRep
            @a_a3Kh
            (GHC.Base.build
               @Char
               (\ (@b_a558) ->
                  GHC.CString.unpackFoldrCString#
                    @b_a558 "foldl1: empty structure"#));
        GHC.Maybe.Just v_a559 -> v_a559
      }

-- RHS size: {terms: 27, types: 26, coercions: 0, joins: 0/0}
$cfoldr1_a3K4 [Occ=LoopBreaker]
  :: forall a. (a -> a -> a) -> Maybe a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0] 260 0}]
$cfoldr1_a3K4
  = \ (@a_a3K7)
      (f_a55f :: a_a3K7 -> a_a3K7 -> a_a3K7)
      (xs_a55g :: Maybe a_a3K7) ->
      case foldr
             @Maybe
             Main.$fFoldableMaybe
             @a_a3K7
             @(GHC.Maybe.Maybe a_a3K7)
             (\ (x_a55h :: a_a3K7) (m_a55i :: GHC.Maybe.Maybe a_a3K7) ->
                GHC.Maybe.Just
                  @a_a3K7
                  (case m_a55i of {
                     GHC.Maybe.Nothing -> x_a55h;
                     GHC.Maybe.Just y_a55l -> f_a55f x_a55h y_a55l
                   }))
             (GHC.Maybe.Nothing @a_a3K7)
             xs_a55g
      of {
        GHC.Maybe.Nothing ->
          errorWithoutStackTrace
            @GHC.Types.LiftedRep
            @a_a3K7
            (GHC.Base.build
               @Char
               (\ (@b_a55o) ->
                  GHC.CString.unpackFoldrCString#
                    @b_a55o "foldr1: empty structure"#));
        GHC.Maybe.Just v_a55p -> v_a55p
      }

-- RHS size: {terms: 20, types: 18, coercions: 0, joins: 0/0}
$cfoldl'_a3JS [Occ=LoopBreaker]
  :: forall b a. (b -> a -> b) -> b -> Maybe a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 150 0}]
$cfoldl'_a3JS
  = \ (@b_a3JV)
      (@a_a3JW)
      (f_a55w :: b_a3JV -> a_a3JW -> b_a3JV)
      (z0_a55x :: b_a3JV)
      (xs_a55y :: Maybe a_a3JW) ->
      foldr
        @Maybe
        Main.$fFoldableMaybe
        @a_a3JW
        @(b_a3JV -> b_a3JV)
        (\ (ds_a55z :: a_a3JW)
           (ds1_a55A :: b_a3JV -> b_a3JV)
           (v_a55B [OS=OneShot] :: b_a3JV) ->
           case v_a55B of z_a55C { __DEFAULT ->
           ds1_a55A (f_a55w z_a55C ds_a55z)
           })
        (id @b_a3JV)
        xs_a55y
        z0_a55x

-- RHS size: {terms: 16, types: 18, coercions: 10, joins: 0/0}
$cfoldl_a3JG [Occ=LoopBreaker]
  :: forall b a. (b -> a -> b) -> b -> Maybe a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 130 0}]
$cfoldl_a3JG
  = \ (@b_a3JJ)
      (@a_a3JK)
      (eta_a55I :: b_a3JJ -> a_a3JK -> b_a3JJ)
      (eta1_a55J :: b_a3JJ)
      (eta2_a55K :: Maybe a_a3JK) ->
      ((foldMap
          @Maybe
          Main.$fFoldableMaybe
          @(base:Data.Semigroup.Internal.Dual
              (base:Data.Semigroup.Internal.Endo b_a3JJ))
          @a_a3JK
          (base:Data.Semigroup.Internal.$fMonoidDual
             @(base:Data.Semigroup.Internal.Endo b_a3JJ)
             (base:Data.Semigroup.Internal.$fMonoidEndo @b_a3JJ))
          ((\ (x_a55N :: a_a3JK) (y_a55O :: b_a3JJ) ->
              eta_a55I y_a55O x_a55N)
           `cast` (<a_a3JK>_R
                   %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Dual[0]
                                            (base:Data.Semigroup.Internal.N:Endo[0] <b_a3JJ>_R))
                   :: (a_a3JK -> b_a3JJ -> b_a3JJ)
                      ~R# (a_a3JK
                           -> base:Data.Semigroup.Internal.Dual
                                (base:Data.Semigroup.Internal.Endo b_a3JJ))))
          eta2_a55K)
       `cast` (base:Data.Semigroup.Internal.N:Dual[0]
                   (base:Data.Semigroup.Internal.N:Endo[0] <b_a3JJ>_R)
               :: base:Data.Semigroup.Internal.Dual
                    (base:Data.Semigroup.Internal.Endo b_a3JJ)
                  ~R# (b_a3JJ -> b_a3JJ)))
        eta1_a55J

-- RHS size: {terms: 20, types: 18, coercions: 0, joins: 0/0}
$cfoldr'_a3Ju [Occ=LoopBreaker]
  :: forall a b. (a -> b -> b) -> b -> Maybe a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 150 0}]
$cfoldr'_a3Ju
  = \ (@a_a3Jx)
      (@b_a3Jy)
      (f_a55X :: a_a3Jx -> b_a3Jy -> b_a3Jy)
      (z0_a55Y :: b_a3Jy)
      (xs_a55Z :: Maybe a_a3Jx) ->
      foldl
        @Maybe
        Main.$fFoldableMaybe
        @(b_a3Jy -> b_a3Jy)
        @a_a3Jx
        (\ (ds_a560 :: b_a3Jy -> b_a3Jy)
           (ds1_a561 :: a_a3Jx)
           (v_a562 [OS=OneShot] :: b_a3Jy) ->
           case v_a562 of z_a563 { __DEFAULT ->
           ds_a560 (f_a55X ds1_a561 z_a563)
           })
        (id @b_a3Jy)
        xs_a55Z
        z0_a55Y

-- RHS size: {terms: 18, types: 16, coercions: 0, joins: 0/1}
$cfoldMap'_a3J7 [Occ=LoopBreaker]
  :: forall m a. Monoid m => (a -> m) -> Maybe a -> m
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 60] 170 0}]
$cfoldMap'_a3J7
  = \ (@m_a3Ja)
      (@a_a3Jb)
      ($dMonoid_a3Jc :: Monoid m_a3Ja)
      (eta_a569 :: a_a3Jb -> m_a3Ja) ->
      let {
        $dSemigroup_a56a :: Semigroup m_a3Ja
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dSemigroup_a56a = GHC.Base.$p1Monoid @m_a3Ja $dMonoid_a3Jc } in
      Data.Foldable.foldl'
        @Maybe
        Main.$fFoldableMaybe
        @m_a3Ja
        @a_a3Jb
        (\ (acc_a56b :: m_a3Ja) (a1_a56c :: a_a3Jb) ->
           <> @m_a3Ja $dSemigroup_a56a acc_a56b (eta_a569 a1_a56c))
        (mempty @m_a3Ja $dMonoid_a3Jc)

-- RHS size: {terms: 14, types: 18, coercions: 25, joins: 0/0}
$cproduct_a3LC [Occ=LoopBreaker] :: forall a. Num a => Maybe a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 120 60}]
$cproduct_a3LC
  = \ (@a_a3LF) ($dNum_a3LG :: Num a_a3LF) ->
      ((\ (@(t_a56d :: * -> *))
          ($dFoldable_a56e :: Foldable t_a56d)
          (@a_a56f)
          ($dNum_a56g :: Num a_a56f) ->
          Data.Foldable.foldMap'
            @t_a56d
            $dFoldable_a56e
            @(base:Data.Semigroup.Internal.Product a_a56f)
            @a_a56f
            (base:Data.Semigroup.Internal.$fMonoidProduct @a_a56f $dNum_a56g)
            ((\ (ds_a56i :: a_a56f) -> ds_a56i)
             `cast` (<a_a56f>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Product[0]
                                              <a_a56f>_R)
                     :: (a_a56f -> a_a56f)
                        ~R# (a_a56f -> base:Data.Semigroup.Internal.Product a_a56f))))
       `cast` (forall (t :: <* -> *>_N).
               <Foldable t>_R
               %<'Many>_N ->_R forall (a :: <*>_N).
                               <Num a>_R
                               %<'Many>_N ->_R <t a>_R
                               %<'Many>_N ->_R base:Data.Semigroup.Internal.N:Product[0] <a>_R
               :: (forall {t :: * -> *} {a}.
                   (Foldable t, Num a) =>
                   t a -> base:Data.Semigroup.Internal.Product a)
                  ~R# (forall {t :: * -> *} {a}. (Foldable t, Num a) => t a -> a)))
        @Maybe Main.$fFoldableMaybe @a_a3LF $dNum_a3LG

-- RHS size: {terms: 6, types: 7, coercions: 0, joins: 0/0}
$cfold_a3II [Occ=LoopBreaker] :: forall m. Monoid m => Maybe m -> m
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 40 0}]
$cfold_a3II
  = \ (@m_a3IL) ($dMonoid_a3IM :: Monoid m_a3IL) ->
      foldMap
        @Maybe
        Main.$fFoldableMaybe
        @m_a3IL
        @m_a3IL
        $dMonoid_a3IM
        (id @m_a3IL)
end Rec }

-- RHS size: {terms: 11, types: 10, coercions: 0, joins: 0/0}
$c<$_a3It :: forall a b. a -> Maybe b -> Maybe a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)}]
$c<$_a3It
  = \ (@a_a3Iw)
      (@b_a3Ix)
      (z_a2fz :: a_a3Iw)
      (ds_d4Sj :: Maybe b_a3Ix) ->
      case ds_d4Sj of {
        Just _ [Occ=Dead] -> Main.Just @a_a3Iw z_a2fz;
        Nothing -> Main.Nothing @a_a3Iw
      }

-- RHS size: {terms: 12, types: 11, coercions: 0, joins: 0/0}
$cfmap_a3Ih :: forall a b. (a -> b) -> Maybe a -> Maybe b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 30] 50 20}]
$cfmap_a3Ih
  = \ (@a_a3Ik)
      (@b_a3Il)
      (f_a2fw :: a_a3Ik -> b_a3Il)
      (ds_d4Sh :: Maybe a_a3Ik) ->
      case ds_d4Sh of {
        Just a1_a2fx -> Main.Just @b_a3Il (f_a2fw a1_a2fx);
        Nothing -> Main.Nothing @b_a3Il
      }

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Main.$fFunctorMaybe [InlPrag=CONLIKE] :: Functor Maybe
[LclIdX[DFunId],
 Unf=DFun: \ ->
       GHC.Base.C:Functor TYPE: Maybe $cfmap_a3Ih $c<$_a3It]
Main.$fFunctorMaybe
  = GHC.Base.C:Functor @Maybe $cfmap_a3Ih $c<$_a3It

Rec {
-- RHS size: {terms: 7, types: 1, coercions: 0, joins: 0/0}
Main.$fTraversableMaybe [InlPrag=CONLIKE] :: Traversable Maybe
[LclIdX[DFunId],
 Unf=DFun: \ ->
       Data.Traversable.C:Traversable TYPE: Maybe
                                      Main.$fFunctorMaybe
                                      Main.$fFoldableMaybe
                                      $ctraverse_a4kX
                                      $csequenceA_a4ld
                                      $cmapM_a4lr
                                      $csequence_a4lH]
Main.$fTraversableMaybe
  = Data.Traversable.C:Traversable
      @Maybe
      Main.$fFunctorMaybe
      Main.$fFoldableMaybe
      $ctraverse_a4kX
      $csequenceA_a4ld
      $cmapM_a4lr
      $csequence_a4lH

-- RHS size: {terms: 8, types: 11, coercions: 0, joins: 0/0}
$cmapM_a4lr [Occ=LoopBreaker]
  :: forall (m :: * -> *) a b.
     Monad m =>
     (a -> m b) -> Maybe a -> m (Maybe b)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30] 50 0}]
$cmapM_a4lr
  = \ (@(m_a4lu :: * -> *))
      (@a_a4lv)
      (@b_a4lw)
      ($dMonad_a4lx :: Monad m_a4lu) ->
      traverse
        @Maybe
        Main.$fTraversableMaybe
        @m_a4lu
        @a_a4lv
        @b_a4lw
        (GHC.Base.$p1Monad @m_a4lu $dMonad_a4lx)

-- RHS size: {terms: 7, types: 12, coercions: 0, joins: 0/0}
$csequenceA_a4ld [Occ=LoopBreaker]
  :: forall (f :: * -> *) a.
     Applicative f =>
     Maybe (f a) -> f (Maybe a)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 40 0}]
$csequenceA_a4ld
  = \ (@(f_a4lg :: * -> *))
      (@a_a4lh)
      ($dApplicative_a4li :: Applicative f_a4lg) ->
      traverse
        @Maybe
        Main.$fTraversableMaybe
        @f_a4lg
        @(f_a4lg a_a4lh)
        @a_a4lh
        $dApplicative_a4li
        (id @(f_a4lg a_a4lh))

-- RHS size: {terms: 7, types: 9, coercions: 0, joins: 0/0}
$csequence_a4lH [Occ=LoopBreaker]
  :: forall (m :: * -> *) a. Monad m => Maybe (m a) -> m (Maybe a)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30] 50 0}]
$csequence_a4lH
  = \ (@(m_a4lK :: * -> *))
      (@a_a4lL)
      ($dMonad_a4lM :: Monad m_a4lK) ->
      sequenceA
        @Maybe
        Main.$fTraversableMaybe
        @m_a4lK
        @a_a4lL
        (GHC.Base.$p1Monad @m_a4lK $dMonad_a4lM)

-- RHS size: {terms: 18, types: 30, coercions: 0, joins: 0/2}
$ctraverse_a4kX [Occ=LoopBreaker]
  :: forall (f :: * -> *) a b.
     Applicative f =>
     (a -> f b) -> Maybe a -> f (Maybe b)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 150 60}]
$ctraverse_a4kX
  = \ (@(f_a4l0 :: * -> *))
      (@a_a4l1)
      (@b_a4l2)
      ($dApplicative_a4l3 :: Applicative f_a4l0)
      (eta1_a56N :: a_a4l1 -> f_a4l0 b_a4l2) ->
      let {
        f1_a56O :: Maybe (f_a4l0 b_a4l2) -> f_a4l0 (Maybe b_a4l2)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 30 0}]
        f1_a56O
          = sequenceA
              @Maybe
              Main.$fTraversableMaybe
              @f_a4l0
              @b_a4l2
              $dApplicative_a4l3 } in
      let {
        g_a56P :: Maybe a_a4l1 -> Maybe (f_a4l0 b_a4l2)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 50 0}]
        g_a56P
          = fmap
              @Maybe
              (Data.Traversable.$p1Traversable @Maybe Main.$fTraversableMaybe)
              @a_a4l1
              @(f_a4l0 b_a4l2)
              eta1_a56N } in
      \ (x_a56Q :: Maybe a_a4l1) -> f1_a56O (g_a56P x_a56Q)
end Rec }

-- RHS size: {terms: 26, types: 14, coercions: 0, joins: 0/0}
$cshowsPrec_a3HM :: forall a. Show a => Int -> Maybe a -> ShowS
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 0 100] 320 0}]
$cshowsPrec_a3HM
  = \ (@a_a3HJ)
      ($dShow_a3HK :: Show a_a3HJ)
      (a_a2fu :: Int)
      (ds_d4Sc :: Maybe a_a3HJ) ->
      case ds_d4Sc of {
        Just b1_a2fv ->
          showParen
            (>= @Int GHC.Classes.$fOrdInt a_a2fu (GHC.Types.I# 11#))
            (. @String
               @String
               @String
               (showString (GHC.CString.unpackCString# "Just "#))
               (showsPrec @a_a3HJ $dShow_a3HK (GHC.Types.I# 11#) b1_a2fv));
        Nothing -> showString (GHC.CString.unpackCString# "Nothing"#)
      }

Rec {
-- RHS size: {terms: 9, types: 8, coercions: 0, joins: 0/0}
Main.$fShowMaybe [InlPrag=CONLIKE]
  :: forall a. Show a => Show (Maybe a)
[LclIdX[DFunId],
 Unf=DFun: \ (@a_a1yV) (v_B1 :: Show a_a1yV) ->
       GHC.Show.C:Show TYPE: Maybe a_a1yV
                       $cshowsPrec_a3HM @a_a1yV v_B1
                       $cshow_a3I0 @a_a1yV v_B1
                       $cshowList_a3I7 @a_a1yV v_B1]
Main.$fShowMaybe
  = \ (@a_a3HJ) ($dShow_a3HK :: Show a_a3HJ) ->
      GHC.Show.C:Show
        @(Maybe a_a3HJ)
        ($cshowsPrec_a3HM @a_a3HJ $dShow_a3HK)
        ($cshow_a3I0 @a_a3HJ $dShow_a3HK)
        ($cshowList_a3I7 @a_a3HJ $dShow_a3HK)

-- RHS size: {terms: 14, types: 15, coercions: 0, joins: 0/1}
$cshowList_a3I7 [Occ=LoopBreaker]
  :: forall a. Show a => [Maybe a] -> ShowS
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 130 60}]
$cshowList_a3I7
  = \ (@a_a3HJ) ($dShow_a3HK :: Show a_a3HJ) ->
      let {
        $dShow_a56S :: Show (Maybe a_a3HJ)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dShow_a56S = Main.$fShowMaybe @a_a3HJ $dShow_a3HK } in
      \ (ls_a56T :: [Maybe a_a3HJ]) (s_a56U :: String) ->
        GHC.Show.showList__
          @(Maybe a_a3HJ)
          (showsPrec @(Maybe a_a3HJ) $dShow_a56S (GHC.Types.I# 0#))
          ls_a56T
          s_a56U

-- RHS size: {terms: 12, types: 12, coercions: 0, joins: 0/1}
$cshow_a3I0 [Occ=LoopBreaker]
  :: forall a. Show a => Maybe a -> String
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 100 60}]
$cshow_a3I0
  = \ (@a_a3HJ) ($dShow_a3HK :: Show a_a3HJ) ->
      let {
        $dShow_a56X :: Show (Maybe a_a3HJ)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dShow_a56X = Main.$fShowMaybe @a_a3HJ $dShow_a3HK } in
      \ (x_a56Y :: Maybe a_a3HJ) ->
        showsPrec
          @(Maybe a_a3HJ)
          $dShow_a56X
          (GHC.Types.I# 0#)
          x_a56Y
          (GHC.Types.[] @Char)
end Rec }

-- RHS size: {terms: 38, types: 25, coercions: 0, joins: 0/0}
$c==_a3Hf :: forall a. Eq a => Maybe a -> Maybe a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 70] 203 20}]
$c==_a3Hf
  = \ (@a_a3Hc)
      ($dEq_a3Hd :: Eq a_a3Hc)
      (a_a2fo :: Maybe a_a3Hc)
      (b_a2fp :: Maybe a_a3Hc) ->
      case case GHC.Prim.dataToTag# @(Maybe a_a3Hc) a_a2fo of a#_a2fq
           { __DEFAULT ->
           case GHC.Prim.dataToTag# @(Maybe a_a3Hc) b_a2fp of b#_a2fr
           { __DEFAULT ->
           GHC.Prim./=# a#_a2fq b#_a2fr
           }
           }
      of ds_d4RT
      { __DEFAULT ->
      case ds_d4RT of {
        __DEFAULT ->
          case a_a2fo of {
            __DEFAULT -> GHC.Types.True;
            Just a1_a2fs ->
              case b_a2fp of {
                __DEFAULT ->
                  case Control.Exception.Base.patError
                         @GHC.Types.LiftedRep @() "Gy08.hs:32:43-44|case"#
                  of {
                  };
                Just b1_a2ft -> == @a_a3Hc $dEq_a3Hd a1_a2fs b1_a2ft
              }
          };
        1# -> GHC.Types.False
      }
      }

Rec {
-- RHS size: {terms: 7, types: 7, coercions: 0, joins: 0/0}
Main.$fEqMaybe [InlPrag=CONLIKE] :: forall a. Eq a => Eq (Maybe a)
[LclIdX[DFunId],
 Unf=DFun: \ (@a_a1yP) (v_B1 :: Eq a_a1yP) ->
       GHC.Classes.C:Eq TYPE: Maybe a_a1yP
                        $c==_a3Hf @a_a1yP v_B1
                        $c/=_a3HA @a_a1yP v_B1]
Main.$fEqMaybe
  = \ (@a_a3Hc) ($dEq_a3Hd :: Eq a_a3Hc) ->
      GHC.Classes.C:Eq
        @(Maybe a_a3Hc)
        ($c==_a3Hf @a_a3Hc $dEq_a3Hd)
        ($c/=_a3HA @a_a3Hc $dEq_a3Hd)

-- RHS size: {terms: 16, types: 14, coercions: 0, joins: 0/1}
$c/=_a3HA [Occ=LoopBreaker]
  :: forall a. Eq a => Maybe a -> Maybe a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 110 60}]
$c/=_a3HA
  = \ (@a_a3Hc) ($dEq_a3Hd :: Eq a_a3Hc) ->
      let {
        $dEq_a570 :: Eq (Maybe a_a3Hc)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dEq_a570 = Main.$fEqMaybe @a_a3Hc $dEq_a3Hd } in
      \ (x_a571 :: Maybe a_a3Hc) (y_a572 :: Maybe a_a3Hc) ->
        case == @(Maybe a_a3Hc) $dEq_a570 x_a571 y_a572 of {
          False -> GHC.Types.True;
          True -> GHC.Types.False
        }
end Rec }

-- RHS size: {terms: 8, types: 9, coercions: 0, joins: 0/0}
$cnull_a3FU :: forall a. NonEmpty a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)}]
$cnull_a3FU
  = \ (@a_a3FX) (ds_d4RL :: NonEmpty a_a3FX) ->
      case ds_d4RL of {
        Last _ [Occ=Dead] -> GHC.Types.False;
        NECons _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.False
      }

Rec {
-- RHS size: {terms: 18, types: 1, coercions: 0, joins: 0/0}
Main.$fFoldableNonEmpty [InlPrag=CONLIKE] :: Foldable NonEmpty
[LclIdX[DFunId],
 Unf=DFun: \ ->
       Data.Foldable.C:Foldable TYPE: NonEmpty
                                $cfold_a3DK
                                $cfoldMap_a3DW
                                $cfoldMap'_a3Ee
                                $cfoldr_a3Es
                                $cfoldr'_a3EQ
                                $cfoldl_a3F2
                                $cfoldl'_a3Fe
                                $cfoldr1_a3Fq
                                $cfoldl1_a3FA
                                $ctoList_a3FK
                                $cnull_a3FU
                                $clength_a3G2
                                $celem_a3Gc
                                $cmaximum_a3Go
                                $cminimum_a3GA
                                $csum_a3GM
                                $cproduct_a3GY]
Main.$fFoldableNonEmpty
  = Data.Foldable.C:Foldable
      @NonEmpty
      $cfold_a3DK
      $cfoldMap_a3DW
      $cfoldMap'_a3Ee
      $cfoldr_a3Es
      $cfoldr'_a3EQ
      $cfoldl_a3F2
      $cfoldl'_a3Fe
      $cfoldr1_a3Fq
      $cfoldl1_a3FA
      $ctoList_a3FK
      $cnull_a3FU
      $clength_a3G2
      $celem_a3Gc
      $cmaximum_a3Go
      $cminimum_a3GA
      $csum_a3GM
      $cproduct_a3GY

-- RHS size: {terms: 14, types: 18, coercions: 25, joins: 0/0}
$csum_a3GM [Occ=LoopBreaker] :: forall a. Num a => NonEmpty a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 120 60}]
$csum_a3GM
  = \ (@a_a3GP) ($dNum_a3GQ :: Num a_a3GP) ->
      ((\ (@(t_a4WR :: * -> *))
          ($dFoldable_a4WS :: Foldable t_a4WR)
          (@a_a4WT)
          ($dNum_a4WU :: Num a_a4WT) ->
          Data.Foldable.foldMap'
            @t_a4WR
            $dFoldable_a4WS
            @(base:Data.Semigroup.Internal.Sum a_a4WT)
            @a_a4WT
            (base:Data.Semigroup.Internal.$fMonoidSum @a_a4WT $dNum_a4WU)
            ((\ (ds_a52f :: a_a4WT) -> ds_a52f)
             `cast` (<a_a4WT>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Sum[0]
                                              <a_a4WT>_R)
                     :: (a_a4WT -> a_a4WT)
                        ~R# (a_a4WT -> base:Data.Semigroup.Internal.Sum a_a4WT))))
       `cast` (forall (t :: <* -> *>_N).
               <Foldable t>_R
               %<'Many>_N ->_R forall (a :: <*>_N).
                               <Num a>_R
                               %<'Many>_N ->_R <t a>_R
                               %<'Many>_N ->_R base:Data.Semigroup.Internal.N:Sum[0] <a>_R
               :: (forall {t :: * -> *} {a}.
                   (Foldable t, Num a) =>
                   t a -> base:Data.Semigroup.Internal.Sum a)
                  ~R# (forall {t :: * -> *} {a}. (Foldable t, Num a) => t a -> a)))
        @NonEmpty Main.$fFoldableNonEmpty @a_a3GP $dNum_a3GQ

-- RHS size: {terms: 24, types: 25, coercions: 8, joins: 0/2}
$cminimum_a3GA [Occ=LoopBreaker]
  :: forall a. Ord a => NonEmpty a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 260 60}]
$cminimum_a3GA
  = \ (@a_a3GD) ($dOrd_a3GE :: Ord a_a3GD) ->
      let {
        d_a52o :: a_a3GD
        [LclId,
         Str=b,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 110 0}]
        d_a52o
          = errorWithoutStackTrace
              @GHC.Types.LiftedRep
              @a_a3GD
              (GHC.Base.build
                 @Char
                 (\ (@b_a52t) ->
                    GHC.CString.unpackFoldrCString#
                      @b_a52t "minimum: empty structure"#)) } in
      let {
        g_a52v :: NonEmpty a_a3GD -> base:Data.Functor.Utils.Min a_a3GD
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 80 0}]
        g_a52v
          = Data.Foldable.foldMap'
              @NonEmpty
              Main.$fFoldableNonEmpty
              @(base:Data.Functor.Utils.Min a_a3GD)
              @a_a3GD
              (base:Data.Functor.Utils.$fMonoidMin @a_a3GD $dOrd_a3GE)
              ((\ (ds_a53M :: a_a3GD) -> GHC.Maybe.Just @a_a3GD ds_a53M)
               `cast` (<a_a3GD>_R
                       %<'Many>_N ->_R Sym (base:Data.Functor.Utils.N:Min[0]) <a_a3GD>_N
                       :: (a_a3GD -> GHC.Maybe.Maybe a_a3GD)
                          ~R# (a_a3GD -> base:Data.Functor.Utils.Min a_a3GD))) } in
      \ (x_a53N :: NonEmpty a_a3GD) ->
        case (g_a52v x_a53N)
             `cast` (base:Data.Functor.Utils.N:Min[0] <a_a3GD>_N
                     :: base:Data.Functor.Utils.Min a_a3GD ~R# GHC.Maybe.Maybe a_a3GD)
        of {
          GHC.Maybe.Nothing -> d_a52o;
          GHC.Maybe.Just v_a54h -> v_a54h
        }

-- RHS size: {terms: 24, types: 25, coercions: 8, joins: 0/2}
$cmaximum_a3Go [Occ=LoopBreaker]
  :: forall a. Ord a => NonEmpty a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 260 60}]
$cmaximum_a3Go
  = \ (@a_a3Gr) ($dOrd_a3Gs :: Ord a_a3Gr) ->
      let {
        d_a54n :: a_a3Gr
        [LclId,
         Str=b,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 110 0}]
        d_a54n
          = errorWithoutStackTrace
              @GHC.Types.LiftedRep
              @a_a3Gr
              (GHC.Base.build
                 @Char
                 (\ (@b_a54o) ->
                    GHC.CString.unpackFoldrCString#
                      @b_a54o "maximum: empty structure"#)) } in
      let {
        g_a54p :: NonEmpty a_a3Gr -> base:Data.Functor.Utils.Max a_a3Gr
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 80 0}]
        g_a54p
          = Data.Foldable.foldMap'
              @NonEmpty
              Main.$fFoldableNonEmpty
              @(base:Data.Functor.Utils.Max a_a3Gr)
              @a_a3Gr
              (base:Data.Functor.Utils.$fMonoidMax @a_a3Gr $dOrd_a3Gs)
              ((\ (ds_a54r :: a_a3Gr) -> GHC.Maybe.Just @a_a3Gr ds_a54r)
               `cast` (<a_a3Gr>_R
                       %<'Many>_N ->_R Sym (base:Data.Functor.Utils.N:Max[0]) <a_a3Gr>_N
                       :: (a_a3Gr -> GHC.Maybe.Maybe a_a3Gr)
                          ~R# (a_a3Gr -> base:Data.Functor.Utils.Max a_a3Gr))) } in
      \ (x_a54s :: NonEmpty a_a3Gr) ->
        case (g_a54p x_a54s)
             `cast` (base:Data.Functor.Utils.N:Max[0] <a_a3Gr>_N
                     :: base:Data.Functor.Utils.Max a_a3Gr ~R# GHC.Maybe.Maybe a_a3Gr)
        of {
          GHC.Maybe.Nothing -> d_a54n;
          GHC.Maybe.Just v_a54x -> v_a54x
        }

-- RHS size: {terms: 15, types: 17, coercions: 26, joins: 0/0}
$celem_a3Gc [Occ=LoopBreaker]
  :: forall a. Eq a => a -> NonEmpty a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 130 60}]
$celem_a3Gc
  = \ (@a_a3Gf) ($dEq_a3Gg :: Eq a_a3Gf) ->
      ((\ (@(t_a54z :: * -> *))
          ($dFoldable_a54A :: Foldable t_a54z)
          (@a_a54B)
          ($dEq_a54C :: Eq a_a54B)
          (eta_a54D :: a_a54B) ->
          foldMap
            @t_a54z
            $dFoldable_a54A
            @base:Data.Semigroup.Internal.Any
            @a_a54B
            base:Data.Semigroup.Internal.$fMonoidAny
            ((== @a_a54B $dEq_a54C eta_a54D)
             `cast` (<a_a54B>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Any[0])
                     :: (a_a54B -> Bool)
                        ~R# (a_a54B -> base:Data.Semigroup.Internal.Any))))
       `cast` (forall (t :: <* -> *>_N).
               <Foldable t>_R
               %<'Many>_N ->_R forall (a :: <*>_N).
                               <Eq a>_R
                               %<'Many>_N ->_R <a>_R
                               %<'Many>_N ->_R <t a>_R
                               %<'Many>_N ->_R base:Data.Semigroup.Internal.N:Any[0]
               :: (forall {t :: * -> *} {a}.
                   (Foldable t, Eq a) =>
                   a -> t a -> base:Data.Semigroup.Internal.Any)
                  ~R# (forall {t :: * -> *} {a}.
                       (Foldable t, Eq a) =>
                       a -> t a -> Bool)))
        @NonEmpty Main.$fFoldableNonEmpty @a_a3Gf $dEq_a3Gg

-- RHS size: {terms: 14, types: 8, coercions: 0, joins: 0/0}
$clength_a3G2 [Occ=LoopBreaker] :: forall a. NonEmpty a -> Int
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=False, ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 91 0}]
$clength_a3G2
  = \ (@a_a3G5) ->
      Data.Foldable.foldl'
        @NonEmpty
        Main.$fFoldableNonEmpty
        @Int
        @a_a3G5
        (\ (c_a54K :: Int) _ [Occ=Dead] ->
           case c_a54K of { GHC.Types.I# x_a54N ->
           GHC.Types.I# (GHC.Prim.+# x_a54N 1#)
           })
        (GHC.Types.I# 0#)

-- RHS size: {terms: 11, types: 12, coercions: 0, joins: 0/0}
$ctoList_a3FK [Occ=LoopBreaker] :: forall a. NonEmpty a -> [a]
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 70 40}]
$ctoList_a3FK
  = \ (@a_a3FN) (t1_a54S :: NonEmpty a_a3FN) ->
      GHC.Base.build
        @a_a3FN
        (\ (@b_a54T)
           (c_a54U [OS=OneShot] :: a_a3FN -> b_a54T -> b_a54T)
           (n_a54V [OS=OneShot] :: b_a54T) ->
           foldr
             @NonEmpty
             Main.$fFoldableNonEmpty
             @a_a3FN
             @b_a54T
             c_a54U
             n_a54V
             t1_a54S)

-- RHS size: {terms: 27, types: 26, coercions: 0, joins: 0/0}
$cfoldl1_a3FA [Occ=LoopBreaker]
  :: forall a. (a -> a -> a) -> NonEmpty a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0] 260 0}]
$cfoldl1_a3FA
  = \ (@a_a3FD)
      (f_a54Z :: a_a3FD -> a_a3FD -> a_a3FD)
      (xs_a550 :: NonEmpty a_a3FD) ->
      case foldl
             @NonEmpty
             Main.$fFoldableNonEmpty
             @(GHC.Maybe.Maybe a_a3FD)
             @a_a3FD
             (\ (m_a551 :: GHC.Maybe.Maybe a_a3FD) (y_a552 :: a_a3FD) ->
                GHC.Maybe.Just
                  @a_a3FD
                  (case m_a551 of {
                     GHC.Maybe.Nothing -> y_a552;
                     GHC.Maybe.Just x_a555 -> f_a54Z x_a555 y_a552
                   }))
             (GHC.Maybe.Nothing @a_a3FD)
             xs_a550
      of {
        GHC.Maybe.Nothing ->
          errorWithoutStackTrace
            @GHC.Types.LiftedRep
            @a_a3FD
            (GHC.Base.build
               @Char
               (\ (@b_a558) ->
                  GHC.CString.unpackFoldrCString#
                    @b_a558 "foldl1: empty structure"#));
        GHC.Maybe.Just v_a559 -> v_a559
      }

-- RHS size: {terms: 27, types: 26, coercions: 0, joins: 0/0}
$cfoldr1_a3Fq [Occ=LoopBreaker]
  :: forall a. (a -> a -> a) -> NonEmpty a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0] 260 0}]
$cfoldr1_a3Fq
  = \ (@a_a3Ft)
      (f_a55f :: a_a3Ft -> a_a3Ft -> a_a3Ft)
      (xs_a55g :: NonEmpty a_a3Ft) ->
      case foldr
             @NonEmpty
             Main.$fFoldableNonEmpty
             @a_a3Ft
             @(GHC.Maybe.Maybe a_a3Ft)
             (\ (x_a55h :: a_a3Ft) (m_a55i :: GHC.Maybe.Maybe a_a3Ft) ->
                GHC.Maybe.Just
                  @a_a3Ft
                  (case m_a55i of {
                     GHC.Maybe.Nothing -> x_a55h;
                     GHC.Maybe.Just y_a55l -> f_a55f x_a55h y_a55l
                   }))
             (GHC.Maybe.Nothing @a_a3Ft)
             xs_a55g
      of {
        GHC.Maybe.Nothing ->
          errorWithoutStackTrace
            @GHC.Types.LiftedRep
            @a_a3Ft
            (GHC.Base.build
               @Char
               (\ (@b_a55o) ->
                  GHC.CString.unpackFoldrCString#
                    @b_a55o "foldr1: empty structure"#));
        GHC.Maybe.Just v_a55p -> v_a55p
      }

-- RHS size: {terms: 20, types: 18, coercions: 0, joins: 0/0}
$cfoldl'_a3Fe [Occ=LoopBreaker]
  :: forall b a. (b -> a -> b) -> b -> NonEmpty a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 150 0}]
$cfoldl'_a3Fe
  = \ (@b_a3Fh)
      (@a_a3Fi)
      (f_a55w :: b_a3Fh -> a_a3Fi -> b_a3Fh)
      (z0_a55x :: b_a3Fh)
      (xs_a55y :: NonEmpty a_a3Fi) ->
      foldr
        @NonEmpty
        Main.$fFoldableNonEmpty
        @a_a3Fi
        @(b_a3Fh -> b_a3Fh)
        (\ (ds_a55z :: a_a3Fi)
           (ds1_a55A :: b_a3Fh -> b_a3Fh)
           (v_a55B [OS=OneShot] :: b_a3Fh) ->
           case v_a55B of z_a55C { __DEFAULT ->
           ds1_a55A (f_a55w z_a55C ds_a55z)
           })
        (id @b_a3Fh)
        xs_a55y
        z0_a55x

-- RHS size: {terms: 16, types: 18, coercions: 10, joins: 0/0}
$cfoldl_a3F2 [Occ=LoopBreaker]
  :: forall b a. (b -> a -> b) -> b -> NonEmpty a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 130 0}]
$cfoldl_a3F2
  = \ (@b_a3F5)
      (@a_a3F6)
      (eta_a55I :: b_a3F5 -> a_a3F6 -> b_a3F5)
      (eta1_a55J :: b_a3F5)
      (eta2_a55K :: NonEmpty a_a3F6) ->
      ((foldMap
          @NonEmpty
          Main.$fFoldableNonEmpty
          @(base:Data.Semigroup.Internal.Dual
              (base:Data.Semigroup.Internal.Endo b_a3F5))
          @a_a3F6
          (base:Data.Semigroup.Internal.$fMonoidDual
             @(base:Data.Semigroup.Internal.Endo b_a3F5)
             (base:Data.Semigroup.Internal.$fMonoidEndo @b_a3F5))
          ((\ (x_a55N :: a_a3F6) (y_a55O :: b_a3F5) ->
              eta_a55I y_a55O x_a55N)
           `cast` (<a_a3F6>_R
                   %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Dual[0]
                                            (base:Data.Semigroup.Internal.N:Endo[0] <b_a3F5>_R))
                   :: (a_a3F6 -> b_a3F5 -> b_a3F5)
                      ~R# (a_a3F6
                           -> base:Data.Semigroup.Internal.Dual
                                (base:Data.Semigroup.Internal.Endo b_a3F5))))
          eta2_a55K)
       `cast` (base:Data.Semigroup.Internal.N:Dual[0]
                   (base:Data.Semigroup.Internal.N:Endo[0] <b_a3F5>_R)
               :: base:Data.Semigroup.Internal.Dual
                    (base:Data.Semigroup.Internal.Endo b_a3F5)
                  ~R# (b_a3F5 -> b_a3F5)))
        eta1_a55J

-- RHS size: {terms: 20, types: 18, coercions: 0, joins: 0/0}
$cfoldr'_a3EQ [Occ=LoopBreaker]
  :: forall a b. (a -> b -> b) -> b -> NonEmpty a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 150 0}]
$cfoldr'_a3EQ
  = \ (@a_a3ET)
      (@b_a3EU)
      (f_a55X :: a_a3ET -> b_a3EU -> b_a3EU)
      (z0_a55Y :: b_a3EU)
      (xs_a55Z :: NonEmpty a_a3ET) ->
      foldl
        @NonEmpty
        Main.$fFoldableNonEmpty
        @(b_a3EU -> b_a3EU)
        @a_a3ET
        (\ (ds_a560 :: b_a3EU -> b_a3EU)
           (ds1_a561 :: a_a3ET)
           (v_a562 [OS=OneShot] :: b_a3EU) ->
           case v_a562 of z_a563 { __DEFAULT ->
           ds_a560 (f_a55X ds1_a561 z_a563)
           })
        (id @b_a3EU)
        xs_a55Z
        z0_a55Y

-- RHS size: {terms: 19, types: 17, coercions: 0, joins: 0/0}
$cfoldr_a3Es [Occ=LoopBreaker]
  :: forall a b. (a -> b -> b) -> b -> NonEmpty a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 60] 130 0}]
$cfoldr_a3Es
  = \ (@a_a3Ev)
      (@b_a3Ew)
      (f_a2fa :: a_a3Ev -> b_a3Ew -> b_a3Ew)
      (z_a2fb :: b_a3Ew)
      (ds_d4RK :: NonEmpty a_a3Ev) ->
      case ds_d4RK of {
        Last a1_a2fc -> f_a2fa a1_a2fc z_a2fb;
        NECons a1_a2ff a2_a2fg ->
          f_a2fa
            a1_a2ff
            (foldr
               @NonEmpty
               Main.$fFoldableNonEmpty
               @a_a3Ev
               @b_a3Ew
               f_a2fa
               z_a2fb
               a2_a2fg)
      }

-- RHS size: {terms: 18, types: 16, coercions: 0, joins: 0/1}
$cfoldMap'_a3Ee [Occ=LoopBreaker]
  :: forall m a. Monoid m => (a -> m) -> NonEmpty a -> m
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 60] 170 0}]
$cfoldMap'_a3Ee
  = \ (@m_a3Eh)
      (@a_a3Ei)
      ($dMonoid_a3Ej :: Monoid m_a3Eh)
      (eta_a569 :: a_a3Ei -> m_a3Eh) ->
      let {
        $dSemigroup_a56a :: Semigroup m_a3Eh
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dSemigroup_a56a = GHC.Base.$p1Monoid @m_a3Eh $dMonoid_a3Ej } in
      Data.Foldable.foldl'
        @NonEmpty
        Main.$fFoldableNonEmpty
        @m_a3Eh
        @a_a3Ei
        (\ (acc_a56b :: m_a3Eh) (a1_a56c :: a_a3Ei) ->
           <> @m_a3Eh $dSemigroup_a56a acc_a56b (eta_a569 a1_a56c))
        (mempty @m_a3Eh $dMonoid_a3Ej)

-- RHS size: {terms: 20, types: 18, coercions: 0, joins: 0/0}
$cfoldMap_a3DW [Occ=LoopBreaker]
  :: forall m a. Monoid m => (a -> m) -> NonEmpty a -> m
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 60 50] 150 0}]
$cfoldMap_a3DW
  = \ (@m_a3DZ)
      (@a_a3E0)
      ($dMonoid_a3E1 :: Monoid m_a3DZ)
      (f_a2fj :: a_a3E0 -> m_a3DZ)
      (ds_d4RJ :: NonEmpty a_a3E0) ->
      case ds_d4RJ of {
        Last a1_a2fk -> f_a2fj a1_a2fk;
        NECons a1_a2fm a2_a2fn ->
          mappend
            @m_a3DZ
            $dMonoid_a3E1
            (f_a2fj a1_a2fm)
            (foldMap
               @NonEmpty
               Main.$fFoldableNonEmpty
               @m_a3DZ
               @a_a3E0
               $dMonoid_a3E1
               f_a2fj
               a2_a2fn)
      }

-- RHS size: {terms: 14, types: 18, coercions: 25, joins: 0/0}
$cproduct_a3GY [Occ=LoopBreaker]
  :: forall a. Num a => NonEmpty a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 120 60}]
$cproduct_a3GY
  = \ (@a_a3H1) ($dNum_a3H2 :: Num a_a3H1) ->
      ((\ (@(t_a56d :: * -> *))
          ($dFoldable_a56e :: Foldable t_a56d)
          (@a_a56f)
          ($dNum_a56g :: Num a_a56f) ->
          Data.Foldable.foldMap'
            @t_a56d
            $dFoldable_a56e
            @(base:Data.Semigroup.Internal.Product a_a56f)
            @a_a56f
            (base:Data.Semigroup.Internal.$fMonoidProduct @a_a56f $dNum_a56g)
            ((\ (ds_a56i :: a_a56f) -> ds_a56i)
             `cast` (<a_a56f>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Product[0]
                                              <a_a56f>_R)
                     :: (a_a56f -> a_a56f)
                        ~R# (a_a56f -> base:Data.Semigroup.Internal.Product a_a56f))))
       `cast` (forall (t :: <* -> *>_N).
               <Foldable t>_R
               %<'Many>_N ->_R forall (a :: <*>_N).
                               <Num a>_R
                               %<'Many>_N ->_R <t a>_R
                               %<'Many>_N ->_R base:Data.Semigroup.Internal.N:Product[0] <a>_R
               :: (forall {t :: * -> *} {a}.
                   (Foldable t, Num a) =>
                   t a -> base:Data.Semigroup.Internal.Product a)
                  ~R# (forall {t :: * -> *} {a}. (Foldable t, Num a) => t a -> a)))
        @NonEmpty Main.$fFoldableNonEmpty @a_a3H1 $dNum_a3H2

-- RHS size: {terms: 6, types: 7, coercions: 0, joins: 0/0}
$cfold_a3DK [Occ=LoopBreaker]
  :: forall m. Monoid m => NonEmpty m -> m
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 40 0}]
$cfold_a3DK
  = \ (@m_a3DN) ($dMonoid_a3DO :: Monoid m_a3DN) ->
      foldMap
        @NonEmpty
        Main.$fFoldableNonEmpty
        @m_a3DN
        @m_a3DN
        $dMonoid_a3DO
        (id @m_a3DN)
end Rec }

Rec {
-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Main.$fFunctorNonEmpty [InlPrag=CONLIKE] :: Functor NonEmpty
[LclIdX[DFunId],
 Unf=DFun: \ ->
       GHC.Base.C:Functor TYPE: NonEmpty $cfmap_a3D5 $c<$_a3Do]
Main.$fFunctorNonEmpty
  = GHC.Base.C:Functor @NonEmpty $cfmap_a3D5 $c<$_a3Do

-- RHS size: {terms: 16, types: 16, coercions: 0, joins: 0/0}
$c<$_a3Do [Occ=LoopBreaker]
  :: forall a b. a -> NonEmpty b -> NonEmpty a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 40] 80 20}]
$c<$_a3Do
  = \ (@a_a3Dr)
      (@b_a3Ds)
      (z_a2f5 :: a_a3Dr)
      (ds_d4RF :: NonEmpty b_a3Ds) ->
      case ds_d4RF of {
        Last _ [Occ=Dead] -> Main.Last @a_a3Dr z_a2f5;
        NECons _ [Occ=Dead] a2_a2f9 ->
          Main.NECons
            @a_a3Dr
            z_a2f5
            (<$
               @NonEmpty Main.$fFunctorNonEmpty @a_a3Dr @b_a3Ds z_a2f5 a2_a2f9)
      }

-- RHS size: {terms: 18, types: 17, coercions: 0, joins: 0/0}
$cfmap_a3D5 [Occ=LoopBreaker]
  :: forall a b. (a -> b) -> NonEmpty a -> NonEmpty b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 60] 120 20}]
$cfmap_a3D5
  = \ (@a_a3D8)
      (@b_a3D9)
      (f_a2f0 :: a_a3D8 -> b_a3D9)
      (ds_d4RB :: NonEmpty a_a3D8) ->
      case ds_d4RB of {
        Last a1_a2f1 -> Main.Last @b_a3D9 (f_a2f0 a1_a2f1);
        NECons a1_a2f3 a2_a2f4 ->
          Main.NECons
            @b_a3D9
            (f_a2f0 a1_a2f3)
            (fmap
               @NonEmpty Main.$fFunctorNonEmpty @a_a3D8 @b_a3D9 f_a2f0 a2_a2f4)
      }
end Rec }

Rec {
-- RHS size: {terms: 7, types: 1, coercions: 0, joins: 0/0}
Main.$fTraversableNonEmpty [InlPrag=CONLIKE]
  :: Traversable NonEmpty
[LclIdX[DFunId],
 Unf=DFun: \ ->
       Data.Traversable.C:Traversable TYPE: NonEmpty
                                      Main.$fFunctorNonEmpty
                                      Main.$fFoldableNonEmpty
                                      $ctraverse_a4jO
                                      $csequenceA_a4k4
                                      $cmapM_a4ki
                                      $csequence_a4ky]
Main.$fTraversableNonEmpty
  = Data.Traversable.C:Traversable
      @NonEmpty
      Main.$fFunctorNonEmpty
      Main.$fFoldableNonEmpty
      $ctraverse_a4jO
      $csequenceA_a4k4
      $cmapM_a4ki
      $csequence_a4ky

-- RHS size: {terms: 8, types: 11, coercions: 0, joins: 0/0}
$cmapM_a4ki [Occ=LoopBreaker]
  :: forall (m :: * -> *) a b.
     Monad m =>
     (a -> m b) -> NonEmpty a -> m (NonEmpty b)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30] 50 0}]
$cmapM_a4ki
  = \ (@(m_a4kl :: * -> *))
      (@a_a4km)
      (@b_a4kn)
      ($dMonad_a4ko :: Monad m_a4kl) ->
      traverse
        @NonEmpty
        Main.$fTraversableNonEmpty
        @m_a4kl
        @a_a4km
        @b_a4kn
        (GHC.Base.$p1Monad @m_a4kl $dMonad_a4ko)

-- RHS size: {terms: 7, types: 12, coercions: 0, joins: 0/0}
$csequenceA_a4k4 [Occ=LoopBreaker]
  :: forall (f :: * -> *) a.
     Applicative f =>
     NonEmpty (f a) -> f (NonEmpty a)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 40 0}]
$csequenceA_a4k4
  = \ (@(f_a4k7 :: * -> *))
      (@a_a4k8)
      ($dApplicative_a4k9 :: Applicative f_a4k7) ->
      traverse
        @NonEmpty
        Main.$fTraversableNonEmpty
        @f_a4k7
        @(f_a4k7 a_a4k8)
        @a_a4k8
        $dApplicative_a4k9
        (id @(f_a4k7 a_a4k8))

-- RHS size: {terms: 7, types: 9, coercions: 0, joins: 0/0}
$csequence_a4ky [Occ=LoopBreaker]
  :: forall (m :: * -> *) a.
     Monad m =>
     NonEmpty (m a) -> m (NonEmpty a)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30] 50 0}]
$csequence_a4ky
  = \ (@(m_a4kB :: * -> *))
      (@a_a4kC)
      ($dMonad_a4kD :: Monad m_a4kB) ->
      sequenceA
        @NonEmpty
        Main.$fTraversableNonEmpty
        @m_a4kB
        @a_a4kC
        (GHC.Base.$p1Monad @m_a4kB $dMonad_a4kD)

-- RHS size: {terms: 18, types: 30, coercions: 0, joins: 0/2}
$ctraverse_a4jO [Occ=LoopBreaker]
  :: forall (f :: * -> *) a b.
     Applicative f =>
     (a -> f b) -> NonEmpty a -> f (NonEmpty b)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 150 60}]
$ctraverse_a4jO
  = \ (@(f_a4jR :: * -> *))
      (@a_a4jS)
      (@b_a4jT)
      ($dApplicative_a4jU :: Applicative f_a4jR)
      (eta1_a56N :: a_a4jS -> f_a4jR b_a4jT) ->
      let {
        f1_a56O :: NonEmpty (f_a4jR b_a4jT) -> f_a4jR (NonEmpty b_a4jT)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 30 0}]
        f1_a56O
          = sequenceA
              @NonEmpty
              Main.$fTraversableNonEmpty
              @f_a4jR
              @b_a4jT
              $dApplicative_a4jU } in
      let {
        g_a56P :: NonEmpty a_a4jS -> NonEmpty (f_a4jR b_a4jT)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 50 0}]
        g_a56P
          = fmap
              @NonEmpty
              (Data.Traversable.$p1Traversable
                 @NonEmpty Main.$fTraversableNonEmpty)
              @a_a4jS
              @(f_a4jR b_a4jT)
              eta1_a56N } in
      \ (x_a56Q :: NonEmpty a_a4jS) -> f1_a56O (g_a56P x_a56Q)
end Rec }

Rec {
-- RHS size: {terms: 9, types: 8, coercions: 0, joins: 0/0}
Main.$fShowNonEmpty [InlPrag=CONLIKE]
  :: forall a. Show a => Show (NonEmpty a)
[LclIdX[DFunId],
 Unf=DFun: \ (@a_a1yz) (v_B1 :: Show a_a1yz) ->
       GHC.Show.C:Show TYPE: NonEmpty a_a1yz
                       $cshowsPrec_a3Cl @a_a1yz v_B1
                       $cshow_a3CO @a_a1yz v_B1
                       $cshowList_a3CV @a_a1yz v_B1]
Main.$fShowNonEmpty
  = \ (@a_a3Ci) ($dShow_a3Cj :: Show a_a3Ci) ->
      GHC.Show.C:Show
        @(NonEmpty a_a3Ci)
        ($cshowsPrec_a3Cl @a_a3Ci $dShow_a3Cj)
        ($cshow_a3CO @a_a3Ci $dShow_a3Cj)
        ($cshowList_a3CV @a_a3Ci $dShow_a3Cj)

-- RHS size: {terms: 12, types: 12, coercions: 0, joins: 0/1}
$cshow_a3CO [Occ=LoopBreaker]
  :: forall a. Show a => NonEmpty a -> String
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 100 60}]
$cshow_a3CO
  = \ (@a_a3Ci) ($dShow_a3Cj :: Show a_a3Ci) ->
      let {
        $dShow_a56X :: Show (NonEmpty a_a3Ci)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dShow_a56X = Main.$fShowNonEmpty @a_a3Ci $dShow_a3Cj } in
      \ (x_a56Y :: NonEmpty a_a3Ci) ->
        showsPrec
          @(NonEmpty a_a3Ci)
          $dShow_a56X
          (GHC.Types.I# 0#)
          x_a56Y
          (GHC.Types.[] @Char)

-- RHS size: {terms: 14, types: 15, coercions: 0, joins: 0/1}
$cshowList_a3CV [Occ=LoopBreaker]
  :: forall a. Show a => [NonEmpty a] -> ShowS
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 130 60}]
$cshowList_a3CV
  = \ (@a_a3Ci) ($dShow_a3Cj :: Show a_a3Ci) ->
      let {
        $dShow_a56S :: Show (NonEmpty a_a3Ci)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dShow_a56S = Main.$fShowNonEmpty @a_a3Ci $dShow_a3Cj } in
      \ (ls_a56T :: [NonEmpty a_a3Ci]) (s_a56U :: String) ->
        GHC.Show.showList__
          @(NonEmpty a_a3Ci)
          (showsPrec @(NonEmpty a_a3Ci) $dShow_a56S (GHC.Types.I# 0#))
          ls_a56T
          s_a56U

-- RHS size: {terms: 49, types: 34, coercions: 0, joins: 0/1}
$cshowsPrec_a3Cl [Occ=LoopBreaker]
  :: forall a. Show a => Int -> NonEmpty a -> ShowS
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60] 640 60}]
$cshowsPrec_a3Cl
  = \ (@a_a3Ci) ($dShow_a3Cj :: Show a_a3Ci) ->
      let {
        $dShow_a3CM :: Show (NonEmpty a_a3Ci)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dShow_a3CM = Main.$fShowNonEmpty @a_a3Ci $dShow_a3Cj } in
      \ (a_a2eV :: Int) (ds_d4Rw :: NonEmpty a_a3Ci) ->
        case ds_d4Rw of {
          Last b1_a2eW ->
            showParen
              (>= @Int GHC.Classes.$fOrdInt a_a2eV (GHC.Types.I# 11#))
              (. @String
                 @String
                 @String
                 (showString (GHC.CString.unpackCString# "Last "#))
                 (showsPrec @a_a3Ci $dShow_a3Cj (GHC.Types.I# 11#) b1_a2eW));
          NECons b1_a2eY b2_a2eZ ->
            showParen
              (>= @Int GHC.Classes.$fOrdInt a_a2eV (GHC.Types.I# 11#))
              (. @String
                 @String
                 @String
                 (showString (GHC.CString.unpackCString# "NECons "#))
                 (. @String
                    @String
                    @String
                    (showsPrec @a_a3Ci $dShow_a3Cj (GHC.Types.I# 11#) b1_a2eY)
                    (. @String
                       @String
                       @String
                       GHC.Show.showSpace
                       (showsPrec
                          @(NonEmpty a_a3Ci) $dShow_a3CM (GHC.Types.I# 11#) b2_a2eZ))))
        }
end Rec }

Rec {
-- RHS size: {terms: 7, types: 7, coercions: 0, joins: 0/0}
Main.$fEqNonEmpty [InlPrag=CONLIKE]
  :: forall a. Eq a => Eq (NonEmpty a)
[LclIdX[DFunId],
 Unf=DFun: \ (@a_a1yt) (v_B1 :: Eq a_a1yt) ->
       GHC.Classes.C:Eq TYPE: NonEmpty a_a1yt
                        $c==_a3BG @a_a1yt v_B1
                        $c/=_a3C9 @a_a1yt v_B1]
Main.$fEqNonEmpty
  = \ (@a_a3BD) ($dEq_a3BE :: Eq a_a3BD) ->
      GHC.Classes.C:Eq
        @(NonEmpty a_a3BD)
        ($c==_a3BG @a_a3BD $dEq_a3BE)
        ($c/=_a3C9 @a_a3BD $dEq_a3BE)

-- RHS size: {terms: 16, types: 14, coercions: 0, joins: 0/1}
$c/=_a3C9 [Occ=LoopBreaker]
  :: forall a. Eq a => NonEmpty a -> NonEmpty a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 110 60}]
$c/=_a3C9
  = \ (@a_a3BD) ($dEq_a3BE :: Eq a_a3BD) ->
      let {
        $dEq_a570 :: Eq (NonEmpty a_a3BD)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dEq_a570 = Main.$fEqNonEmpty @a_a3BD $dEq_a3BE } in
      \ (x_a571 :: NonEmpty a_a3BD) (y_a572 :: NonEmpty a_a3BD) ->
        case == @(NonEmpty a_a3BD) $dEq_a570 x_a571 y_a572 of {
          False -> GHC.Types.True;
          True -> GHC.Types.False
        }

-- RHS size: {terms: 56, types: 43, coercions: 0, joins: 0/1}
$c==_a3BG [Occ=LoopBreaker]
  :: forall a. Eq a => NonEmpty a -> NonEmpty a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60] 473 60}]
$c==_a3BG
  = \ (@a_a3BD) ($dEq_a3BE :: Eq a_a3BD) ->
      let {
        $dEq_a3C7 :: Eq (NonEmpty a_a3BD)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dEq_a3C7 = Main.$fEqNonEmpty @a_a3BD $dEq_a3BE } in
      \ (a_a2eL :: NonEmpty a_a3BD) (b_a2eM :: NonEmpty a_a3BD) ->
        case case GHC.Prim.dataToTag# @(NonEmpty a_a3BD) a_a2eL of a#_a2eN
             { __DEFAULT ->
             case GHC.Prim.dataToTag# @(NonEmpty a_a3BD) b_a2eM of b#_a2eO
             { __DEFAULT ->
             GHC.Prim./=# a#_a2eN b#_a2eO
             }
             }
        of ds_d4Re
        { __DEFAULT ->
        case ds_d4Re of {
          __DEFAULT ->
            case a_a2eL of {
              Last a1_a2eP ->
                case b_a2eM of {
                  __DEFAULT ->
                    case Control.Exception.Base.patError
                           @GHC.Types.LiftedRep @() "Gy08.hs:33:60-61|case"#
                    of {
                    };
                  Last b1_a2eQ -> == @a_a3BD $dEq_a3BE a1_a2eP b1_a2eQ
                };
              NECons a1_a2eR a2_a2eS ->
                case b_a2eM of {
                  __DEFAULT ->
                    case Control.Exception.Base.patError
                           @GHC.Types.LiftedRep @() "Gy08.hs:33:60-61|case"#
                    of {
                    };
                  NECons b1_a2eT b2_a2eU ->
                    &&
                      (== @a_a3BD $dEq_a3BE a1_a2eR b1_a2eT)
                      (== @(NonEmpty a_a3BD) $dEq_a3C7 a2_a2eS b2_a2eU)
                }
            };
          1# -> GHC.Types.False
        }
        }
end Rec }

-- RHS size: {terms: 6, types: 8, coercions: 0, joins: 0/0}
$cnull_a3Am :: forall a. NonEmpty2 a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)}]
$cnull_a3Am
  = \ (@a_a3Ap) (ds_d4R7 :: NonEmpty2 a_a3Ap) ->
      case ds_d4R7 of { NECons2 _ [Occ=Dead] _ [Occ=Dead] ->
      GHC.Types.False
      }

-- RHS size: {terms: 15, types: 16, coercions: 0, joins: 0/0}
$cfoldr_a3yV :: forall a b. (a -> b -> b) -> b -> NonEmpty2 a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 20] 90 0}]
$cfoldr_a3yV
  = \ (@a_a3yY)
      (@b_a3yZ)
      (f_a2eC :: a_a3yY -> b_a3yZ -> b_a3yZ)
      (z_a2eD :: b_a3yZ)
      (ds_d4R6 :: NonEmpty2 a_a3yY) ->
      case ds_d4R6 of { NECons2 a1_a2eE a2_a2eF ->
      f_a2eC
        a1_a2eE
        (foldr
           @List Main.$fFoldableList @a_a3yY @b_a3yZ f_a2eC z_a2eD a2_a2eF)
      }

-- RHS size: {terms: 17, types: 17, coercions: 0, joins: 0/0}
$cfoldMap_a3yq
  :: forall m a. Monoid m => (a -> m) -> NonEmpty2 a -> m
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 60 20] 120 0}]
$cfoldMap_a3yq
  = \ (@m_a3yt)
      (@a_a3yu)
      ($dMonoid_a3yv :: Monoid m_a3yt)
      (f_a2eI :: a_a3yu -> m_a3yt)
      (ds_d4R5 :: NonEmpty2 a_a3yu) ->
      case ds_d4R5 of { NECons2 a1_a2eJ a2_a2eK ->
      mappend
        @m_a3yt
        $dMonoid_a3yv
        (f_a2eI a1_a2eJ)
        (foldMap
           @List
           Main.$fFoldableList
           @m_a3yt
           @a_a3yu
           $dMonoid_a3yv
           f_a2eI
           a2_a2eK)
      }

Rec {
-- RHS size: {terms: 18, types: 1, coercions: 0, joins: 0/0}
Main.$fFoldableNonEmpty2 [InlPrag=CONLIKE] :: Foldable NonEmpty2
[LclIdX[DFunId],
 Unf=DFun: \ ->
       Data.Foldable.C:Foldable TYPE: NonEmpty2
                                $cfold_a3ye
                                $cfoldMap_a3yq
                                $cfoldMap'_a3yH
                                $cfoldr_a3yV
                                $cfoldr'_a3zi
                                $cfoldl_a3zu
                                $cfoldl'_a3zG
                                $cfoldr1_a3zS
                                $cfoldl1_a3A2
                                $ctoList_a3Ac
                                $cnull_a3Am
                                $clength_a3At
                                $celem_a3AD
                                $cmaximum_a3AP
                                $cminimum_a3B1
                                $csum_a3Bd
                                $cproduct_a3Bp]
Main.$fFoldableNonEmpty2
  = Data.Foldable.C:Foldable
      @NonEmpty2
      $cfold_a3ye
      $cfoldMap_a3yq
      $cfoldMap'_a3yH
      $cfoldr_a3yV
      $cfoldr'_a3zi
      $cfoldl_a3zu
      $cfoldl'_a3zG
      $cfoldr1_a3zS
      $cfoldl1_a3A2
      $ctoList_a3Ac
      $cnull_a3Am
      $clength_a3At
      $celem_a3AD
      $cmaximum_a3AP
      $cminimum_a3B1
      $csum_a3Bd
      $cproduct_a3Bp

-- RHS size: {terms: 14, types: 18, coercions: 25, joins: 0/0}
$csum_a3Bd [Occ=LoopBreaker] :: forall a. Num a => NonEmpty2 a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 120 60}]
$csum_a3Bd
  = \ (@a_a3Bg) ($dNum_a3Bh :: Num a_a3Bg) ->
      ((\ (@(t_a4WR :: * -> *))
          ($dFoldable_a4WS :: Foldable t_a4WR)
          (@a_a4WT)
          ($dNum_a4WU :: Num a_a4WT) ->
          Data.Foldable.foldMap'
            @t_a4WR
            $dFoldable_a4WS
            @(base:Data.Semigroup.Internal.Sum a_a4WT)
            @a_a4WT
            (base:Data.Semigroup.Internal.$fMonoidSum @a_a4WT $dNum_a4WU)
            ((\ (ds_a52f :: a_a4WT) -> ds_a52f)
             `cast` (<a_a4WT>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Sum[0]
                                              <a_a4WT>_R)
                     :: (a_a4WT -> a_a4WT)
                        ~R# (a_a4WT -> base:Data.Semigroup.Internal.Sum a_a4WT))))
       `cast` (forall (t :: <* -> *>_N).
               <Foldable t>_R
               %<'Many>_N ->_R forall (a :: <*>_N).
                               <Num a>_R
                               %<'Many>_N ->_R <t a>_R
                               %<'Many>_N ->_R base:Data.Semigroup.Internal.N:Sum[0] <a>_R
               :: (forall {t :: * -> *} {a}.
                   (Foldable t, Num a) =>
                   t a -> base:Data.Semigroup.Internal.Sum a)
                  ~R# (forall {t :: * -> *} {a}. (Foldable t, Num a) => t a -> a)))
        @NonEmpty2 Main.$fFoldableNonEmpty2 @a_a3Bg $dNum_a3Bh

-- RHS size: {terms: 24, types: 25, coercions: 8, joins: 0/2}
$cminimum_a3B1 [Occ=LoopBreaker]
  :: forall a. Ord a => NonEmpty2 a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 260 60}]
$cminimum_a3B1
  = \ (@a_a3B4) ($dOrd_a3B5 :: Ord a_a3B4) ->
      let {
        d_a52o :: a_a3B4
        [LclId,
         Str=b,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 110 0}]
        d_a52o
          = errorWithoutStackTrace
              @GHC.Types.LiftedRep
              @a_a3B4
              (GHC.Base.build
                 @Char
                 (\ (@b_a52t) ->
                    GHC.CString.unpackFoldrCString#
                      @b_a52t "minimum: empty structure"#)) } in
      let {
        g_a52v :: NonEmpty2 a_a3B4 -> base:Data.Functor.Utils.Min a_a3B4
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 80 0}]
        g_a52v
          = Data.Foldable.foldMap'
              @NonEmpty2
              Main.$fFoldableNonEmpty2
              @(base:Data.Functor.Utils.Min a_a3B4)
              @a_a3B4
              (base:Data.Functor.Utils.$fMonoidMin @a_a3B4 $dOrd_a3B5)
              ((\ (ds_a53M :: a_a3B4) -> GHC.Maybe.Just @a_a3B4 ds_a53M)
               `cast` (<a_a3B4>_R
                       %<'Many>_N ->_R Sym (base:Data.Functor.Utils.N:Min[0]) <a_a3B4>_N
                       :: (a_a3B4 -> GHC.Maybe.Maybe a_a3B4)
                          ~R# (a_a3B4 -> base:Data.Functor.Utils.Min a_a3B4))) } in
      \ (x_a53N :: NonEmpty2 a_a3B4) ->
        case (g_a52v x_a53N)
             `cast` (base:Data.Functor.Utils.N:Min[0] <a_a3B4>_N
                     :: base:Data.Functor.Utils.Min a_a3B4 ~R# GHC.Maybe.Maybe a_a3B4)
        of {
          GHC.Maybe.Nothing -> d_a52o;
          GHC.Maybe.Just v_a54h -> v_a54h
        }

-- RHS size: {terms: 24, types: 25, coercions: 8, joins: 0/2}
$cmaximum_a3AP [Occ=LoopBreaker]
  :: forall a. Ord a => NonEmpty2 a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 260 60}]
$cmaximum_a3AP
  = \ (@a_a3AS) ($dOrd_a3AT :: Ord a_a3AS) ->
      let {
        d_a54n :: a_a3AS
        [LclId,
         Str=b,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 110 0}]
        d_a54n
          = errorWithoutStackTrace
              @GHC.Types.LiftedRep
              @a_a3AS
              (GHC.Base.build
                 @Char
                 (\ (@b_a54o) ->
                    GHC.CString.unpackFoldrCString#
                      @b_a54o "maximum: empty structure"#)) } in
      let {
        g_a54p :: NonEmpty2 a_a3AS -> base:Data.Functor.Utils.Max a_a3AS
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 80 0}]
        g_a54p
          = Data.Foldable.foldMap'
              @NonEmpty2
              Main.$fFoldableNonEmpty2
              @(base:Data.Functor.Utils.Max a_a3AS)
              @a_a3AS
              (base:Data.Functor.Utils.$fMonoidMax @a_a3AS $dOrd_a3AT)
              ((\ (ds_a54r :: a_a3AS) -> GHC.Maybe.Just @a_a3AS ds_a54r)
               `cast` (<a_a3AS>_R
                       %<'Many>_N ->_R Sym (base:Data.Functor.Utils.N:Max[0]) <a_a3AS>_N
                       :: (a_a3AS -> GHC.Maybe.Maybe a_a3AS)
                          ~R# (a_a3AS -> base:Data.Functor.Utils.Max a_a3AS))) } in
      \ (x_a54s :: NonEmpty2 a_a3AS) ->
        case (g_a54p x_a54s)
             `cast` (base:Data.Functor.Utils.N:Max[0] <a_a3AS>_N
                     :: base:Data.Functor.Utils.Max a_a3AS ~R# GHC.Maybe.Maybe a_a3AS)
        of {
          GHC.Maybe.Nothing -> d_a54n;
          GHC.Maybe.Just v_a54x -> v_a54x
        }

-- RHS size: {terms: 15, types: 17, coercions: 26, joins: 0/0}
$celem_a3AD [Occ=LoopBreaker]
  :: forall a. Eq a => a -> NonEmpty2 a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 130 60}]
$celem_a3AD
  = \ (@a_a3AG) ($dEq_a3AH :: Eq a_a3AG) ->
      ((\ (@(t_a54z :: * -> *))
          ($dFoldable_a54A :: Foldable t_a54z)
          (@a_a54B)
          ($dEq_a54C :: Eq a_a54B)
          (eta_a54D :: a_a54B) ->
          foldMap
            @t_a54z
            $dFoldable_a54A
            @base:Data.Semigroup.Internal.Any
            @a_a54B
            base:Data.Semigroup.Internal.$fMonoidAny
            ((== @a_a54B $dEq_a54C eta_a54D)
             `cast` (<a_a54B>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Any[0])
                     :: (a_a54B -> Bool)
                        ~R# (a_a54B -> base:Data.Semigroup.Internal.Any))))
       `cast` (forall (t :: <* -> *>_N).
               <Foldable t>_R
               %<'Many>_N ->_R forall (a :: <*>_N).
                               <Eq a>_R
                               %<'Many>_N ->_R <a>_R
                               %<'Many>_N ->_R <t a>_R
                               %<'Many>_N ->_R base:Data.Semigroup.Internal.N:Any[0]
               :: (forall {t :: * -> *} {a}.
                   (Foldable t, Eq a) =>
                   a -> t a -> base:Data.Semigroup.Internal.Any)
                  ~R# (forall {t :: * -> *} {a}.
                       (Foldable t, Eq a) =>
                       a -> t a -> Bool)))
        @NonEmpty2 Main.$fFoldableNonEmpty2 @a_a3AG $dEq_a3AH

-- RHS size: {terms: 14, types: 8, coercions: 0, joins: 0/0}
$clength_a3At [Occ=LoopBreaker] :: forall a. NonEmpty2 a -> Int
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=False, ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 91 0}]
$clength_a3At
  = \ (@a_a3Aw) ->
      Data.Foldable.foldl'
        @NonEmpty2
        Main.$fFoldableNonEmpty2
        @Int
        @a_a3Aw
        (\ (c_a54K :: Int) _ [Occ=Dead] ->
           case c_a54K of { GHC.Types.I# x_a54N ->
           GHC.Types.I# (GHC.Prim.+# x_a54N 1#)
           })
        (GHC.Types.I# 0#)

-- RHS size: {terms: 11, types: 12, coercions: 0, joins: 0/0}
$ctoList_a3Ac [Occ=LoopBreaker] :: forall a. NonEmpty2 a -> [a]
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 70 40}]
$ctoList_a3Ac
  = \ (@a_a3Af) (t1_a54S :: NonEmpty2 a_a3Af) ->
      GHC.Base.build
        @a_a3Af
        (\ (@b_a54T)
           (c_a54U [OS=OneShot] :: a_a3Af -> b_a54T -> b_a54T)
           (n_a54V [OS=OneShot] :: b_a54T) ->
           foldr
             @NonEmpty2
             Main.$fFoldableNonEmpty2
             @a_a3Af
             @b_a54T
             c_a54U
             n_a54V
             t1_a54S)

-- RHS size: {terms: 27, types: 26, coercions: 0, joins: 0/0}
$cfoldl1_a3A2 [Occ=LoopBreaker]
  :: forall a. (a -> a -> a) -> NonEmpty2 a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0] 260 0}]
$cfoldl1_a3A2
  = \ (@a_a3A5)
      (f_a54Z :: a_a3A5 -> a_a3A5 -> a_a3A5)
      (xs_a550 :: NonEmpty2 a_a3A5) ->
      case foldl
             @NonEmpty2
             Main.$fFoldableNonEmpty2
             @(GHC.Maybe.Maybe a_a3A5)
             @a_a3A5
             (\ (m_a551 :: GHC.Maybe.Maybe a_a3A5) (y_a552 :: a_a3A5) ->
                GHC.Maybe.Just
                  @a_a3A5
                  (case m_a551 of {
                     GHC.Maybe.Nothing -> y_a552;
                     GHC.Maybe.Just x_a555 -> f_a54Z x_a555 y_a552
                   }))
             (GHC.Maybe.Nothing @a_a3A5)
             xs_a550
      of {
        GHC.Maybe.Nothing ->
          errorWithoutStackTrace
            @GHC.Types.LiftedRep
            @a_a3A5
            (GHC.Base.build
               @Char
               (\ (@b_a558) ->
                  GHC.CString.unpackFoldrCString#
                    @b_a558 "foldl1: empty structure"#));
        GHC.Maybe.Just v_a559 -> v_a559
      }

-- RHS size: {terms: 27, types: 26, coercions: 0, joins: 0/0}
$cfoldr1_a3zS [Occ=LoopBreaker]
  :: forall a. (a -> a -> a) -> NonEmpty2 a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0] 260 0}]
$cfoldr1_a3zS
  = \ (@a_a3zV)
      (f_a55f :: a_a3zV -> a_a3zV -> a_a3zV)
      (xs_a55g :: NonEmpty2 a_a3zV) ->
      case foldr
             @NonEmpty2
             Main.$fFoldableNonEmpty2
             @a_a3zV
             @(GHC.Maybe.Maybe a_a3zV)
             (\ (x_a55h :: a_a3zV) (m_a55i :: GHC.Maybe.Maybe a_a3zV) ->
                GHC.Maybe.Just
                  @a_a3zV
                  (case m_a55i of {
                     GHC.Maybe.Nothing -> x_a55h;
                     GHC.Maybe.Just y_a55l -> f_a55f x_a55h y_a55l
                   }))
             (GHC.Maybe.Nothing @a_a3zV)
             xs_a55g
      of {
        GHC.Maybe.Nothing ->
          errorWithoutStackTrace
            @GHC.Types.LiftedRep
            @a_a3zV
            (GHC.Base.build
               @Char
               (\ (@b_a55o) ->
                  GHC.CString.unpackFoldrCString#
                    @b_a55o "foldr1: empty structure"#));
        GHC.Maybe.Just v_a55p -> v_a55p
      }

-- RHS size: {terms: 20, types: 18, coercions: 0, joins: 0/0}
$cfoldl'_a3zG [Occ=LoopBreaker]
  :: forall b a. (b -> a -> b) -> b -> NonEmpty2 a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 150 0}]
$cfoldl'_a3zG
  = \ (@b_a3zJ)
      (@a_a3zK)
      (f_a55w :: b_a3zJ -> a_a3zK -> b_a3zJ)
      (z0_a55x :: b_a3zJ)
      (xs_a55y :: NonEmpty2 a_a3zK) ->
      foldr
        @NonEmpty2
        Main.$fFoldableNonEmpty2
        @a_a3zK
        @(b_a3zJ -> b_a3zJ)
        (\ (ds_a55z :: a_a3zK)
           (ds1_a55A :: b_a3zJ -> b_a3zJ)
           (v_a55B [OS=OneShot] :: b_a3zJ) ->
           case v_a55B of z_a55C { __DEFAULT ->
           ds1_a55A (f_a55w z_a55C ds_a55z)
           })
        (id @b_a3zJ)
        xs_a55y
        z0_a55x

-- RHS size: {terms: 16, types: 18, coercions: 10, joins: 0/0}
$cfoldl_a3zu [Occ=LoopBreaker]
  :: forall b a. (b -> a -> b) -> b -> NonEmpty2 a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 130 0}]
$cfoldl_a3zu
  = \ (@b_a3zx)
      (@a_a3zy)
      (eta_a55I :: b_a3zx -> a_a3zy -> b_a3zx)
      (eta1_a55J :: b_a3zx)
      (eta2_a55K :: NonEmpty2 a_a3zy) ->
      ((foldMap
          @NonEmpty2
          Main.$fFoldableNonEmpty2
          @(base:Data.Semigroup.Internal.Dual
              (base:Data.Semigroup.Internal.Endo b_a3zx))
          @a_a3zy
          (base:Data.Semigroup.Internal.$fMonoidDual
             @(base:Data.Semigroup.Internal.Endo b_a3zx)
             (base:Data.Semigroup.Internal.$fMonoidEndo @b_a3zx))
          ((\ (x_a55N :: a_a3zy) (y_a55O :: b_a3zx) ->
              eta_a55I y_a55O x_a55N)
           `cast` (<a_a3zy>_R
                   %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Dual[0]
                                            (base:Data.Semigroup.Internal.N:Endo[0] <b_a3zx>_R))
                   :: (a_a3zy -> b_a3zx -> b_a3zx)
                      ~R# (a_a3zy
                           -> base:Data.Semigroup.Internal.Dual
                                (base:Data.Semigroup.Internal.Endo b_a3zx))))
          eta2_a55K)
       `cast` (base:Data.Semigroup.Internal.N:Dual[0]
                   (base:Data.Semigroup.Internal.N:Endo[0] <b_a3zx>_R)
               :: base:Data.Semigroup.Internal.Dual
                    (base:Data.Semigroup.Internal.Endo b_a3zx)
                  ~R# (b_a3zx -> b_a3zx)))
        eta1_a55J

-- RHS size: {terms: 20, types: 18, coercions: 0, joins: 0/0}
$cfoldr'_a3zi [Occ=LoopBreaker]
  :: forall a b. (a -> b -> b) -> b -> NonEmpty2 a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 150 0}]
$cfoldr'_a3zi
  = \ (@a_a3zl)
      (@b_a3zm)
      (f_a55X :: a_a3zl -> b_a3zm -> b_a3zm)
      (z0_a55Y :: b_a3zm)
      (xs_a55Z :: NonEmpty2 a_a3zl) ->
      foldl
        @NonEmpty2
        Main.$fFoldableNonEmpty2
        @(b_a3zm -> b_a3zm)
        @a_a3zl
        (\ (ds_a560 :: b_a3zm -> b_a3zm)
           (ds1_a561 :: a_a3zl)
           (v_a562 [OS=OneShot] :: b_a3zm) ->
           case v_a562 of z_a563 { __DEFAULT ->
           ds_a560 (f_a55X ds1_a561 z_a563)
           })
        (id @b_a3zm)
        xs_a55Z
        z0_a55Y

-- RHS size: {terms: 18, types: 16, coercions: 0, joins: 0/1}
$cfoldMap'_a3yH [Occ=LoopBreaker]
  :: forall m a. Monoid m => (a -> m) -> NonEmpty2 a -> m
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 60] 170 0}]
$cfoldMap'_a3yH
  = \ (@m_a3yK)
      (@a_a3yL)
      ($dMonoid_a3yM :: Monoid m_a3yK)
      (eta_a569 :: a_a3yL -> m_a3yK) ->
      let {
        $dSemigroup_a56a :: Semigroup m_a3yK
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dSemigroup_a56a = GHC.Base.$p1Monoid @m_a3yK $dMonoid_a3yM } in
      Data.Foldable.foldl'
        @NonEmpty2
        Main.$fFoldableNonEmpty2
        @m_a3yK
        @a_a3yL
        (\ (acc_a56b :: m_a3yK) (a1_a56c :: a_a3yL) ->
           <> @m_a3yK $dSemigroup_a56a acc_a56b (eta_a569 a1_a56c))
        (mempty @m_a3yK $dMonoid_a3yM)

-- RHS size: {terms: 14, types: 18, coercions: 25, joins: 0/0}
$cproduct_a3Bp [Occ=LoopBreaker]
  :: forall a. Num a => NonEmpty2 a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 120 60}]
$cproduct_a3Bp
  = \ (@a_a3Bs) ($dNum_a3Bt :: Num a_a3Bs) ->
      ((\ (@(t_a56d :: * -> *))
          ($dFoldable_a56e :: Foldable t_a56d)
          (@a_a56f)
          ($dNum_a56g :: Num a_a56f) ->
          Data.Foldable.foldMap'
            @t_a56d
            $dFoldable_a56e
            @(base:Data.Semigroup.Internal.Product a_a56f)
            @a_a56f
            (base:Data.Semigroup.Internal.$fMonoidProduct @a_a56f $dNum_a56g)
            ((\ (ds_a56i :: a_a56f) -> ds_a56i)
             `cast` (<a_a56f>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Product[0]
                                              <a_a56f>_R)
                     :: (a_a56f -> a_a56f)
                        ~R# (a_a56f -> base:Data.Semigroup.Internal.Product a_a56f))))
       `cast` (forall (t :: <* -> *>_N).
               <Foldable t>_R
               %<'Many>_N ->_R forall (a :: <*>_N).
                               <Num a>_R
                               %<'Many>_N ->_R <t a>_R
                               %<'Many>_N ->_R base:Data.Semigroup.Internal.N:Product[0] <a>_R
               :: (forall {t :: * -> *} {a}.
                   (Foldable t, Num a) =>
                   t a -> base:Data.Semigroup.Internal.Product a)
                  ~R# (forall {t :: * -> *} {a}. (Foldable t, Num a) => t a -> a)))
        @NonEmpty2 Main.$fFoldableNonEmpty2 @a_a3Bs $dNum_a3Bt

-- RHS size: {terms: 6, types: 7, coercions: 0, joins: 0/0}
$cfold_a3ye [Occ=LoopBreaker]
  :: forall m. Monoid m => NonEmpty2 m -> m
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 40 0}]
$cfold_a3ye
  = \ (@m_a3yh) ($dMonoid_a3yi :: Monoid m_a3yh) ->
      foldMap
        @NonEmpty2
        Main.$fFoldableNonEmpty2
        @m_a3yh
        @m_a3yh
        $dMonoid_a3yi
        (id @m_a3yh)
end Rec }

-- RHS size: {terms: 13, types: 14, coercions: 0, joins: 0/0}
$c<$_a3xV :: forall a b. a -> NonEmpty2 b -> NonEmpty2 a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 20] 60 10}]
$c<$_a3xV
  = \ (@a_a3xY)
      (@b_a3xZ)
      (z_a2ez :: a_a3xY)
      (ds_d4R2 :: NonEmpty2 b_a3xZ) ->
      case ds_d4R2 of { NECons2 _ [Occ=Dead] a2_a2eB ->
      Main.NECons2
        @a_a3xY
        z_a2ez
        (<$ @List Main.$fFunctorList @a_a3xY @b_a3xZ z_a2ez a2_a2eB)
      }

-- RHS size: {terms: 14, types: 15, coercions: 0, joins: 0/0}
$cfmap_a3xF :: forall a b. (a -> b) -> NonEmpty2 a -> NonEmpty2 b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 20] 80 10}]
$cfmap_a3xF
  = \ (@a_a3xI)
      (@b_a3xJ)
      (f_a2ew :: a_a3xI -> b_a3xJ)
      (ds_d4QZ :: NonEmpty2 a_a3xI) ->
      case ds_d4QZ of { NECons2 a1_a2ex a2_a2ey ->
      Main.NECons2
        @b_a3xJ
        (f_a2ew a1_a2ex)
        (fmap @List Main.$fFunctorList @a_a3xI @b_a3xJ f_a2ew a2_a2ey)
      }

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Main.$fFunctorNonEmpty2 [InlPrag=CONLIKE] :: Functor NonEmpty2
[LclIdX[DFunId],
 Unf=DFun: \ ->
       GHC.Base.C:Functor TYPE: NonEmpty2 $cfmap_a3xF $c<$_a3xV]
Main.$fFunctorNonEmpty2
  = GHC.Base.C:Functor @NonEmpty2 $cfmap_a3xF $c<$_a3xV

Rec {
-- RHS size: {terms: 7, types: 1, coercions: 0, joins: 0/0}
Main.$fTraversableNonEmpty2 [InlPrag=CONLIKE]
  :: Traversable NonEmpty2
[LclIdX[DFunId],
 Unf=DFun: \ ->
       Data.Traversable.C:Traversable TYPE: NonEmpty2
                                      Main.$fFunctorNonEmpty2
                                      Main.$fFoldableNonEmpty2
                                      $ctraverse_a4iF
                                      $csequenceA_a4iV
                                      $cmapM_a4j9
                                      $csequence_a4jp]
Main.$fTraversableNonEmpty2
  = Data.Traversable.C:Traversable
      @NonEmpty2
      Main.$fFunctorNonEmpty2
      Main.$fFoldableNonEmpty2
      $ctraverse_a4iF
      $csequenceA_a4iV
      $cmapM_a4j9
      $csequence_a4jp

-- RHS size: {terms: 8, types: 11, coercions: 0, joins: 0/0}
$cmapM_a4j9 [Occ=LoopBreaker]
  :: forall (m :: * -> *) a b.
     Monad m =>
     (a -> m b) -> NonEmpty2 a -> m (NonEmpty2 b)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30] 50 0}]
$cmapM_a4j9
  = \ (@(m_a4jc :: * -> *))
      (@a_a4jd)
      (@b_a4je)
      ($dMonad_a4jf :: Monad m_a4jc) ->
      traverse
        @NonEmpty2
        Main.$fTraversableNonEmpty2
        @m_a4jc
        @a_a4jd
        @b_a4je
        (GHC.Base.$p1Monad @m_a4jc $dMonad_a4jf)

-- RHS size: {terms: 7, types: 12, coercions: 0, joins: 0/0}
$csequenceA_a4iV [Occ=LoopBreaker]
  :: forall (f :: * -> *) a.
     Applicative f =>
     NonEmpty2 (f a) -> f (NonEmpty2 a)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 40 0}]
$csequenceA_a4iV
  = \ (@(f_a4iY :: * -> *))
      (@a_a4iZ)
      ($dApplicative_a4j0 :: Applicative f_a4iY) ->
      traverse
        @NonEmpty2
        Main.$fTraversableNonEmpty2
        @f_a4iY
        @(f_a4iY a_a4iZ)
        @a_a4iZ
        $dApplicative_a4j0
        (id @(f_a4iY a_a4iZ))

-- RHS size: {terms: 7, types: 9, coercions: 0, joins: 0/0}
$csequence_a4jp [Occ=LoopBreaker]
  :: forall (m :: * -> *) a.
     Monad m =>
     NonEmpty2 (m a) -> m (NonEmpty2 a)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30] 50 0}]
$csequence_a4jp
  = \ (@(m_a4js :: * -> *))
      (@a_a4jt)
      ($dMonad_a4ju :: Monad m_a4js) ->
      sequenceA
        @NonEmpty2
        Main.$fTraversableNonEmpty2
        @m_a4js
        @a_a4jt
        (GHC.Base.$p1Monad @m_a4js $dMonad_a4ju)

-- RHS size: {terms: 18, types: 30, coercions: 0, joins: 0/2}
$ctraverse_a4iF [Occ=LoopBreaker]
  :: forall (f :: * -> *) a b.
     Applicative f =>
     (a -> f b) -> NonEmpty2 a -> f (NonEmpty2 b)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 150 60}]
$ctraverse_a4iF
  = \ (@(f_a4iI :: * -> *))
      (@a_a4iJ)
      (@b_a4iK)
      ($dApplicative_a4iL :: Applicative f_a4iI)
      (eta1_a56N :: a_a4iJ -> f_a4iI b_a4iK) ->
      let {
        f1_a56O :: NonEmpty2 (f_a4iI b_a4iK) -> f_a4iI (NonEmpty2 b_a4iK)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 30 0}]
        f1_a56O
          = sequenceA
              @NonEmpty2
              Main.$fTraversableNonEmpty2
              @f_a4iI
              @b_a4iK
              $dApplicative_a4iL } in
      let {
        g_a56P :: NonEmpty2 a_a4iJ -> NonEmpty2 (f_a4iI b_a4iK)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 50 0}]
        g_a56P
          = fmap
              @NonEmpty2
              (Data.Traversable.$p1Traversable
                 @NonEmpty2 Main.$fTraversableNonEmpty2)
              @a_a4iJ
              @(f_a4iI b_a4iK)
              eta1_a56N } in
      \ (x_a56Q :: NonEmpty2 a_a4iJ) -> f1_a56O (g_a56P x_a56Q)
end Rec }

-- RHS size: {terms: 33, types: 28, coercions: 0, joins: 0/1}
$cshowsPrec_a3x3 :: forall a. Show a => Int -> NonEmpty2 a -> ShowS
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30] 400 60}]
$cshowsPrec_a3x3
  = \ (@a_a3x0) ($dShow_a3x1 :: Show a_a3x0) ->
      let {
        $dShow_a3xm :: Show (List a_a3x0)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dShow_a3xm = Main.$fShowList @a_a3x0 $dShow_a3x1 } in
      \ (a_a2et :: Int) (ds_d4QU :: NonEmpty2 a_a3x0) ->
        case ds_d4QU of { NECons2 b1_a2eu b2_a2ev ->
        showParen
          (>= @Int GHC.Classes.$fOrdInt a_a2et (GHC.Types.I# 11#))
          (. @String
             @String
             @String
             (showString (GHC.CString.unpackCString# "NECons2 "#))
             (. @String
                @String
                @String
                (showsPrec @a_a3x0 $dShow_a3x1 (GHC.Types.I# 11#) b1_a2eu)
                (. @String
                   @String
                   @String
                   GHC.Show.showSpace
                   (showsPrec
                      @(List a_a3x0) $dShow_a3xm (GHC.Types.I# 11#) b2_a2ev))))
        }

Rec {
-- RHS size: {terms: 9, types: 8, coercions: 0, joins: 0/0}
Main.$fShowNonEmpty2 [InlPrag=CONLIKE]
  :: forall a. Show a => Show (NonEmpty2 a)
[LclIdX[DFunId],
 Unf=DFun: \ (@a_a1yd) (v_B1 :: Show a_a1yd) ->
       GHC.Show.C:Show TYPE: NonEmpty2 a_a1yd
                       $cshowsPrec_a3x3 @a_a1yd v_B1
                       $cshow_a3xo @a_a1yd v_B1
                       $cshowList_a3xv @a_a1yd v_B1]
Main.$fShowNonEmpty2
  = \ (@a_a3x0) ($dShow_a3x1 :: Show a_a3x0) ->
      GHC.Show.C:Show
        @(NonEmpty2 a_a3x0)
        ($cshowsPrec_a3x3 @a_a3x0 $dShow_a3x1)
        ($cshow_a3xo @a_a3x0 $dShow_a3x1)
        ($cshowList_a3xv @a_a3x0 $dShow_a3x1)

-- RHS size: {terms: 14, types: 15, coercions: 0, joins: 0/1}
$cshowList_a3xv [Occ=LoopBreaker]
  :: forall a. Show a => [NonEmpty2 a] -> ShowS
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 130 60}]
$cshowList_a3xv
  = \ (@a_a3x0) ($dShow_a3x1 :: Show a_a3x0) ->
      let {
        $dShow_a56S :: Show (NonEmpty2 a_a3x0)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dShow_a56S = Main.$fShowNonEmpty2 @a_a3x0 $dShow_a3x1 } in
      \ (ls_a56T :: [NonEmpty2 a_a3x0]) (s_a56U :: String) ->
        GHC.Show.showList__
          @(NonEmpty2 a_a3x0)
          (showsPrec @(NonEmpty2 a_a3x0) $dShow_a56S (GHC.Types.I# 0#))
          ls_a56T
          s_a56U

-- RHS size: {terms: 12, types: 12, coercions: 0, joins: 0/1}
$cshow_a3xo [Occ=LoopBreaker]
  :: forall a. Show a => NonEmpty2 a -> String
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 100 60}]
$cshow_a3xo
  = \ (@a_a3x0) ($dShow_a3x1 :: Show a_a3x0) ->
      let {
        $dShow_a56X :: Show (NonEmpty2 a_a3x0)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dShow_a56X = Main.$fShowNonEmpty2 @a_a3x0 $dShow_a3x1 } in
      \ (x_a56Y :: NonEmpty2 a_a3x0) ->
        showsPrec
          @(NonEmpty2 a_a3x0)
          $dShow_a56X
          (GHC.Types.I# 0#)
          x_a56Y
          (GHC.Types.[] @Char)
end Rec }

-- RHS size: {terms: 22, types: 24, coercions: 0, joins: 0/1}
$c==_a3wG :: forall a. Eq a => NonEmpty2 a -> NonEmpty2 a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30] 180 60}]
$c==_a3wG
  = \ (@a_a3wD) ($dEq_a3wE :: Eq a_a3wD) ->
      let {
        $dEq_a3wP :: Eq (List a_a3wD)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dEq_a3wP = Main.$fEqList @a_a3wD $dEq_a3wE } in
      \ (ds_d4QM :: NonEmpty2 a_a3wD) (ds_d4QN :: NonEmpty2 a_a3wD) ->
        case ds_d4QM of { NECons2 a1_a2ep a2_a2eq ->
        case ds_d4QN of { NECons2 b1_a2er b2_a2es ->
        &&
          (== @a_a3wD $dEq_a3wE a1_a2ep b1_a2er)
          (== @(List a_a3wD) $dEq_a3wP a2_a2eq b2_a2es)
        }
        }

Rec {
-- RHS size: {terms: 7, types: 7, coercions: 0, joins: 0/0}
Main.$fEqNonEmpty2 [InlPrag=CONLIKE]
  :: forall a. Eq a => Eq (NonEmpty2 a)
[LclIdX[DFunId],
 Unf=DFun: \ (@a_a1y7) (v_B1 :: Eq a_a1y7) ->
       GHC.Classes.C:Eq TYPE: NonEmpty2 a_a1y7
                        $c==_a3wG @a_a1y7 v_B1
                        $c/=_a3wR @a_a1y7 v_B1]
Main.$fEqNonEmpty2
  = \ (@a_a3wD) ($dEq_a3wE :: Eq a_a3wD) ->
      GHC.Classes.C:Eq
        @(NonEmpty2 a_a3wD)
        ($c==_a3wG @a_a3wD $dEq_a3wE)
        ($c/=_a3wR @a_a3wD $dEq_a3wE)

-- RHS size: {terms: 16, types: 14, coercions: 0, joins: 0/1}
$c/=_a3wR [Occ=LoopBreaker]
  :: forall a. Eq a => NonEmpty2 a -> NonEmpty2 a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 110 60}]
$c/=_a3wR
  = \ (@a_a3wD) ($dEq_a3wE :: Eq a_a3wD) ->
      let {
        $dEq_a570 :: Eq (NonEmpty2 a_a3wD)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dEq_a570 = Main.$fEqNonEmpty2 @a_a3wD $dEq_a3wE } in
      \ (x_a571 :: NonEmpty2 a_a3wD) (y_a572 :: NonEmpty2 a_a3wD) ->
        case == @(NonEmpty2 a_a3wD) $dEq_a570 x_a571 y_a572 of {
          False -> GHC.Types.True;
          True -> GHC.Types.False
        }
end Rec }

-- RHS size: {terms: 8, types: 11, coercions: 0, joins: 0/0}
$cnull_a3vl :: forall a. Tree a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)}]
$cnull_a3vl
  = \ (@a_a3vo) (ds_d4QD :: Tree a_a3vo) ->
      case ds_d4QD of {
        Leaf _ [Occ=Dead] -> GHC.Types.False;
        Node _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.False
      }

Rec {
-- RHS size: {terms: 18, types: 1, coercions: 0, joins: 0/0}
Main.$fFoldableTree [InlPrag=CONLIKE] :: Foldable Tree
[LclIdX[DFunId],
 Unf=DFun: \ ->
       Data.Foldable.C:Foldable TYPE: Tree
                                $cfold_a3sQ
                                $cfoldMap_a3t2
                                $cfoldMap'_a3tr
                                $cfoldr_a3tF
                                $cfoldr'_a3uh
                                $cfoldl_a3ut
                                $cfoldl'_a3uF
                                $cfoldr1_a3uR
                                $cfoldl1_a3v1
                                $ctoList_a3vb
                                $cnull_a3vl
                                $clength_a3vt
                                $celem_a3vD
                                $cmaximum_a3vP
                                $cminimum_a3w1
                                $csum_a3wd
                                $cproduct_a3wp]
Main.$fFoldableTree
  = Data.Foldable.C:Foldable
      @Tree
      $cfold_a3sQ
      $cfoldMap_a3t2
      $cfoldMap'_a3tr
      $cfoldr_a3tF
      $cfoldr'_a3uh
      $cfoldl_a3ut
      $cfoldl'_a3uF
      $cfoldr1_a3uR
      $cfoldl1_a3v1
      $ctoList_a3vb
      $cnull_a3vl
      $clength_a3vt
      $celem_a3vD
      $cmaximum_a3vP
      $cminimum_a3w1
      $csum_a3wd
      $cproduct_a3wp

-- RHS size: {terms: 14, types: 18, coercions: 25, joins: 0/0}
$csum_a3wd [Occ=LoopBreaker] :: forall a. Num a => Tree a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 120 60}]
$csum_a3wd
  = \ (@a_a3wg) ($dNum_a3wh :: Num a_a3wg) ->
      ((\ (@(t_a4WR :: * -> *))
          ($dFoldable_a4WS :: Foldable t_a4WR)
          (@a_a4WT)
          ($dNum_a4WU :: Num a_a4WT) ->
          Data.Foldable.foldMap'
            @t_a4WR
            $dFoldable_a4WS
            @(base:Data.Semigroup.Internal.Sum a_a4WT)
            @a_a4WT
            (base:Data.Semigroup.Internal.$fMonoidSum @a_a4WT $dNum_a4WU)
            ((\ (ds_a52f :: a_a4WT) -> ds_a52f)
             `cast` (<a_a4WT>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Sum[0]
                                              <a_a4WT>_R)
                     :: (a_a4WT -> a_a4WT)
                        ~R# (a_a4WT -> base:Data.Semigroup.Internal.Sum a_a4WT))))
       `cast` (forall (t :: <* -> *>_N).
               <Foldable t>_R
               %<'Many>_N ->_R forall (a :: <*>_N).
                               <Num a>_R
                               %<'Many>_N ->_R <t a>_R
                               %<'Many>_N ->_R base:Data.Semigroup.Internal.N:Sum[0] <a>_R
               :: (forall {t :: * -> *} {a}.
                   (Foldable t, Num a) =>
                   t a -> base:Data.Semigroup.Internal.Sum a)
                  ~R# (forall {t :: * -> *} {a}. (Foldable t, Num a) => t a -> a)))
        @Tree Main.$fFoldableTree @a_a3wg $dNum_a3wh

-- RHS size: {terms: 24, types: 25, coercions: 8, joins: 0/2}
$cminimum_a3w1 [Occ=LoopBreaker] :: forall a. Ord a => Tree a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 260 60}]
$cminimum_a3w1
  = \ (@a_a3w4) ($dOrd_a3w5 :: Ord a_a3w4) ->
      let {
        d_a52o :: a_a3w4
        [LclId,
         Str=b,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 110 0}]
        d_a52o
          = errorWithoutStackTrace
              @GHC.Types.LiftedRep
              @a_a3w4
              (GHC.Base.build
                 @Char
                 (\ (@b_a52t) ->
                    GHC.CString.unpackFoldrCString#
                      @b_a52t "minimum: empty structure"#)) } in
      let {
        g_a52v :: Tree a_a3w4 -> base:Data.Functor.Utils.Min a_a3w4
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 80 0}]
        g_a52v
          = Data.Foldable.foldMap'
              @Tree
              Main.$fFoldableTree
              @(base:Data.Functor.Utils.Min a_a3w4)
              @a_a3w4
              (base:Data.Functor.Utils.$fMonoidMin @a_a3w4 $dOrd_a3w5)
              ((\ (ds_a53M :: a_a3w4) -> GHC.Maybe.Just @a_a3w4 ds_a53M)
               `cast` (<a_a3w4>_R
                       %<'Many>_N ->_R Sym (base:Data.Functor.Utils.N:Min[0]) <a_a3w4>_N
                       :: (a_a3w4 -> GHC.Maybe.Maybe a_a3w4)
                          ~R# (a_a3w4 -> base:Data.Functor.Utils.Min a_a3w4))) } in
      \ (x_a53N :: Tree a_a3w4) ->
        case (g_a52v x_a53N)
             `cast` (base:Data.Functor.Utils.N:Min[0] <a_a3w4>_N
                     :: base:Data.Functor.Utils.Min a_a3w4 ~R# GHC.Maybe.Maybe a_a3w4)
        of {
          GHC.Maybe.Nothing -> d_a52o;
          GHC.Maybe.Just v_a54h -> v_a54h
        }

-- RHS size: {terms: 24, types: 25, coercions: 8, joins: 0/2}
$cmaximum_a3vP [Occ=LoopBreaker] :: forall a. Ord a => Tree a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 260 60}]
$cmaximum_a3vP
  = \ (@a_a3vS) ($dOrd_a3vT :: Ord a_a3vS) ->
      let {
        d_a54n :: a_a3vS
        [LclId,
         Str=b,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 110 0}]
        d_a54n
          = errorWithoutStackTrace
              @GHC.Types.LiftedRep
              @a_a3vS
              (GHC.Base.build
                 @Char
                 (\ (@b_a54o) ->
                    GHC.CString.unpackFoldrCString#
                      @b_a54o "maximum: empty structure"#)) } in
      let {
        g_a54p :: Tree a_a3vS -> base:Data.Functor.Utils.Max a_a3vS
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 80 0}]
        g_a54p
          = Data.Foldable.foldMap'
              @Tree
              Main.$fFoldableTree
              @(base:Data.Functor.Utils.Max a_a3vS)
              @a_a3vS
              (base:Data.Functor.Utils.$fMonoidMax @a_a3vS $dOrd_a3vT)
              ((\ (ds_a54r :: a_a3vS) -> GHC.Maybe.Just @a_a3vS ds_a54r)
               `cast` (<a_a3vS>_R
                       %<'Many>_N ->_R Sym (base:Data.Functor.Utils.N:Max[0]) <a_a3vS>_N
                       :: (a_a3vS -> GHC.Maybe.Maybe a_a3vS)
                          ~R# (a_a3vS -> base:Data.Functor.Utils.Max a_a3vS))) } in
      \ (x_a54s :: Tree a_a3vS) ->
        case (g_a54p x_a54s)
             `cast` (base:Data.Functor.Utils.N:Max[0] <a_a3vS>_N
                     :: base:Data.Functor.Utils.Max a_a3vS ~R# GHC.Maybe.Maybe a_a3vS)
        of {
          GHC.Maybe.Nothing -> d_a54n;
          GHC.Maybe.Just v_a54x -> v_a54x
        }

-- RHS size: {terms: 15, types: 17, coercions: 26, joins: 0/0}
$celem_a3vD [Occ=LoopBreaker]
  :: forall a. Eq a => a -> Tree a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 130 60}]
$celem_a3vD
  = \ (@a_a3vG) ($dEq_a3vH :: Eq a_a3vG) ->
      ((\ (@(t_a54z :: * -> *))
          ($dFoldable_a54A :: Foldable t_a54z)
          (@a_a54B)
          ($dEq_a54C :: Eq a_a54B)
          (eta_a54D :: a_a54B) ->
          foldMap
            @t_a54z
            $dFoldable_a54A
            @base:Data.Semigroup.Internal.Any
            @a_a54B
            base:Data.Semigroup.Internal.$fMonoidAny
            ((== @a_a54B $dEq_a54C eta_a54D)
             `cast` (<a_a54B>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Any[0])
                     :: (a_a54B -> Bool)
                        ~R# (a_a54B -> base:Data.Semigroup.Internal.Any))))
       `cast` (forall (t :: <* -> *>_N).
               <Foldable t>_R
               %<'Many>_N ->_R forall (a :: <*>_N).
                               <Eq a>_R
                               %<'Many>_N ->_R <a>_R
                               %<'Many>_N ->_R <t a>_R
                               %<'Many>_N ->_R base:Data.Semigroup.Internal.N:Any[0]
               :: (forall {t :: * -> *} {a}.
                   (Foldable t, Eq a) =>
                   a -> t a -> base:Data.Semigroup.Internal.Any)
                  ~R# (forall {t :: * -> *} {a}.
                       (Foldable t, Eq a) =>
                       a -> t a -> Bool)))
        @Tree Main.$fFoldableTree @a_a3vG $dEq_a3vH

-- RHS size: {terms: 14, types: 8, coercions: 0, joins: 0/0}
$clength_a3vt [Occ=LoopBreaker] :: forall a. Tree a -> Int
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=False, ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 91 0}]
$clength_a3vt
  = \ (@a_a3vw) ->
      Data.Foldable.foldl'
        @Tree
        Main.$fFoldableTree
        @Int
        @a_a3vw
        (\ (c_a54K :: Int) _ [Occ=Dead] ->
           case c_a54K of { GHC.Types.I# x_a54N ->
           GHC.Types.I# (GHC.Prim.+# x_a54N 1#)
           })
        (GHC.Types.I# 0#)

-- RHS size: {terms: 11, types: 12, coercions: 0, joins: 0/0}
$ctoList_a3vb [Occ=LoopBreaker] :: forall a. Tree a -> [a]
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 70 40}]
$ctoList_a3vb
  = \ (@a_a3ve) (t1_a54S :: Tree a_a3ve) ->
      GHC.Base.build
        @a_a3ve
        (\ (@b_a54T)
           (c_a54U [OS=OneShot] :: a_a3ve -> b_a54T -> b_a54T)
           (n_a54V [OS=OneShot] :: b_a54T) ->
           foldr
             @Tree Main.$fFoldableTree @a_a3ve @b_a54T c_a54U n_a54V t1_a54S)

-- RHS size: {terms: 27, types: 26, coercions: 0, joins: 0/0}
$cfoldl1_a3v1 [Occ=LoopBreaker]
  :: forall a. (a -> a -> a) -> Tree a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0] 260 0}]
$cfoldl1_a3v1
  = \ (@a_a3v4)
      (f_a54Z :: a_a3v4 -> a_a3v4 -> a_a3v4)
      (xs_a550 :: Tree a_a3v4) ->
      case foldl
             @Tree
             Main.$fFoldableTree
             @(GHC.Maybe.Maybe a_a3v4)
             @a_a3v4
             (\ (m_a551 :: GHC.Maybe.Maybe a_a3v4) (y_a552 :: a_a3v4) ->
                GHC.Maybe.Just
                  @a_a3v4
                  (case m_a551 of {
                     GHC.Maybe.Nothing -> y_a552;
                     GHC.Maybe.Just x_a555 -> f_a54Z x_a555 y_a552
                   }))
             (GHC.Maybe.Nothing @a_a3v4)
             xs_a550
      of {
        GHC.Maybe.Nothing ->
          errorWithoutStackTrace
            @GHC.Types.LiftedRep
            @a_a3v4
            (GHC.Base.build
               @Char
               (\ (@b_a558) ->
                  GHC.CString.unpackFoldrCString#
                    @b_a558 "foldl1: empty structure"#));
        GHC.Maybe.Just v_a559 -> v_a559
      }

-- RHS size: {terms: 27, types: 26, coercions: 0, joins: 0/0}
$cfoldr1_a3uR [Occ=LoopBreaker]
  :: forall a. (a -> a -> a) -> Tree a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0] 260 0}]
$cfoldr1_a3uR
  = \ (@a_a3uU)
      (f_a55f :: a_a3uU -> a_a3uU -> a_a3uU)
      (xs_a55g :: Tree a_a3uU) ->
      case foldr
             @Tree
             Main.$fFoldableTree
             @a_a3uU
             @(GHC.Maybe.Maybe a_a3uU)
             (\ (x_a55h :: a_a3uU) (m_a55i :: GHC.Maybe.Maybe a_a3uU) ->
                GHC.Maybe.Just
                  @a_a3uU
                  (case m_a55i of {
                     GHC.Maybe.Nothing -> x_a55h;
                     GHC.Maybe.Just y_a55l -> f_a55f x_a55h y_a55l
                   }))
             (GHC.Maybe.Nothing @a_a3uU)
             xs_a55g
      of {
        GHC.Maybe.Nothing ->
          errorWithoutStackTrace
            @GHC.Types.LiftedRep
            @a_a3uU
            (GHC.Base.build
               @Char
               (\ (@b_a55o) ->
                  GHC.CString.unpackFoldrCString#
                    @b_a55o "foldr1: empty structure"#));
        GHC.Maybe.Just v_a55p -> v_a55p
      }

-- RHS size: {terms: 20, types: 18, coercions: 0, joins: 0/0}
$cfoldl'_a3uF [Occ=LoopBreaker]
  :: forall b a. (b -> a -> b) -> b -> Tree a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 150 0}]
$cfoldl'_a3uF
  = \ (@b_a3uI)
      (@a_a3uJ)
      (f_a55w :: b_a3uI -> a_a3uJ -> b_a3uI)
      (z0_a55x :: b_a3uI)
      (xs_a55y :: Tree a_a3uJ) ->
      foldr
        @Tree
        Main.$fFoldableTree
        @a_a3uJ
        @(b_a3uI -> b_a3uI)
        (\ (ds_a55z :: a_a3uJ)
           (ds1_a55A :: b_a3uI -> b_a3uI)
           (v_a55B [OS=OneShot] :: b_a3uI) ->
           case v_a55B of z_a55C { __DEFAULT ->
           ds1_a55A (f_a55w z_a55C ds_a55z)
           })
        (id @b_a3uI)
        xs_a55y
        z0_a55x

-- RHS size: {terms: 16, types: 18, coercions: 10, joins: 0/0}
$cfoldl_a3ut [Occ=LoopBreaker]
  :: forall b a. (b -> a -> b) -> b -> Tree a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 130 0}]
$cfoldl_a3ut
  = \ (@b_a3uw)
      (@a_a3ux)
      (eta_a55I :: b_a3uw -> a_a3ux -> b_a3uw)
      (eta1_a55J :: b_a3uw)
      (eta2_a55K :: Tree a_a3ux) ->
      ((foldMap
          @Tree
          Main.$fFoldableTree
          @(base:Data.Semigroup.Internal.Dual
              (base:Data.Semigroup.Internal.Endo b_a3uw))
          @a_a3ux
          (base:Data.Semigroup.Internal.$fMonoidDual
             @(base:Data.Semigroup.Internal.Endo b_a3uw)
             (base:Data.Semigroup.Internal.$fMonoidEndo @b_a3uw))
          ((\ (x_a55N :: a_a3ux) (y_a55O :: b_a3uw) ->
              eta_a55I y_a55O x_a55N)
           `cast` (<a_a3ux>_R
                   %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Dual[0]
                                            (base:Data.Semigroup.Internal.N:Endo[0] <b_a3uw>_R))
                   :: (a_a3ux -> b_a3uw -> b_a3uw)
                      ~R# (a_a3ux
                           -> base:Data.Semigroup.Internal.Dual
                                (base:Data.Semigroup.Internal.Endo b_a3uw))))
          eta2_a55K)
       `cast` (base:Data.Semigroup.Internal.N:Dual[0]
                   (base:Data.Semigroup.Internal.N:Endo[0] <b_a3uw>_R)
               :: base:Data.Semigroup.Internal.Dual
                    (base:Data.Semigroup.Internal.Endo b_a3uw)
                  ~R# (b_a3uw -> b_a3uw)))
        eta1_a55J

-- RHS size: {terms: 20, types: 18, coercions: 0, joins: 0/0}
$cfoldr'_a3uh [Occ=LoopBreaker]
  :: forall a b. (a -> b -> b) -> b -> Tree a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 150 0}]
$cfoldr'_a3uh
  = \ (@a_a3uk)
      (@b_a3ul)
      (f_a55X :: a_a3uk -> b_a3ul -> b_a3ul)
      (z0_a55Y :: b_a3ul)
      (xs_a55Z :: Tree a_a3uk) ->
      foldl
        @Tree
        Main.$fFoldableTree
        @(b_a3ul -> b_a3ul)
        @a_a3uk
        (\ (ds_a560 :: b_a3ul -> b_a3ul)
           (ds1_a561 :: a_a3uk)
           (v_a562 [OS=OneShot] :: b_a3ul) ->
           case v_a562 of z_a563 { __DEFAULT ->
           ds_a560 (f_a55X ds1_a561 z_a563)
           })
        (id @b_a3ul)
        xs_a55Z
        z0_a55Y

-- RHS size: {terms: 23, types: 22, coercions: 0, joins: 0/0}
$cfoldr_a3tF [Occ=LoopBreaker]
  :: forall a b. (a -> b -> b) -> b -> Tree a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 60] 180 0}]
$cfoldr_a3tF
  = \ (@a_a3tI)
      (@b_a3tJ)
      (f_a2e7 :: a_a3tI -> b_a3tJ -> b_a3tJ)
      (z_a2e8 :: b_a3tJ)
      (ds_d4QC :: Tree a_a3tI) ->
      case ds_d4QC of {
        Leaf a1_a2e9 -> f_a2e7 a1_a2e9 z_a2e8;
        Node a1_a2ec a2_a2ed a3_a2ee ->
          foldr
            @Tree
            Main.$fFoldableTree
            @a_a3tI
            @b_a3tJ
            f_a2e7
            (f_a2e7
               a2_a2ed
               (foldr
                  @Tree Main.$fFoldableTree @a_a3tI @b_a3tJ f_a2e7 z_a2e8 a3_a2ee))
            a1_a2ec
      }

-- RHS size: {terms: 18, types: 16, coercions: 0, joins: 0/1}
$cfoldMap'_a3tr [Occ=LoopBreaker]
  :: forall m a. Monoid m => (a -> m) -> Tree a -> m
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 60] 170 0}]
$cfoldMap'_a3tr
  = \ (@m_a3tu)
      (@a_a3tv)
      ($dMonoid_a3tw :: Monoid m_a3tu)
      (eta_a569 :: a_a3tv -> m_a3tu) ->
      let {
        $dSemigroup_a56a :: Semigroup m_a3tu
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dSemigroup_a56a = GHC.Base.$p1Monoid @m_a3tu $dMonoid_a3tw } in
      Data.Foldable.foldl'
        @Tree
        Main.$fFoldableTree
        @m_a3tu
        @a_a3tv
        (\ (acc_a56b :: m_a3tu) (a1_a56c :: a_a3tv) ->
           <> @m_a3tu $dSemigroup_a56a acc_a56b (eta_a569 a1_a56c))
        (mempty @m_a3tu $dMonoid_a3tw)

-- RHS size: {terms: 27, types: 24, coercions: 0, joins: 0/0}
$cfoldMap_a3t2 [Occ=LoopBreaker]
  :: forall m a. Monoid m => (a -> m) -> Tree a -> m
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 60 50] 240 0}]
$cfoldMap_a3t2
  = \ (@m_a3t5)
      (@a_a3t6)
      ($dMonoid_a3t7 :: Monoid m_a3t5)
      (f_a2ej :: a_a3t6 -> m_a3t5)
      (ds_d4QB :: Tree a_a3t6) ->
      case ds_d4QB of {
        Leaf a1_a2ek -> f_a2ej a1_a2ek;
        Node a1_a2em a2_a2en a3_a2eo ->
          mappend
            @m_a3t5
            $dMonoid_a3t7
            (foldMap
               @Tree
               Main.$fFoldableTree
               @m_a3t5
               @a_a3t6
               $dMonoid_a3t7
               f_a2ej
               a1_a2em)
            (mappend
               @m_a3t5
               $dMonoid_a3t7
               (f_a2ej a2_a2en)
               (foldMap
                  @Tree
                  Main.$fFoldableTree
                  @m_a3t5
                  @a_a3t6
                  $dMonoid_a3t7
                  f_a2ej
                  a3_a2eo))
      }

-- RHS size: {terms: 14, types: 18, coercions: 25, joins: 0/0}
$cproduct_a3wp [Occ=LoopBreaker] :: forall a. Num a => Tree a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 120 60}]
$cproduct_a3wp
  = \ (@a_a3ws) ($dNum_a3wt :: Num a_a3ws) ->
      ((\ (@(t_a56d :: * -> *))
          ($dFoldable_a56e :: Foldable t_a56d)
          (@a_a56f)
          ($dNum_a56g :: Num a_a56f) ->
          Data.Foldable.foldMap'
            @t_a56d
            $dFoldable_a56e
            @(base:Data.Semigroup.Internal.Product a_a56f)
            @a_a56f
            (base:Data.Semigroup.Internal.$fMonoidProduct @a_a56f $dNum_a56g)
            ((\ (ds_a56i :: a_a56f) -> ds_a56i)
             `cast` (<a_a56f>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Product[0]
                                              <a_a56f>_R)
                     :: (a_a56f -> a_a56f)
                        ~R# (a_a56f -> base:Data.Semigroup.Internal.Product a_a56f))))
       `cast` (forall (t :: <* -> *>_N).
               <Foldable t>_R
               %<'Many>_N ->_R forall (a :: <*>_N).
                               <Num a>_R
                               %<'Many>_N ->_R <t a>_R
                               %<'Many>_N ->_R base:Data.Semigroup.Internal.N:Product[0] <a>_R
               :: (forall {t :: * -> *} {a}.
                   (Foldable t, Num a) =>
                   t a -> base:Data.Semigroup.Internal.Product a)
                  ~R# (forall {t :: * -> *} {a}. (Foldable t, Num a) => t a -> a)))
        @Tree Main.$fFoldableTree @a_a3ws $dNum_a3wt

-- RHS size: {terms: 6, types: 7, coercions: 0, joins: 0/0}
$cfold_a3sQ [Occ=LoopBreaker] :: forall m. Monoid m => Tree m -> m
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 40 0}]
$cfold_a3sQ
  = \ (@m_a3sT) ($dMonoid_a3sU :: Monoid m_a3sT) ->
      foldMap
        @Tree
        Main.$fFoldableTree
        @m_a3sT
        @m_a3sT
        $dMonoid_a3sU
        (id @m_a3sT)
end Rec }

Rec {
-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Main.$fFunctorTree [InlPrag=CONLIKE] :: Functor Tree
[LclIdX[DFunId],
 Unf=DFun: \ -> GHC.Base.C:Functor TYPE: Tree $cfmap_a3s1 $c<$_a3sp]
Main.$fFunctorTree = GHC.Base.C:Functor @Tree $cfmap_a3s1 $c<$_a3sp

-- RHS size: {terms: 20, types: 21, coercions: 0, joins: 0/0}
$c<$_a3sp [Occ=LoopBreaker] :: forall a b. a -> Tree b -> Tree a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 40] 120 20}]
$c<$_a3sp
  = \ (@a_a3ss)
      (@b_a3st)
      (z_a2e1 :: a_a3ss)
      (ds_d4Qw :: Tree b_a3st) ->
      case ds_d4Qw of {
        Leaf _ [Occ=Dead] -> Main.Leaf @a_a3ss z_a2e1;
        Node a1_a2e4 _ [Occ=Dead] a3_a2e6 ->
          Main.Node
            @a_a3ss
            (<$ @Tree Main.$fFunctorTree @a_a3ss @b_a3st z_a2e1 a1_a2e4)
            z_a2e1
            (<$ @Tree Main.$fFunctorTree @a_a3ss @b_a3st z_a2e1 a3_a2e6)
      }

-- RHS size: {terms: 22, types: 22, coercions: 0, joins: 0/0}
$cfmap_a3s1 [Occ=LoopBreaker]
  :: forall a b. (a -> b) -> Tree a -> Tree b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 60] 160 20}]
$cfmap_a3s1
  = \ (@a_a3s4)
      (@b_a3s5)
      (f_a2dV :: a_a3s4 -> b_a3s5)
      (ds_d4Qr :: Tree a_a3s4) ->
      case ds_d4Qr of {
        Leaf a1_a2dW -> Main.Leaf @b_a3s5 (f_a2dV a1_a2dW);
        Node a1_a2dY a2_a2dZ a3_a2e0 ->
          Main.Node
            @b_a3s5
            (fmap @Tree Main.$fFunctorTree @a_a3s4 @b_a3s5 f_a2dV a1_a2dY)
            (f_a2dV a2_a2dZ)
            (fmap @Tree Main.$fFunctorTree @a_a3s4 @b_a3s5 f_a2dV a3_a2e0)
      }
end Rec }

Rec {
-- RHS size: {terms: 7, types: 1, coercions: 0, joins: 0/0}
Main.$fTraversableTree [InlPrag=CONLIKE] :: Traversable Tree
[LclIdX[DFunId],
 Unf=DFun: \ ->
       Data.Traversable.C:Traversable TYPE: Tree
                                      Main.$fFunctorTree
                                      Main.$fFoldableTree
                                      $ctraverse_a4hw
                                      $csequenceA_a4hM
                                      $cmapM_a4i0
                                      $csequence_a4ig]
Main.$fTraversableTree
  = Data.Traversable.C:Traversable
      @Tree
      Main.$fFunctorTree
      Main.$fFoldableTree
      $ctraverse_a4hw
      $csequenceA_a4hM
      $cmapM_a4i0
      $csequence_a4ig

-- RHS size: {terms: 8, types: 11, coercions: 0, joins: 0/0}
$cmapM_a4i0 [Occ=LoopBreaker]
  :: forall (m :: * -> *) a b.
     Monad m =>
     (a -> m b) -> Tree a -> m (Tree b)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30] 50 0}]
$cmapM_a4i0
  = \ (@(m_a4i3 :: * -> *))
      (@a_a4i4)
      (@b_a4i5)
      ($dMonad_a4i6 :: Monad m_a4i3) ->
      traverse
        @Tree
        Main.$fTraversableTree
        @m_a4i3
        @a_a4i4
        @b_a4i5
        (GHC.Base.$p1Monad @m_a4i3 $dMonad_a4i6)

-- RHS size: {terms: 7, types: 12, coercions: 0, joins: 0/0}
$csequenceA_a4hM [Occ=LoopBreaker]
  :: forall (f :: * -> *) a.
     Applicative f =>
     Tree (f a) -> f (Tree a)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 40 0}]
$csequenceA_a4hM
  = \ (@(f_a4hP :: * -> *))
      (@a_a4hQ)
      ($dApplicative_a4hR :: Applicative f_a4hP) ->
      traverse
        @Tree
        Main.$fTraversableTree
        @f_a4hP
        @(f_a4hP a_a4hQ)
        @a_a4hQ
        $dApplicative_a4hR
        (id @(f_a4hP a_a4hQ))

-- RHS size: {terms: 7, types: 9, coercions: 0, joins: 0/0}
$csequence_a4ig [Occ=LoopBreaker]
  :: forall (m :: * -> *) a. Monad m => Tree (m a) -> m (Tree a)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30] 50 0}]
$csequence_a4ig
  = \ (@(m_a4ij :: * -> *))
      (@a_a4ik)
      ($dMonad_a4il :: Monad m_a4ij) ->
      sequenceA
        @Tree
        Main.$fTraversableTree
        @m_a4ij
        @a_a4ik
        (GHC.Base.$p1Monad @m_a4ij $dMonad_a4il)

-- RHS size: {terms: 18, types: 30, coercions: 0, joins: 0/2}
$ctraverse_a4hw [Occ=LoopBreaker]
  :: forall (f :: * -> *) a b.
     Applicative f =>
     (a -> f b) -> Tree a -> f (Tree b)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 150 60}]
$ctraverse_a4hw
  = \ (@(f_a4hz :: * -> *))
      (@a_a4hA)
      (@b_a4hB)
      ($dApplicative_a4hC :: Applicative f_a4hz)
      (eta1_a56N :: a_a4hA -> f_a4hz b_a4hB) ->
      let {
        f1_a56O :: Tree (f_a4hz b_a4hB) -> f_a4hz (Tree b_a4hB)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 30 0}]
        f1_a56O
          = sequenceA
              @Tree
              Main.$fTraversableTree
              @f_a4hz
              @b_a4hB
              $dApplicative_a4hC } in
      let {
        g_a56P :: Tree a_a4hA -> Tree (f_a4hz b_a4hB)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 50 0}]
        g_a56P
          = fmap
              @Tree
              (Data.Traversable.$p1Traversable @Tree Main.$fTraversableTree)
              @a_a4hA
              @(f_a4hz b_a4hB)
              eta1_a56N } in
      \ (x_a56Q :: Tree a_a4hA) -> f1_a56O (g_a56P x_a56Q)
end Rec }

Rec {
-- RHS size: {terms: 9, types: 8, coercions: 0, joins: 0/0}
Main.$fShowTree [InlPrag=CONLIKE]
  :: forall a. Show a => Show (Tree a)
[LclIdX[DFunId],
 Unf=DFun: \ (@a_a1xR) (v_B1 :: Show a_a1xR) ->
       GHC.Show.C:Show TYPE: Tree a_a1xR
                       $cshowsPrec_a3r9 @a_a1xR v_B1
                       $cshow_a3rK @a_a1xR v_B1
                       $cshowList_a3rR @a_a1xR v_B1]
Main.$fShowTree
  = \ (@a_a3r6) ($dShow_a3r7 :: Show a_a3r6) ->
      GHC.Show.C:Show
        @(Tree a_a3r6)
        ($cshowsPrec_a3r9 @a_a3r6 $dShow_a3r7)
        ($cshow_a3rK @a_a3r6 $dShow_a3r7)
        ($cshowList_a3rR @a_a3r6 $dShow_a3r7)

-- RHS size: {terms: 12, types: 12, coercions: 0, joins: 0/1}
$cshow_a3rK [Occ=LoopBreaker]
  :: forall a. Show a => Tree a -> String
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 100 60}]
$cshow_a3rK
  = \ (@a_a3r6) ($dShow_a3r7 :: Show a_a3r6) ->
      let {
        $dShow_a56X :: Show (Tree a_a3r6)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dShow_a56X = Main.$fShowTree @a_a3r6 $dShow_a3r7 } in
      \ (x_a56Y :: Tree a_a3r6) ->
        showsPrec
          @(Tree a_a3r6)
          $dShow_a56X
          (GHC.Types.I# 0#)
          x_a56Y
          (GHC.Types.[] @Char)

-- RHS size: {terms: 14, types: 15, coercions: 0, joins: 0/1}
$cshowList_a3rR [Occ=LoopBreaker]
  :: forall a. Show a => [Tree a] -> ShowS
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 130 60}]
$cshowList_a3rR
  = \ (@a_a3r6) ($dShow_a3r7 :: Show a_a3r6) ->
      let {
        $dShow_a56S :: Show (Tree a_a3r6)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dShow_a56S = Main.$fShowTree @a_a3r6 $dShow_a3r7 } in
      \ (ls_a56T :: [Tree a_a3r6]) (s_a56U :: String) ->
        GHC.Show.showList__
          @(Tree a_a3r6)
          (showsPrec @(Tree a_a3r6) $dShow_a56S (GHC.Types.I# 0#))
          ls_a56T
          s_a56U

-- RHS size: {terms: 57, types: 44, coercions: 0, joins: 0/1}
$cshowsPrec_a3r9 [Occ=LoopBreaker]
  :: forall a. Show a => Int -> Tree a -> ShowS
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60] 750 60}]
$cshowsPrec_a3r9
  = \ (@a_a3r6) ($dShow_a3r7 :: Show a_a3r6) ->
      let {
        $dShow_a3rv :: Show (Tree a_a3r6)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dShow_a3rv = Main.$fShowTree @a_a3r6 $dShow_a3r7 } in
      \ (a_a2dP :: Int) (ds_d4Qm :: Tree a_a3r6) ->
        case ds_d4Qm of {
          Leaf b1_a2dQ ->
            showParen
              (>= @Int GHC.Classes.$fOrdInt a_a2dP (GHC.Types.I# 11#))
              (. @String
                 @String
                 @String
                 (showString (GHC.CString.unpackCString# "Leaf "#))
                 (showsPrec @a_a3r6 $dShow_a3r7 (GHC.Types.I# 11#) b1_a2dQ));
          Node b1_a2dS b2_a2dT b3_a2dU ->
            showParen
              (>= @Int GHC.Classes.$fOrdInt a_a2dP (GHC.Types.I# 11#))
              (. @String
                 @String
                 @String
                 (showString (GHC.CString.unpackCString# "Node "#))
                 (. @String
                    @String
                    @String
                    (showsPrec @(Tree a_a3r6) $dShow_a3rv (GHC.Types.I# 11#) b1_a2dS)
                    (. @String
                       @String
                       @String
                       GHC.Show.showSpace
                       (. @String
                          @String
                          @String
                          (showsPrec @a_a3r6 $dShow_a3r7 (GHC.Types.I# 11#) b2_a2dT)
                          (. @String
                             @String
                             @String
                             GHC.Show.showSpace
                             (showsPrec
                                @(Tree a_a3r6) $dShow_a3rv (GHC.Types.I# 11#) b3_a2dU))))))
        }
end Rec }

Rec {
-- RHS size: {terms: 7, types: 7, coercions: 0, joins: 0/0}
Main.$fEqTree [InlPrag=CONLIKE] :: forall a. Eq a => Eq (Tree a)
[LclIdX[DFunId],
 Unf=DFun: \ (@a_a1xL) (v_B1 :: Eq a_a1xL) ->
       GHC.Classes.C:Eq TYPE: Tree a_a1xL
                        $c==_a3qs @a_a1xL v_B1
                        $c/=_a3qX @a_a1xL v_B1]
Main.$fEqTree
  = \ (@a_a3qp) ($dEq_a3qq :: Eq a_a3qp) ->
      GHC.Classes.C:Eq
        @(Tree a_a3qp)
        ($c==_a3qs @a_a3qp $dEq_a3qq)
        ($c/=_a3qX @a_a3qp $dEq_a3qq)

-- RHS size: {terms: 16, types: 14, coercions: 0, joins: 0/1}
$c/=_a3qX [Occ=LoopBreaker]
  :: forall a. Eq a => Tree a -> Tree a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 110 60}]
$c/=_a3qX
  = \ (@a_a3qp) ($dEq_a3qq :: Eq a_a3qp) ->
      let {
        $dEq_a570 :: Eq (Tree a_a3qp)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dEq_a570 = Main.$fEqTree @a_a3qp $dEq_a3qq } in
      \ (x_a571 :: Tree a_a3qp) (y_a572 :: Tree a_a3qp) ->
        case == @(Tree a_a3qp) $dEq_a570 x_a571 y_a572 of {
          False -> GHC.Types.True;
          True -> GHC.Types.False
        }

-- RHS size: {terms: 61, types: 49, coercions: 0, joins: 0/1}
$c==_a3qs [Occ=LoopBreaker]
  :: forall a. Eq a => Tree a -> Tree a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60] 543 60}]
$c==_a3qs
  = \ (@a_a3qp) ($dEq_a3qq :: Eq a_a3qp) ->
      let {
        $dEq_a3qR :: Eq (Tree a_a3qp)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dEq_a3qR = Main.$fEqTree @a_a3qp $dEq_a3qq } in
      \ (a_a2dD :: Tree a_a3qp) (b_a2dE :: Tree a_a3qp) ->
        case case GHC.Prim.dataToTag# @(Tree a_a3qp) a_a2dD of a#_a2dF
             { __DEFAULT ->
             case GHC.Prim.dataToTag# @(Tree a_a3qp) b_a2dE of b#_a2dG
             { __DEFAULT ->
             GHC.Prim./=# a#_a2dF b#_a2dG
             }
             }
        of ds_d4Q4
        { __DEFAULT ->
        case ds_d4Q4 of {
          __DEFAULT ->
            case a_a2dD of {
              Leaf a1_a2dH ->
                case b_a2dE of {
                  __DEFAULT ->
                    case Control.Exception.Base.patError
                           @GHC.Types.LiftedRep @() "Gy08.hs:35:59-60|case"#
                    of {
                    };
                  Leaf b1_a2dI -> == @a_a3qp $dEq_a3qq a1_a2dH b1_a2dI
                };
              Node a1_a2dJ a2_a2dK a3_a2dL ->
                case b_a2dE of {
                  __DEFAULT ->
                    case Control.Exception.Base.patError
                           @GHC.Types.LiftedRep @() "Gy08.hs:35:59-60|case"#
                    of {
                    };
                  Node b1_a2dM b2_a2dN b3_a2dO ->
                    &&
                      (== @(Tree a_a3qp) $dEq_a3qR a1_a2dJ b1_a2dM)
                      (&&
                         (== @a_a3qp $dEq_a3qq a2_a2dK b2_a2dN)
                         (== @(Tree a_a3qp) $dEq_a3qR a3_a2dL b3_a2dO))
                }
            };
          1# -> GHC.Types.False
        }
        }
end Rec }

-- RHS size: {terms: 9, types: 10, coercions: 0, joins: 0/0}
$cnull_a3p7 :: forall e a. Either e a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)}]
$cnull_a3p7
  = \ (@e_a3nf) (@a_a3pa) (ds_d4PY :: Either e_a3nf a_a3pa) ->
      case ds_d4PY of {
        Left _ [Occ=Dead] -> GHC.Types.True;
        Right _ [Occ=Dead] -> GHC.Types.False
      }

-- RHS size: {terms: 14, types: 15, coercions: 0, joins: 0/0}
$cfoldr_a3nU :: forall e a b. (a -> b -> b) -> b -> Either e a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 30] 50 0}]
$cfoldr_a3nU
  = \ (@e_a3nf)
      (@a_a3nX)
      (@b_a3nY)
      (f_a2ds :: a_a3nX -> b_a3nY -> b_a3nY)
      (z_a2dt :: b_a3nY)
      (ds_d4PX :: Either e_a3nf a_a3nX) ->
      case ds_d4PX of {
        Left _ [Occ=Dead] -> z_a2dt;
        Right a1_a2dx -> f_a2ds a1_a2dx z_a2dt
      }

-- RHS size: {terms: 14, types: 16, coercions: 0, joins: 0/0}
$cfoldMap_a3nt
  :: forall e m a. Monoid m => (a -> m) -> Either e a -> m
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 60 50] 60 0}]
$cfoldMap_a3nt
  = \ (@e_a3nf)
      (@m_a3nw)
      (@a_a3nx)
      ($dMonoid_a3ny :: Monoid m_a3nw)
      (f_a2dy :: a_a3nx -> m_a3nw)
      (ds_d4PW :: Either e_a3nf a_a3nx) ->
      case ds_d4PW of {
        Left _ [Occ=Dead] -> mempty @m_a3nw $dMonoid_a3ny;
        Right a1_a2dB -> f_a2dy a1_a2dB
      }

Rec {
-- RHS size: {terms: 19, types: 20, coercions: 0, joins: 0/0}
Main.$fFoldableEither [InlPrag=CONLIKE]
  :: forall e. Foldable (Either e)
[LclIdX[DFunId],
 Unf=DFun: \ (@e_a1xF) ->
       Data.Foldable.C:Foldable TYPE: Either e_a1xF
                                $cfold_a3nh @e_a1xF
                                $cfoldMap_a3nt @e_a1xF
                                $cfoldMap'_a3nG @e_a1xF
                                $cfoldr_a3nU @e_a1xF
                                $cfoldr'_a3o3 @e_a1xF
                                $cfoldl_a3of @e_a1xF
                                $cfoldl'_a3or @e_a1xF
                                $cfoldr1_a3oD @e_a1xF
                                $cfoldl1_a3oN @e_a1xF
                                $ctoList_a3oX @e_a1xF
                                $cnull_a3p7 @e_a1xF
                                $clength_a3pf @e_a1xF
                                $celem_a3pp @e_a1xF
                                $cmaximum_a3pB @e_a1xF
                                $cminimum_a3pN @e_a1xF
                                $csum_a3pZ @e_a1xF
                                $cproduct_a3qb @e_a1xF]
Main.$fFoldableEither
  = \ (@e_a3nf) ->
      Data.Foldable.C:Foldable
        @(Either e_a3nf)
        ($cfold_a3nh @e_a3nf)
        ($cfoldMap_a3nt @e_a3nf)
        ($cfoldMap'_a3nG @e_a3nf)
        ($cfoldr_a3nU @e_a3nf)
        ($cfoldr'_a3o3 @e_a3nf)
        ($cfoldl_a3of @e_a3nf)
        ($cfoldl'_a3or @e_a3nf)
        ($cfoldr1_a3oD @e_a3nf)
        ($cfoldl1_a3oN @e_a3nf)
        ($ctoList_a3oX @e_a3nf)
        ($cnull_a3p7 @e_a3nf)
        ($clength_a3pf @e_a3nf)
        ($celem_a3pp @e_a3nf)
        ($cmaximum_a3pB @e_a3nf)
        ($cminimum_a3pN @e_a3nf)
        ($csum_a3pZ @e_a3nf)
        ($cproduct_a3qb @e_a3nf)

-- RHS size: {terms: 15, types: 21, coercions: 25, joins: 0/0}
$csum_a3pZ [Occ=LoopBreaker]
  :: forall e a. Num a => Either e a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 120 60}]
$csum_a3pZ
  = \ (@e_a3nf) (@a_a3q2) ($dNum_a3q3 :: Num a_a3q2) ->
      ((\ (@(t_a4WR :: * -> *))
          ($dFoldable_a4WS :: Foldable t_a4WR)
          (@a_a4WT)
          ($dNum_a4WU :: Num a_a4WT) ->
          Data.Foldable.foldMap'
            @t_a4WR
            $dFoldable_a4WS
            @(base:Data.Semigroup.Internal.Sum a_a4WT)
            @a_a4WT
            (base:Data.Semigroup.Internal.$fMonoidSum @a_a4WT $dNum_a4WU)
            ((\ (ds_a52f :: a_a4WT) -> ds_a52f)
             `cast` (<a_a4WT>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Sum[0]
                                              <a_a4WT>_R)
                     :: (a_a4WT -> a_a4WT)
                        ~R# (a_a4WT -> base:Data.Semigroup.Internal.Sum a_a4WT))))
       `cast` (forall (t :: <* -> *>_N).
               <Foldable t>_R
               %<'Many>_N ->_R forall (a :: <*>_N).
                               <Num a>_R
                               %<'Many>_N ->_R <t a>_R
                               %<'Many>_N ->_R base:Data.Semigroup.Internal.N:Sum[0] <a>_R
               :: (forall {t :: * -> *} {a}.
                   (Foldable t, Num a) =>
                   t a -> base:Data.Semigroup.Internal.Sum a)
                  ~R# (forall {t :: * -> *} {a}. (Foldable t, Num a) => t a -> a)))
        @(Either e_a3nf) (Main.$fFoldableEither @e_a3nf) @a_a3q2 $dNum_a3q3

-- RHS size: {terms: 25, types: 30, coercions: 8, joins: 0/2}
$cminimum_a3pN [Occ=LoopBreaker]
  :: forall e a. Ord a => Either e a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 260 60}]
$cminimum_a3pN
  = \ (@e_a3nf) (@a_a3pQ) ($dOrd_a3pR :: Ord a_a3pQ) ->
      let {
        d_a52o :: a_a3pQ
        [LclId,
         Str=b,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 110 0}]
        d_a52o
          = errorWithoutStackTrace
              @GHC.Types.LiftedRep
              @a_a3pQ
              (GHC.Base.build
                 @Char
                 (\ (@b_a52t) ->
                    GHC.CString.unpackFoldrCString#
                      @b_a52t "minimum: empty structure"#)) } in
      let {
        g_a52v
          :: Either e_a3nf a_a3pQ -> base:Data.Functor.Utils.Min a_a3pQ
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 80 0}]
        g_a52v
          = Data.Foldable.foldMap'
              @(Either e_a3nf)
              (Main.$fFoldableEither @e_a3nf)
              @(base:Data.Functor.Utils.Min a_a3pQ)
              @a_a3pQ
              (base:Data.Functor.Utils.$fMonoidMin @a_a3pQ $dOrd_a3pR)
              ((\ (ds_a53M :: a_a3pQ) -> GHC.Maybe.Just @a_a3pQ ds_a53M)
               `cast` (<a_a3pQ>_R
                       %<'Many>_N ->_R Sym (base:Data.Functor.Utils.N:Min[0]) <a_a3pQ>_N
                       :: (a_a3pQ -> GHC.Maybe.Maybe a_a3pQ)
                          ~R# (a_a3pQ -> base:Data.Functor.Utils.Min a_a3pQ))) } in
      \ (x_a53N :: Either e_a3nf a_a3pQ) ->
        case (g_a52v x_a53N)
             `cast` (base:Data.Functor.Utils.N:Min[0] <a_a3pQ>_N
                     :: base:Data.Functor.Utils.Min a_a3pQ ~R# GHC.Maybe.Maybe a_a3pQ)
        of {
          GHC.Maybe.Nothing -> d_a52o;
          GHC.Maybe.Just v_a54h -> v_a54h
        }

-- RHS size: {terms: 25, types: 30, coercions: 8, joins: 0/2}
$cmaximum_a3pB [Occ=LoopBreaker]
  :: forall e a. Ord a => Either e a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 260 60}]
$cmaximum_a3pB
  = \ (@e_a3nf) (@a_a3pE) ($dOrd_a3pF :: Ord a_a3pE) ->
      let {
        d_a54n :: a_a3pE
        [LclId,
         Str=b,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 110 0}]
        d_a54n
          = errorWithoutStackTrace
              @GHC.Types.LiftedRep
              @a_a3pE
              (GHC.Base.build
                 @Char
                 (\ (@b_a54o) ->
                    GHC.CString.unpackFoldrCString#
                      @b_a54o "maximum: empty structure"#)) } in
      let {
        g_a54p
          :: Either e_a3nf a_a3pE -> base:Data.Functor.Utils.Max a_a3pE
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 80 0}]
        g_a54p
          = Data.Foldable.foldMap'
              @(Either e_a3nf)
              (Main.$fFoldableEither @e_a3nf)
              @(base:Data.Functor.Utils.Max a_a3pE)
              @a_a3pE
              (base:Data.Functor.Utils.$fMonoidMax @a_a3pE $dOrd_a3pF)
              ((\ (ds_a54r :: a_a3pE) -> GHC.Maybe.Just @a_a3pE ds_a54r)
               `cast` (<a_a3pE>_R
                       %<'Many>_N ->_R Sym (base:Data.Functor.Utils.N:Max[0]) <a_a3pE>_N
                       :: (a_a3pE -> GHC.Maybe.Maybe a_a3pE)
                          ~R# (a_a3pE -> base:Data.Functor.Utils.Max a_a3pE))) } in
      \ (x_a54s :: Either e_a3nf a_a3pE) ->
        case (g_a54p x_a54s)
             `cast` (base:Data.Functor.Utils.N:Max[0] <a_a3pE>_N
                     :: base:Data.Functor.Utils.Max a_a3pE ~R# GHC.Maybe.Maybe a_a3pE)
        of {
          GHC.Maybe.Nothing -> d_a54n;
          GHC.Maybe.Just v_a54x -> v_a54x
        }

-- RHS size: {terms: 16, types: 20, coercions: 26, joins: 0/0}
$celem_a3pp [Occ=LoopBreaker]
  :: forall e a. Eq a => a -> Either e a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 130 60}]
$celem_a3pp
  = \ (@e_a3nf) (@a_a3ps) ($dEq_a3pt :: Eq a_a3ps) ->
      ((\ (@(t_a54z :: * -> *))
          ($dFoldable_a54A :: Foldable t_a54z)
          (@a_a54B)
          ($dEq_a54C :: Eq a_a54B)
          (eta_a54D :: a_a54B) ->
          foldMap
            @t_a54z
            $dFoldable_a54A
            @base:Data.Semigroup.Internal.Any
            @a_a54B
            base:Data.Semigroup.Internal.$fMonoidAny
            ((== @a_a54B $dEq_a54C eta_a54D)
             `cast` (<a_a54B>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Any[0])
                     :: (a_a54B -> Bool)
                        ~R# (a_a54B -> base:Data.Semigroup.Internal.Any))))
       `cast` (forall (t :: <* -> *>_N).
               <Foldable t>_R
               %<'Many>_N ->_R forall (a :: <*>_N).
                               <Eq a>_R
                               %<'Many>_N ->_R <a>_R
                               %<'Many>_N ->_R <t a>_R
                               %<'Many>_N ->_R base:Data.Semigroup.Internal.N:Any[0]
               :: (forall {t :: * -> *} {a}.
                   (Foldable t, Eq a) =>
                   a -> t a -> base:Data.Semigroup.Internal.Any)
                  ~R# (forall {t :: * -> *} {a}.
                       (Foldable t, Eq a) =>
                       a -> t a -> Bool)))
        @(Either e_a3nf) (Main.$fFoldableEither @e_a3nf) @a_a3ps $dEq_a3pt

-- RHS size: {terms: 15, types: 11, coercions: 0, joins: 0/0}
$clength_a3pf [Occ=LoopBreaker] :: forall e a. Either e a -> Int
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=False, ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 91 0}]
$clength_a3pf
  = \ (@e_a3nf) (@a_a3pi) ->
      Data.Foldable.foldl'
        @(Either e_a3nf)
        (Main.$fFoldableEither @e_a3nf)
        @Int
        @a_a3pi
        (\ (c_a54K :: Int) _ [Occ=Dead] ->
           case c_a54K of { GHC.Types.I# x_a54N ->
           GHC.Types.I# (GHC.Prim.+# x_a54N 1#)
           })
        (GHC.Types.I# 0#)

-- RHS size: {terms: 12, types: 16, coercions: 0, joins: 0/0}
$ctoList_a3oX [Occ=LoopBreaker] :: forall e a. Either e a -> [a]
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 70 40}]
$ctoList_a3oX
  = \ (@e_a3nf) (@a_a3p0) (t1_a54S :: Either e_a3nf a_a3p0) ->
      GHC.Base.build
        @a_a3p0
        (\ (@b_a54T)
           (c_a54U [OS=OneShot] :: a_a3p0 -> b_a54T -> b_a54T)
           (n_a54V [OS=OneShot] :: b_a54T) ->
           foldr
             @(Either e_a3nf)
             (Main.$fFoldableEither @e_a3nf)
             @a_a3p0
             @b_a54T
             c_a54U
             n_a54V
             t1_a54S)

-- RHS size: {terms: 28, types: 30, coercions: 0, joins: 0/0}
$cfoldl1_a3oN [Occ=LoopBreaker]
  :: forall e a. (a -> a -> a) -> Either e a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0] 260 0}]
$cfoldl1_a3oN
  = \ (@e_a3nf)
      (@a_a3oQ)
      (f_a54Z :: a_a3oQ -> a_a3oQ -> a_a3oQ)
      (xs_a550 :: Either e_a3nf a_a3oQ) ->
      case foldl
             @(Either e_a3nf)
             (Main.$fFoldableEither @e_a3nf)
             @(GHC.Maybe.Maybe a_a3oQ)
             @a_a3oQ
             (\ (m_a551 :: GHC.Maybe.Maybe a_a3oQ) (y_a552 :: a_a3oQ) ->
                GHC.Maybe.Just
                  @a_a3oQ
                  (case m_a551 of {
                     GHC.Maybe.Nothing -> y_a552;
                     GHC.Maybe.Just x_a555 -> f_a54Z x_a555 y_a552
                   }))
             (GHC.Maybe.Nothing @a_a3oQ)
             xs_a550
      of {
        GHC.Maybe.Nothing ->
          errorWithoutStackTrace
            @GHC.Types.LiftedRep
            @a_a3oQ
            (GHC.Base.build
               @Char
               (\ (@b_a558) ->
                  GHC.CString.unpackFoldrCString#
                    @b_a558 "foldl1: empty structure"#));
        GHC.Maybe.Just v_a559 -> v_a559
      }

-- RHS size: {terms: 28, types: 30, coercions: 0, joins: 0/0}
$cfoldr1_a3oD [Occ=LoopBreaker]
  :: forall e a. (a -> a -> a) -> Either e a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0] 260 0}]
$cfoldr1_a3oD
  = \ (@e_a3nf)
      (@a_a3oG)
      (f_a55f :: a_a3oG -> a_a3oG -> a_a3oG)
      (xs_a55g :: Either e_a3nf a_a3oG) ->
      case foldr
             @(Either e_a3nf)
             (Main.$fFoldableEither @e_a3nf)
             @a_a3oG
             @(GHC.Maybe.Maybe a_a3oG)
             (\ (x_a55h :: a_a3oG) (m_a55i :: GHC.Maybe.Maybe a_a3oG) ->
                GHC.Maybe.Just
                  @a_a3oG
                  (case m_a55i of {
                     GHC.Maybe.Nothing -> x_a55h;
                     GHC.Maybe.Just y_a55l -> f_a55f x_a55h y_a55l
                   }))
             (GHC.Maybe.Nothing @a_a3oG)
             xs_a55g
      of {
        GHC.Maybe.Nothing ->
          errorWithoutStackTrace
            @GHC.Types.LiftedRep
            @a_a3oG
            (GHC.Base.build
               @Char
               (\ (@b_a55o) ->
                  GHC.CString.unpackFoldrCString#
                    @b_a55o "foldr1: empty structure"#));
        GHC.Maybe.Just v_a55p -> v_a55p
      }

-- RHS size: {terms: 21, types: 22, coercions: 0, joins: 0/0}
$cfoldl'_a3or [Occ=LoopBreaker]
  :: forall e b a. (b -> a -> b) -> b -> Either e a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 150 0}]
$cfoldl'_a3or
  = \ (@e_a3nf)
      (@b_a3ou)
      (@a_a3ov)
      (f_a55w :: b_a3ou -> a_a3ov -> b_a3ou)
      (z0_a55x :: b_a3ou)
      (xs_a55y :: Either e_a3nf a_a3ov) ->
      foldr
        @(Either e_a3nf)
        (Main.$fFoldableEither @e_a3nf)
        @a_a3ov
        @(b_a3ou -> b_a3ou)
        (\ (ds_a55z :: a_a3ov)
           (ds1_a55A :: b_a3ou -> b_a3ou)
           (v_a55B [OS=OneShot] :: b_a3ou) ->
           case v_a55B of z_a55C { __DEFAULT ->
           ds1_a55A (f_a55w z_a55C ds_a55z)
           })
        (id @b_a3ou)
        xs_a55y
        z0_a55x

-- RHS size: {terms: 17, types: 22, coercions: 10, joins: 0/0}
$cfoldl_a3of [Occ=LoopBreaker]
  :: forall e b a. (b -> a -> b) -> b -> Either e a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 130 0}]
$cfoldl_a3of
  = \ (@e_a3nf)
      (@b_a3oi)
      (@a_a3oj)
      (eta_a55I :: b_a3oi -> a_a3oj -> b_a3oi)
      (eta1_a55J :: b_a3oi)
      (eta2_a55K :: Either e_a3nf a_a3oj) ->
      ((foldMap
          @(Either e_a3nf)
          (Main.$fFoldableEither @e_a3nf)
          @(base:Data.Semigroup.Internal.Dual
              (base:Data.Semigroup.Internal.Endo b_a3oi))
          @a_a3oj
          (base:Data.Semigroup.Internal.$fMonoidDual
             @(base:Data.Semigroup.Internal.Endo b_a3oi)
             (base:Data.Semigroup.Internal.$fMonoidEndo @b_a3oi))
          ((\ (x_a55N :: a_a3oj) (y_a55O :: b_a3oi) ->
              eta_a55I y_a55O x_a55N)
           `cast` (<a_a3oj>_R
                   %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Dual[0]
                                            (base:Data.Semigroup.Internal.N:Endo[0] <b_a3oi>_R))
                   :: (a_a3oj -> b_a3oi -> b_a3oi)
                      ~R# (a_a3oj
                           -> base:Data.Semigroup.Internal.Dual
                                (base:Data.Semigroup.Internal.Endo b_a3oi))))
          eta2_a55K)
       `cast` (base:Data.Semigroup.Internal.N:Dual[0]
                   (base:Data.Semigroup.Internal.N:Endo[0] <b_a3oi>_R)
               :: base:Data.Semigroup.Internal.Dual
                    (base:Data.Semigroup.Internal.Endo b_a3oi)
                  ~R# (b_a3oi -> b_a3oi)))
        eta1_a55J

-- RHS size: {terms: 21, types: 22, coercions: 0, joins: 0/0}
$cfoldr'_a3o3 [Occ=LoopBreaker]
  :: forall e a b. (a -> b -> b) -> b -> Either e a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 150 0}]
$cfoldr'_a3o3
  = \ (@e_a3nf)
      (@a_a3o6)
      (@b_a3o7)
      (f_a55X :: a_a3o6 -> b_a3o7 -> b_a3o7)
      (z0_a55Y :: b_a3o7)
      (xs_a55Z :: Either e_a3nf a_a3o6) ->
      foldl
        @(Either e_a3nf)
        (Main.$fFoldableEither @e_a3nf)
        @(b_a3o7 -> b_a3o7)
        @a_a3o6
        (\ (ds_a560 :: b_a3o7 -> b_a3o7)
           (ds1_a561 :: a_a3o6)
           (v_a562 [OS=OneShot] :: b_a3o7) ->
           case v_a562 of z_a563 { __DEFAULT ->
           ds_a560 (f_a55X ds1_a561 z_a563)
           })
        (id @b_a3o7)
        xs_a55Z
        z0_a55Y

-- RHS size: {terms: 19, types: 19, coercions: 0, joins: 0/1}
$cfoldMap'_a3nG [Occ=LoopBreaker]
  :: forall e m a. Monoid m => (a -> m) -> Either e a -> m
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 60] 170 0}]
$cfoldMap'_a3nG
  = \ (@e_a3nf)
      (@m_a3nJ)
      (@a_a3nK)
      ($dMonoid_a3nL :: Monoid m_a3nJ)
      (eta_a569 :: a_a3nK -> m_a3nJ) ->
      let {
        $dSemigroup_a56a :: Semigroup m_a3nJ
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dSemigroup_a56a = GHC.Base.$p1Monoid @m_a3nJ $dMonoid_a3nL } in
      Data.Foldable.foldl'
        @(Either e_a3nf)
        (Main.$fFoldableEither @e_a3nf)
        @m_a3nJ
        @a_a3nK
        (\ (acc_a56b :: m_a3nJ) (a1_a56c :: a_a3nK) ->
           <> @m_a3nJ $dSemigroup_a56a acc_a56b (eta_a569 a1_a56c))
        (mempty @m_a3nJ $dMonoid_a3nL)

-- RHS size: {terms: 15, types: 21, coercions: 25, joins: 0/0}
$cproduct_a3qb [Occ=LoopBreaker]
  :: forall e a. Num a => Either e a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 120 60}]
$cproduct_a3qb
  = \ (@e_a3nf) (@a_a3qe) ($dNum_a3qf :: Num a_a3qe) ->
      ((\ (@(t_a56d :: * -> *))
          ($dFoldable_a56e :: Foldable t_a56d)
          (@a_a56f)
          ($dNum_a56g :: Num a_a56f) ->
          Data.Foldable.foldMap'
            @t_a56d
            $dFoldable_a56e
            @(base:Data.Semigroup.Internal.Product a_a56f)
            @a_a56f
            (base:Data.Semigroup.Internal.$fMonoidProduct @a_a56f $dNum_a56g)
            ((\ (ds_a56i :: a_a56f) -> ds_a56i)
             `cast` (<a_a56f>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Product[0]
                                              <a_a56f>_R)
                     :: (a_a56f -> a_a56f)
                        ~R# (a_a56f -> base:Data.Semigroup.Internal.Product a_a56f))))
       `cast` (forall (t :: <* -> *>_N).
               <Foldable t>_R
               %<'Many>_N ->_R forall (a :: <*>_N).
                               <Num a>_R
                               %<'Many>_N ->_R <t a>_R
                               %<'Many>_N ->_R base:Data.Semigroup.Internal.N:Product[0] <a>_R
               :: (forall {t :: * -> *} {a}.
                   (Foldable t, Num a) =>
                   t a -> base:Data.Semigroup.Internal.Product a)
                  ~R# (forall {t :: * -> *} {a}. (Foldable t, Num a) => t a -> a)))
        @(Either e_a3nf) (Main.$fFoldableEither @e_a3nf) @a_a3qe $dNum_a3qf

-- RHS size: {terms: 7, types: 10, coercions: 0, joins: 0/0}
$cfold_a3nh [Occ=LoopBreaker]
  :: forall e m. Monoid m => Either e m -> m
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 40 0}]
$cfold_a3nh
  = \ (@e_a3nf) (@m_a3nk) ($dMonoid_a3nl :: Monoid m_a3nk) ->
      foldMap
        @(Either e_a3nf)
        (Main.$fFoldableEither @e_a3nf)
        @m_a3nk
        @m_a3nk
        $dMonoid_a3nl
        (id @m_a3nk)
end Rec }

-- RHS size: {terms: 13, types: 16, coercions: 0, joins: 0/0}
$c<$_a3mY :: forall e a b. a -> Either e b -> Either e a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 40] 40 20}]
$c<$_a3mY
  = \ (@e_a3mH)
      (@a_a3n1)
      (@b_a3n2)
      (z_a2do :: a_a3n1)
      (ds_d4PT :: Either e_a3mH b_a3n2) ->
      case ds_d4PT of {
        Left a1_a2dp -> Main.Left @e_a3mH @a_a3n1 a1_a2dp;
        Right _ [Occ=Dead] -> Main.Right @e_a3mH @a_a3n1 z_a2do
      }

-- RHS size: {terms: 14, types: 17, coercions: 0, joins: 0/0}
$cfmap_a3mJ :: forall e a b. (a -> b) -> Either e a -> Either e b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 40] 60 20}]
$cfmap_a3mJ
  = \ (@e_a3mH)
      (@a_a3mM)
      (@b_a3mN)
      (f_a2dk :: a_a3mM -> b_a3mN)
      (ds_d4PQ :: Either e_a3mH a_a3mM) ->
      case ds_d4PQ of {
        Left a1_a2dl -> Main.Left @e_a3mH @b_a3mN a1_a2dl;
        Right a1_a2dn -> Main.Right @e_a3mH @b_a3mN (f_a2dk a1_a2dn)
      }

-- RHS size: {terms: 4, types: 5, coercions: 0, joins: 0/0}
Main.$fFunctorEither [InlPrag=CONLIKE]
  :: forall e. Functor (Either e)
[LclIdX[DFunId],
 Unf=DFun: \ (@e_a1xz) ->
       GHC.Base.C:Functor TYPE: Either e_a1xz
                          $cfmap_a3mJ @e_a1xz
                          $c<$_a3mY @e_a1xz]
Main.$fFunctorEither
  = \ (@e_a3mH) ->
      GHC.Base.C:Functor
        @(Either e_a3mH) ($cfmap_a3mJ @e_a3mH) ($c<$_a3mY @e_a3mH)

Rec {
-- RHS size: {terms: 8, types: 9, coercions: 0, joins: 0/0}
Main.$fTraversableEither [InlPrag=CONLIKE]
  :: forall fixed. Traversable (Either fixed)
[LclIdX[DFunId],
 Unf=DFun: \ (@fixed_aUA) ->
       Data.Traversable.C:Traversable TYPE: Either fixed_aUA
                                      Main.$fFunctorEither @fixed_aUA
                                      Main.$fFoldableEither @fixed_aUA
                                      $ctraverse_a4gn @fixed_aUA
                                      $csequenceA_a4gD @fixed_aUA
                                      $cmapM_a4gR @fixed_aUA
                                      $csequence_a4h7 @fixed_aUA]
Main.$fTraversableEither
  = \ (@fixed_a4gd) ->
      Data.Traversable.C:Traversable
        @(Either fixed_a4gd)
        (Main.$fFunctorEither @fixed_a4gd)
        (Main.$fFoldableEither @fixed_a4gd)
        ($ctraverse_a4gn @fixed_a4gd)
        ($csequenceA_a4gD @fixed_a4gd)
        ($cmapM_a4gR @fixed_a4gd)
        ($csequence_a4h7 @fixed_a4gd)

-- RHS size: {terms: 9, types: 14, coercions: 0, joins: 0/0}
$cmapM_a4gR [Occ=LoopBreaker]
  :: forall fixed (m :: * -> *) a b.
     Monad m =>
     (a -> m b) -> Either fixed a -> m (Either fixed b)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30] 50 0}]
$cmapM_a4gR
  = \ (@fixed_a4gd)
      (@(m_a4gU :: * -> *))
      (@a_a4gV)
      (@b_a4gW)
      ($dMonad_a4gX :: Monad m_a4gU) ->
      traverse
        @(Either fixed_a4gd)
        (Main.$fTraversableEither @fixed_a4gd)
        @m_a4gU
        @a_a4gV
        @b_a4gW
        (GHC.Base.$p1Monad @m_a4gU $dMonad_a4gX)

-- RHS size: {terms: 8, types: 15, coercions: 0, joins: 0/0}
$csequenceA_a4gD [Occ=LoopBreaker]
  :: forall fixed (f :: * -> *) a.
     Applicative f =>
     Either fixed (f a) -> f (Either fixed a)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 40 0}]
$csequenceA_a4gD
  = \ (@fixed_a4gd)
      (@(f_a4gG :: * -> *))
      (@a_a4gH)
      ($dApplicative_a4gI :: Applicative f_a4gG) ->
      traverse
        @(Either fixed_a4gd)
        (Main.$fTraversableEither @fixed_a4gd)
        @f_a4gG
        @(f_a4gG a_a4gH)
        @a_a4gH
        $dApplicative_a4gI
        (id @(f_a4gG a_a4gH))

-- RHS size: {terms: 8, types: 12, coercions: 0, joins: 0/0}
$csequence_a4h7 [Occ=LoopBreaker]
  :: forall fixed (m :: * -> *) a.
     Monad m =>
     Either fixed (m a) -> m (Either fixed a)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30] 50 0}]
$csequence_a4h7
  = \ (@fixed_a4gd)
      (@(m_a4ha :: * -> *))
      (@a_a4hb)
      ($dMonad_a4hc :: Monad m_a4ha) ->
      sequenceA
        @(Either fixed_a4gd)
        (Main.$fTraversableEither @fixed_a4gd)
        @m_a4ha
        @a_a4hb
        (GHC.Base.$p1Monad @m_a4ha $dMonad_a4hc)

-- RHS size: {terms: 19, types: 41, coercions: 0, joins: 0/2}
$ctraverse_a4gn [Occ=LoopBreaker]
  :: forall fixed (f :: * -> *) a b.
     Applicative f =>
     (a -> f b) -> Either fixed a -> f (Either fixed b)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 150 60}]
$ctraverse_a4gn
  = \ (@fixed_a4gd)
      (@(f_a4gq :: * -> *))
      (@a_a4gr)
      (@b_a4gs)
      ($dApplicative_a4gt :: Applicative f_a4gq)
      (eta1_a56N :: a_a4gr -> f_a4gq b_a4gs) ->
      let {
        f1_a56O
          :: Either fixed_a4gd (f_a4gq b_a4gs)
             -> f_a4gq (Either fixed_a4gd b_a4gs)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 30 0}]
        f1_a56O
          = sequenceA
              @(Either fixed_a4gd)
              (Main.$fTraversableEither @fixed_a4gd)
              @f_a4gq
              @b_a4gs
              $dApplicative_a4gt } in
      let {
        g_a56P
          :: Either fixed_a4gd a_a4gr -> Either fixed_a4gd (f_a4gq b_a4gs)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 50 0}]
        g_a56P
          = fmap
              @(Either fixed_a4gd)
              (Data.Traversable.$p1Traversable
                 @(Either fixed_a4gd) (Main.$fTraversableEither @fixed_a4gd))
              @a_a4gr
              @(f_a4gq b_a4gs)
              eta1_a56N } in
      \ (x_a56Q :: Either fixed_a4gd a_a4gr) -> f1_a56O (g_a56P x_a56Q)
end Rec }

-- RHS size: {terms: 40, types: 25, coercions: 0, joins: 0/0}
$cshowsPrec_a3m6
  :: forall e a. (Show e, Show a) => Int -> Either e a -> ShowS
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 0 260] 480 0}]
$cshowsPrec_a3m6
  = \ (@e_a3m1)
      (@a_a3m2)
      ($dShow_a3m3 :: Show e_a3m1)
      ($dShow_a3m4 :: Show a_a3m2)
      (a_a2dg :: Int)
      (ds_d4PJ :: Either e_a3m1 a_a3m2) ->
      case ds_d4PJ of {
        Left b1_a2dh ->
          showParen
            (>= @Int GHC.Classes.$fOrdInt a_a2dg (GHC.Types.I# 11#))
            (. @String
               @String
               @String
               (showString (GHC.CString.unpackCString# "Left "#))
               (showsPrec @e_a3m1 $dShow_a3m3 (GHC.Types.I# 11#) b1_a2dh));
        Right b1_a2dj ->
          showParen
            (>= @Int GHC.Classes.$fOrdInt a_a2dg (GHC.Types.I# 11#))
            (. @String
               @String
               @String
               (showString (GHC.CString.unpackCString# "Right "#))
               (showsPrec @a_a3m2 $dShow_a3m4 (GHC.Types.I# 11#) b1_a2dj))
      }

Rec {
-- RHS size: {terms: 14, types: 15, coercions: 0, joins: 0/0}
Main.$fShowEither [InlPrag=CONLIKE]
  :: forall e a. (Show e, Show a) => Show (Either e a)
[LclIdX[DFunId],
 Unf=DFun: \ (@e_a1xs)
             (@a_a1xt)
             (v_B1 :: Show e_a1xs)
             (v_B2 :: Show a_a1xt) ->
       GHC.Show.C:Show TYPE: Either e_a1xs a_a1xt
                       $cshowsPrec_a3m6 @e_a1xs @a_a1xt v_B1 v_B2
                       $cshow_a3mr @e_a1xs @a_a1xt v_B1 v_B2
                       $cshowList_a3my @e_a1xs @a_a1xt v_B1 v_B2]
Main.$fShowEither
  = \ (@e_a3m1)
      (@a_a3m2)
      ($dShow_a3m3 :: Show e_a3m1)
      ($dShow_a3m4 :: Show a_a3m2) ->
      GHC.Show.C:Show
        @(Either e_a3m1 a_a3m2)
        ($cshowsPrec_a3m6 @e_a3m1 @a_a3m2 $dShow_a3m3 $dShow_a3m4)
        ($cshow_a3mr @e_a3m1 @a_a3m2 $dShow_a3m3 $dShow_a3m4)
        ($cshowList_a3my @e_a3m1 @a_a3m2 $dShow_a3m3 $dShow_a3m4)

-- RHS size: {terms: 17, types: 23, coercions: 0, joins: 0/1}
$cshowList_a3my [Occ=LoopBreaker]
  :: forall e a. (Show e, Show a) => [Either e a] -> ShowS
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 140 60}]
$cshowList_a3my
  = \ (@e_a3m1)
      (@a_a3m2)
      ($dShow_a3m3 :: Show e_a3m1)
      ($dShow_a3m4 :: Show a_a3m2) ->
      let {
        $dShow_a56S :: Show (Either e_a3m1 a_a3m2)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 30 0}]
        $dShow_a56S
          = Main.$fShowEither @e_a3m1 @a_a3m2 $dShow_a3m3 $dShow_a3m4 } in
      \ (ls_a56T :: [Either e_a3m1 a_a3m2]) (s_a56U :: String) ->
        GHC.Show.showList__
          @(Either e_a3m1 a_a3m2)
          (showsPrec @(Either e_a3m1 a_a3m2) $dShow_a56S (GHC.Types.I# 0#))
          ls_a56T
          s_a56U

-- RHS size: {terms: 15, types: 19, coercions: 0, joins: 0/1}
$cshow_a3mr [Occ=LoopBreaker]
  :: forall e a. (Show e, Show a) => Either e a -> String
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 110 60}]
$cshow_a3mr
  = \ (@e_a3m1)
      (@a_a3m2)
      ($dShow_a3m3 :: Show e_a3m1)
      ($dShow_a3m4 :: Show a_a3m2) ->
      let {
        $dShow_a56X :: Show (Either e_a3m1 a_a3m2)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 30 0}]
        $dShow_a56X
          = Main.$fShowEither @e_a3m1 @a_a3m2 $dShow_a3m3 $dShow_a3m4 } in
      \ (x_a56Y :: Either e_a3m1 a_a3m2) ->
        showsPrec
          @(Either e_a3m1 a_a3m2)
          $dShow_a56X
          (GHC.Types.I# 0#)
          x_a56Y
          (GHC.Types.[] @Char)
end Rec }

-- RHS size: {terms: 50, types: 43, coercions: 0, joins: 0/0}
$c==_a3lr
  :: forall e a. (Eq e, Eq a) => Either e a -> Either e a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 180 140] 353 10}]
$c==_a3lr
  = \ (@e_a3lm)
      (@a_a3ln)
      ($dEq_a3lo :: Eq e_a3lm)
      ($dEq_a3lp :: Eq a_a3ln)
      (a_a2d8 :: Either e_a3lm a_a3ln)
      (b_a2d9 :: Either e_a3lm a_a3ln) ->
      case case GHC.Prim.dataToTag# @(Either e_a3lm a_a3ln) a_a2d8
           of a#_a2da
           { __DEFAULT ->
           case GHC.Prim.dataToTag# @(Either e_a3lm a_a3ln) b_a2d9 of b#_a2db
           { __DEFAULT ->
           GHC.Prim./=# a#_a2da b#_a2db
           }
           }
      of ds_d4Po
      { __DEFAULT ->
      case ds_d4Po of {
        __DEFAULT ->
          case a_a2d8 of {
            Left a1_a2dc ->
              case b_a2d9 of {
                __DEFAULT ->
                  case Control.Exception.Base.patError
                         @GHC.Types.LiftedRep @() "Gy08.hs:36:46-47|case"#
                  of {
                  };
                Left b1_a2dd -> == @e_a3lm $dEq_a3lo a1_a2dc b1_a2dd
              };
            Right a1_a2de ->
              case b_a2d9 of {
                __DEFAULT ->
                  case Control.Exception.Base.patError
                         @GHC.Types.LiftedRep @() "Gy08.hs:36:46-47|case"#
                  of {
                  };
                Right b1_a2df -> == @a_a3ln $dEq_a3lp a1_a2de b1_a2df
              }
          };
        1# -> GHC.Types.False
      }
      }

Rec {
-- RHS size: {terms: 11, types: 13, coercions: 0, joins: 0/0}
Main.$fEqEither [InlPrag=CONLIKE]
  :: forall e a. (Eq e, Eq a) => Eq (Either e a)
[LclIdX[DFunId],
 Unf=DFun: \ (@e_a1xl)
             (@a_a1xm)
             (v_B1 :: Eq e_a1xl)
             (v_B2 :: Eq a_a1xm) ->
       GHC.Classes.C:Eq TYPE: Either e_a1xl a_a1xm
                        $c==_a3lr @e_a1xl @a_a1xm v_B1 v_B2
                        $c/=_a3lS @e_a1xl @a_a1xm v_B1 v_B2]
Main.$fEqEither
  = \ (@e_a3lm)
      (@a_a3ln)
      ($dEq_a3lo :: Eq e_a3lm)
      ($dEq_a3lp :: Eq a_a3ln) ->
      GHC.Classes.C:Eq
        @(Either e_a3lm a_a3ln)
        ($c==_a3lr @e_a3lm @a_a3ln $dEq_a3lo $dEq_a3lp)
        ($c/=_a3lS @e_a3lm @a_a3ln $dEq_a3lo $dEq_a3lp)

-- RHS size: {terms: 19, types: 22, coercions: 0, joins: 0/1}
$c/=_a3lS [Occ=LoopBreaker]
  :: forall e a. (Eq e, Eq a) => Either e a -> Either e a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 120 60}]
$c/=_a3lS
  = \ (@e_a3lm)
      (@a_a3ln)
      ($dEq_a3lo :: Eq e_a3lm)
      ($dEq_a3lp :: Eq a_a3ln) ->
      let {
        $dEq_a570 :: Eq (Either e_a3lm a_a3ln)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 30 0}]
        $dEq_a570
          = Main.$fEqEither @e_a3lm @a_a3ln $dEq_a3lo $dEq_a3lp } in
      \ (x_a571 :: Either e_a3lm a_a3ln)
        (y_a572 :: Either e_a3lm a_a3ln) ->
        case == @(Either e_a3lm a_a3ln) $dEq_a570 x_a571 y_a572 of {
          False -> GHC.Types.True;
          True -> GHC.Types.False
        }
end Rec }

-- RHS size: {terms: 7, types: 10, coercions: 0, joins: 0/0}
$cnull_a3k5 :: forall e a. BiTuple e a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)}]
$cnull_a3k5
  = \ (@e_a3ih) (@a_a3k8) (ds_d4Pf :: BiTuple e_a3ih a_a3k8) ->
      case ds_d4Pf of { BiTuple _ [Occ=Dead] _ [Occ=Dead] ->
      GHC.Types.False
      }

-- RHS size: {terms: 12, types: 15, coercions: 0, joins: 0/0}
$cfoldr_a3iT
  :: forall e a b. (a -> b -> b) -> b -> BiTuple e a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)}]
$cfoldr_a3iT
  = \ (@e_a3ih)
      (@a_a3iW)
      (@b_a3iX)
      (f_a2d1 :: a_a3iW -> b_a3iX -> b_a3iX)
      (z_a2d2 :: b_a3iX)
      (ds_d4Pe :: BiTuple e_a3ih a_a3iW) ->
      case ds_d4Pe of { BiTuple _ [Occ=Dead] a2_a2d4 ->
      f_a2d1 a2_a2d4 z_a2d2
      }

-- RHS size: {terms: 11, types: 15, coercions: 0, joins: 0/0}
$cfoldMap_a3iv
  :: forall e m a. Monoid m => (a -> m) -> BiTuple e a -> m
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)}]
$cfoldMap_a3iv
  = \ (@e_a3ih)
      (@m_a3iy)
      (@a_a3iz)
      _ [Occ=Dead]
      (f_a2d5 :: a_a3iz -> m_a3iy)
      (ds_d4Pd :: BiTuple e_a3ih a_a3iz) ->
      case ds_d4Pd of { BiTuple _ [Occ=Dead] a2_a2d7 -> f_a2d5 a2_a2d7 }

Rec {
-- RHS size: {terms: 19, types: 20, coercions: 0, joins: 0/0}
Main.$fFoldableBiTuple [InlPrag=CONLIKE]
  :: forall e. Foldable (BiTuple e)
[LclIdX[DFunId],
 Unf=DFun: \ (@e_a1xf) ->
       Data.Foldable.C:Foldable TYPE: BiTuple e_a1xf
                                $cfold_a3ij @e_a1xf
                                $cfoldMap_a3iv @e_a1xf
                                $cfoldMap'_a3iF @e_a1xf
                                $cfoldr_a3iT @e_a1xf
                                $cfoldr'_a3j1 @e_a1xf
                                $cfoldl_a3jd @e_a1xf
                                $cfoldl'_a3jp @e_a1xf
                                $cfoldr1_a3jB @e_a1xf
                                $cfoldl1_a3jL @e_a1xf
                                $ctoList_a3jV @e_a1xf
                                $cnull_a3k5 @e_a1xf
                                $clength_a3kc @e_a1xf
                                $celem_a3km @e_a1xf
                                $cmaximum_a3ky @e_a1xf
                                $cminimum_a3kK @e_a1xf
                                $csum_a3kW @e_a1xf
                                $cproduct_a3l8 @e_a1xf]
Main.$fFoldableBiTuple
  = \ (@e_a3ih) ->
      Data.Foldable.C:Foldable
        @(BiTuple e_a3ih)
        ($cfold_a3ij @e_a3ih)
        ($cfoldMap_a3iv @e_a3ih)
        ($cfoldMap'_a3iF @e_a3ih)
        ($cfoldr_a3iT @e_a3ih)
        ($cfoldr'_a3j1 @e_a3ih)
        ($cfoldl_a3jd @e_a3ih)
        ($cfoldl'_a3jp @e_a3ih)
        ($cfoldr1_a3jB @e_a3ih)
        ($cfoldl1_a3jL @e_a3ih)
        ($ctoList_a3jV @e_a3ih)
        ($cnull_a3k5 @e_a3ih)
        ($clength_a3kc @e_a3ih)
        ($celem_a3km @e_a3ih)
        ($cmaximum_a3ky @e_a3ih)
        ($cminimum_a3kK @e_a3ih)
        ($csum_a3kW @e_a3ih)
        ($cproduct_a3l8 @e_a3ih)

-- RHS size: {terms: 15, types: 21, coercions: 25, joins: 0/0}
$csum_a3kW [Occ=LoopBreaker]
  :: forall e a. Num a => BiTuple e a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 120 60}]
$csum_a3kW
  = \ (@e_a3ih) (@a_a3kZ) ($dNum_a3l0 :: Num a_a3kZ) ->
      ((\ (@(t_a4WR :: * -> *))
          ($dFoldable_a4WS :: Foldable t_a4WR)
          (@a_a4WT)
          ($dNum_a4WU :: Num a_a4WT) ->
          Data.Foldable.foldMap'
            @t_a4WR
            $dFoldable_a4WS
            @(base:Data.Semigroup.Internal.Sum a_a4WT)
            @a_a4WT
            (base:Data.Semigroup.Internal.$fMonoidSum @a_a4WT $dNum_a4WU)
            ((\ (ds_a52f :: a_a4WT) -> ds_a52f)
             `cast` (<a_a4WT>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Sum[0]
                                              <a_a4WT>_R)
                     :: (a_a4WT -> a_a4WT)
                        ~R# (a_a4WT -> base:Data.Semigroup.Internal.Sum a_a4WT))))
       `cast` (forall (t :: <* -> *>_N).
               <Foldable t>_R
               %<'Many>_N ->_R forall (a :: <*>_N).
                               <Num a>_R
                               %<'Many>_N ->_R <t a>_R
                               %<'Many>_N ->_R base:Data.Semigroup.Internal.N:Sum[0] <a>_R
               :: (forall {t :: * -> *} {a}.
                   (Foldable t, Num a) =>
                   t a -> base:Data.Semigroup.Internal.Sum a)
                  ~R# (forall {t :: * -> *} {a}. (Foldable t, Num a) => t a -> a)))
        @(BiTuple e_a3ih)
        (Main.$fFoldableBiTuple @e_a3ih)
        @a_a3kZ
        $dNum_a3l0

-- RHS size: {terms: 25, types: 30, coercions: 8, joins: 0/2}
$cminimum_a3kK [Occ=LoopBreaker]
  :: forall e a. Ord a => BiTuple e a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 260 60}]
$cminimum_a3kK
  = \ (@e_a3ih) (@a_a3kN) ($dOrd_a3kO :: Ord a_a3kN) ->
      let {
        d_a52o :: a_a3kN
        [LclId,
         Str=b,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 110 0}]
        d_a52o
          = errorWithoutStackTrace
              @GHC.Types.LiftedRep
              @a_a3kN
              (GHC.Base.build
                 @Char
                 (\ (@b_a52t) ->
                    GHC.CString.unpackFoldrCString#
                      @b_a52t "minimum: empty structure"#)) } in
      let {
        g_a52v
          :: BiTuple e_a3ih a_a3kN -> base:Data.Functor.Utils.Min a_a3kN
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 80 0}]
        g_a52v
          = Data.Foldable.foldMap'
              @(BiTuple e_a3ih)
              (Main.$fFoldableBiTuple @e_a3ih)
              @(base:Data.Functor.Utils.Min a_a3kN)
              @a_a3kN
              (base:Data.Functor.Utils.$fMonoidMin @a_a3kN $dOrd_a3kO)
              ((\ (ds_a53M :: a_a3kN) -> GHC.Maybe.Just @a_a3kN ds_a53M)
               `cast` (<a_a3kN>_R
                       %<'Many>_N ->_R Sym (base:Data.Functor.Utils.N:Min[0]) <a_a3kN>_N
                       :: (a_a3kN -> GHC.Maybe.Maybe a_a3kN)
                          ~R# (a_a3kN -> base:Data.Functor.Utils.Min a_a3kN))) } in
      \ (x_a53N :: BiTuple e_a3ih a_a3kN) ->
        case (g_a52v x_a53N)
             `cast` (base:Data.Functor.Utils.N:Min[0] <a_a3kN>_N
                     :: base:Data.Functor.Utils.Min a_a3kN ~R# GHC.Maybe.Maybe a_a3kN)
        of {
          GHC.Maybe.Nothing -> d_a52o;
          GHC.Maybe.Just v_a54h -> v_a54h
        }

-- RHS size: {terms: 25, types: 30, coercions: 8, joins: 0/2}
$cmaximum_a3ky [Occ=LoopBreaker]
  :: forall e a. Ord a => BiTuple e a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 260 60}]
$cmaximum_a3ky
  = \ (@e_a3ih) (@a_a3kB) ($dOrd_a3kC :: Ord a_a3kB) ->
      let {
        d_a54n :: a_a3kB
        [LclId,
         Str=b,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 110 0}]
        d_a54n
          = errorWithoutStackTrace
              @GHC.Types.LiftedRep
              @a_a3kB
              (GHC.Base.build
                 @Char
                 (\ (@b_a54o) ->
                    GHC.CString.unpackFoldrCString#
                      @b_a54o "maximum: empty structure"#)) } in
      let {
        g_a54p
          :: BiTuple e_a3ih a_a3kB -> base:Data.Functor.Utils.Max a_a3kB
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 80 0}]
        g_a54p
          = Data.Foldable.foldMap'
              @(BiTuple e_a3ih)
              (Main.$fFoldableBiTuple @e_a3ih)
              @(base:Data.Functor.Utils.Max a_a3kB)
              @a_a3kB
              (base:Data.Functor.Utils.$fMonoidMax @a_a3kB $dOrd_a3kC)
              ((\ (ds_a54r :: a_a3kB) -> GHC.Maybe.Just @a_a3kB ds_a54r)
               `cast` (<a_a3kB>_R
                       %<'Many>_N ->_R Sym (base:Data.Functor.Utils.N:Max[0]) <a_a3kB>_N
                       :: (a_a3kB -> GHC.Maybe.Maybe a_a3kB)
                          ~R# (a_a3kB -> base:Data.Functor.Utils.Max a_a3kB))) } in
      \ (x_a54s :: BiTuple e_a3ih a_a3kB) ->
        case (g_a54p x_a54s)
             `cast` (base:Data.Functor.Utils.N:Max[0] <a_a3kB>_N
                     :: base:Data.Functor.Utils.Max a_a3kB ~R# GHC.Maybe.Maybe a_a3kB)
        of {
          GHC.Maybe.Nothing -> d_a54n;
          GHC.Maybe.Just v_a54x -> v_a54x
        }

-- RHS size: {terms: 16, types: 20, coercions: 26, joins: 0/0}
$celem_a3km [Occ=LoopBreaker]
  :: forall e a. Eq a => a -> BiTuple e a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 130 60}]
$celem_a3km
  = \ (@e_a3ih) (@a_a3kp) ($dEq_a3kq :: Eq a_a3kp) ->
      ((\ (@(t_a54z :: * -> *))
          ($dFoldable_a54A :: Foldable t_a54z)
          (@a_a54B)
          ($dEq_a54C :: Eq a_a54B)
          (eta_a54D :: a_a54B) ->
          foldMap
            @t_a54z
            $dFoldable_a54A
            @base:Data.Semigroup.Internal.Any
            @a_a54B
            base:Data.Semigroup.Internal.$fMonoidAny
            ((== @a_a54B $dEq_a54C eta_a54D)
             `cast` (<a_a54B>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Any[0])
                     :: (a_a54B -> Bool)
                        ~R# (a_a54B -> base:Data.Semigroup.Internal.Any))))
       `cast` (forall (t :: <* -> *>_N).
               <Foldable t>_R
               %<'Many>_N ->_R forall (a :: <*>_N).
                               <Eq a>_R
                               %<'Many>_N ->_R <a>_R
                               %<'Many>_N ->_R <t a>_R
                               %<'Many>_N ->_R base:Data.Semigroup.Internal.N:Any[0]
               :: (forall {t :: * -> *} {a}.
                   (Foldable t, Eq a) =>
                   a -> t a -> base:Data.Semigroup.Internal.Any)
                  ~R# (forall {t :: * -> *} {a}.
                       (Foldable t, Eq a) =>
                       a -> t a -> Bool)))
        @(BiTuple e_a3ih)
        (Main.$fFoldableBiTuple @e_a3ih)
        @a_a3kp
        $dEq_a3kq

-- RHS size: {terms: 15, types: 11, coercions: 0, joins: 0/0}
$clength_a3kc [Occ=LoopBreaker] :: forall e a. BiTuple e a -> Int
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=False, ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 91 0}]
$clength_a3kc
  = \ (@e_a3ih) (@a_a3kf) ->
      Data.Foldable.foldl'
        @(BiTuple e_a3ih)
        (Main.$fFoldableBiTuple @e_a3ih)
        @Int
        @a_a3kf
        (\ (c_a54K :: Int) _ [Occ=Dead] ->
           case c_a54K of { GHC.Types.I# x_a54N ->
           GHC.Types.I# (GHC.Prim.+# x_a54N 1#)
           })
        (GHC.Types.I# 0#)

-- RHS size: {terms: 12, types: 16, coercions: 0, joins: 0/0}
$ctoList_a3jV [Occ=LoopBreaker] :: forall e a. BiTuple e a -> [a]
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 70 40}]
$ctoList_a3jV
  = \ (@e_a3ih) (@a_a3jY) (t1_a54S :: BiTuple e_a3ih a_a3jY) ->
      GHC.Base.build
        @a_a3jY
        (\ (@b_a54T)
           (c_a54U [OS=OneShot] :: a_a3jY -> b_a54T -> b_a54T)
           (n_a54V [OS=OneShot] :: b_a54T) ->
           foldr
             @(BiTuple e_a3ih)
             (Main.$fFoldableBiTuple @e_a3ih)
             @a_a3jY
             @b_a54T
             c_a54U
             n_a54V
             t1_a54S)

-- RHS size: {terms: 28, types: 30, coercions: 0, joins: 0/0}
$cfoldl1_a3jL [Occ=LoopBreaker]
  :: forall e a. (a -> a -> a) -> BiTuple e a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0] 260 0}]
$cfoldl1_a3jL
  = \ (@e_a3ih)
      (@a_a3jO)
      (f_a54Z :: a_a3jO -> a_a3jO -> a_a3jO)
      (xs_a550 :: BiTuple e_a3ih a_a3jO) ->
      case foldl
             @(BiTuple e_a3ih)
             (Main.$fFoldableBiTuple @e_a3ih)
             @(GHC.Maybe.Maybe a_a3jO)
             @a_a3jO
             (\ (m_a551 :: GHC.Maybe.Maybe a_a3jO) (y_a552 :: a_a3jO) ->
                GHC.Maybe.Just
                  @a_a3jO
                  (case m_a551 of {
                     GHC.Maybe.Nothing -> y_a552;
                     GHC.Maybe.Just x_a555 -> f_a54Z x_a555 y_a552
                   }))
             (GHC.Maybe.Nothing @a_a3jO)
             xs_a550
      of {
        GHC.Maybe.Nothing ->
          errorWithoutStackTrace
            @GHC.Types.LiftedRep
            @a_a3jO
            (GHC.Base.build
               @Char
               (\ (@b_a558) ->
                  GHC.CString.unpackFoldrCString#
                    @b_a558 "foldl1: empty structure"#));
        GHC.Maybe.Just v_a559 -> v_a559
      }

-- RHS size: {terms: 28, types: 30, coercions: 0, joins: 0/0}
$cfoldr1_a3jB [Occ=LoopBreaker]
  :: forall e a. (a -> a -> a) -> BiTuple e a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0] 260 0}]
$cfoldr1_a3jB
  = \ (@e_a3ih)
      (@a_a3jE)
      (f_a55f :: a_a3jE -> a_a3jE -> a_a3jE)
      (xs_a55g :: BiTuple e_a3ih a_a3jE) ->
      case foldr
             @(BiTuple e_a3ih)
             (Main.$fFoldableBiTuple @e_a3ih)
             @a_a3jE
             @(GHC.Maybe.Maybe a_a3jE)
             (\ (x_a55h :: a_a3jE) (m_a55i :: GHC.Maybe.Maybe a_a3jE) ->
                GHC.Maybe.Just
                  @a_a3jE
                  (case m_a55i of {
                     GHC.Maybe.Nothing -> x_a55h;
                     GHC.Maybe.Just y_a55l -> f_a55f x_a55h y_a55l
                   }))
             (GHC.Maybe.Nothing @a_a3jE)
             xs_a55g
      of {
        GHC.Maybe.Nothing ->
          errorWithoutStackTrace
            @GHC.Types.LiftedRep
            @a_a3jE
            (GHC.Base.build
               @Char
               (\ (@b_a55o) ->
                  GHC.CString.unpackFoldrCString#
                    @b_a55o "foldr1: empty structure"#));
        GHC.Maybe.Just v_a55p -> v_a55p
      }

-- RHS size: {terms: 21, types: 22, coercions: 0, joins: 0/0}
$cfoldl'_a3jp [Occ=LoopBreaker]
  :: forall e b a. (b -> a -> b) -> b -> BiTuple e a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 150 0}]
$cfoldl'_a3jp
  = \ (@e_a3ih)
      (@b_a3js)
      (@a_a3jt)
      (f_a55w :: b_a3js -> a_a3jt -> b_a3js)
      (z0_a55x :: b_a3js)
      (xs_a55y :: BiTuple e_a3ih a_a3jt) ->
      foldr
        @(BiTuple e_a3ih)
        (Main.$fFoldableBiTuple @e_a3ih)
        @a_a3jt
        @(b_a3js -> b_a3js)
        (\ (ds_a55z :: a_a3jt)
           (ds1_a55A :: b_a3js -> b_a3js)
           (v_a55B [OS=OneShot] :: b_a3js) ->
           case v_a55B of z_a55C { __DEFAULT ->
           ds1_a55A (f_a55w z_a55C ds_a55z)
           })
        (id @b_a3js)
        xs_a55y
        z0_a55x

-- RHS size: {terms: 17, types: 22, coercions: 10, joins: 0/0}
$cfoldl_a3jd [Occ=LoopBreaker]
  :: forall e b a. (b -> a -> b) -> b -> BiTuple e a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 130 0}]
$cfoldl_a3jd
  = \ (@e_a3ih)
      (@b_a3jg)
      (@a_a3jh)
      (eta_a55I :: b_a3jg -> a_a3jh -> b_a3jg)
      (eta1_a55J :: b_a3jg)
      (eta2_a55K :: BiTuple e_a3ih a_a3jh) ->
      ((foldMap
          @(BiTuple e_a3ih)
          (Main.$fFoldableBiTuple @e_a3ih)
          @(base:Data.Semigroup.Internal.Dual
              (base:Data.Semigroup.Internal.Endo b_a3jg))
          @a_a3jh
          (base:Data.Semigroup.Internal.$fMonoidDual
             @(base:Data.Semigroup.Internal.Endo b_a3jg)
             (base:Data.Semigroup.Internal.$fMonoidEndo @b_a3jg))
          ((\ (x_a55N :: a_a3jh) (y_a55O :: b_a3jg) ->
              eta_a55I y_a55O x_a55N)
           `cast` (<a_a3jh>_R
                   %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Dual[0]
                                            (base:Data.Semigroup.Internal.N:Endo[0] <b_a3jg>_R))
                   :: (a_a3jh -> b_a3jg -> b_a3jg)
                      ~R# (a_a3jh
                           -> base:Data.Semigroup.Internal.Dual
                                (base:Data.Semigroup.Internal.Endo b_a3jg))))
          eta2_a55K)
       `cast` (base:Data.Semigroup.Internal.N:Dual[0]
                   (base:Data.Semigroup.Internal.N:Endo[0] <b_a3jg>_R)
               :: base:Data.Semigroup.Internal.Dual
                    (base:Data.Semigroup.Internal.Endo b_a3jg)
                  ~R# (b_a3jg -> b_a3jg)))
        eta1_a55J

-- RHS size: {terms: 21, types: 22, coercions: 0, joins: 0/0}
$cfoldr'_a3j1 [Occ=LoopBreaker]
  :: forall e a b. (a -> b -> b) -> b -> BiTuple e a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 150 0}]
$cfoldr'_a3j1
  = \ (@e_a3ih)
      (@a_a3j4)
      (@b_a3j5)
      (f_a55X :: a_a3j4 -> b_a3j5 -> b_a3j5)
      (z0_a55Y :: b_a3j5)
      (xs_a55Z :: BiTuple e_a3ih a_a3j4) ->
      foldl
        @(BiTuple e_a3ih)
        (Main.$fFoldableBiTuple @e_a3ih)
        @(b_a3j5 -> b_a3j5)
        @a_a3j4
        (\ (ds_a560 :: b_a3j5 -> b_a3j5)
           (ds1_a561 :: a_a3j4)
           (v_a562 [OS=OneShot] :: b_a3j5) ->
           case v_a562 of z_a563 { __DEFAULT ->
           ds_a560 (f_a55X ds1_a561 z_a563)
           })
        (id @b_a3j5)
        xs_a55Z
        z0_a55Y

-- RHS size: {terms: 19, types: 19, coercions: 0, joins: 0/1}
$cfoldMap'_a3iF [Occ=LoopBreaker]
  :: forall e m a. Monoid m => (a -> m) -> BiTuple e a -> m
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 60] 170 0}]
$cfoldMap'_a3iF
  = \ (@e_a3ih)
      (@m_a3iI)
      (@a_a3iJ)
      ($dMonoid_a3iK :: Monoid m_a3iI)
      (eta_a569 :: a_a3iJ -> m_a3iI) ->
      let {
        $dSemigroup_a56a :: Semigroup m_a3iI
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dSemigroup_a56a = GHC.Base.$p1Monoid @m_a3iI $dMonoid_a3iK } in
      Data.Foldable.foldl'
        @(BiTuple e_a3ih)
        (Main.$fFoldableBiTuple @e_a3ih)
        @m_a3iI
        @a_a3iJ
        (\ (acc_a56b :: m_a3iI) (a1_a56c :: a_a3iJ) ->
           <> @m_a3iI $dSemigroup_a56a acc_a56b (eta_a569 a1_a56c))
        (mempty @m_a3iI $dMonoid_a3iK)

-- RHS size: {terms: 15, types: 21, coercions: 25, joins: 0/0}
$cproduct_a3l8 [Occ=LoopBreaker]
  :: forall e a. Num a => BiTuple e a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 120 60}]
$cproduct_a3l8
  = \ (@e_a3ih) (@a_a3lb) ($dNum_a3lc :: Num a_a3lb) ->
      ((\ (@(t_a56d :: * -> *))
          ($dFoldable_a56e :: Foldable t_a56d)
          (@a_a56f)
          ($dNum_a56g :: Num a_a56f) ->
          Data.Foldable.foldMap'
            @t_a56d
            $dFoldable_a56e
            @(base:Data.Semigroup.Internal.Product a_a56f)
            @a_a56f
            (base:Data.Semigroup.Internal.$fMonoidProduct @a_a56f $dNum_a56g)
            ((\ (ds_a56i :: a_a56f) -> ds_a56i)
             `cast` (<a_a56f>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Product[0]
                                              <a_a56f>_R)
                     :: (a_a56f -> a_a56f)
                        ~R# (a_a56f -> base:Data.Semigroup.Internal.Product a_a56f))))
       `cast` (forall (t :: <* -> *>_N).
               <Foldable t>_R
               %<'Many>_N ->_R forall (a :: <*>_N).
                               <Num a>_R
                               %<'Many>_N ->_R <t a>_R
                               %<'Many>_N ->_R base:Data.Semigroup.Internal.N:Product[0] <a>_R
               :: (forall {t :: * -> *} {a}.
                   (Foldable t, Num a) =>
                   t a -> base:Data.Semigroup.Internal.Product a)
                  ~R# (forall {t :: * -> *} {a}. (Foldable t, Num a) => t a -> a)))
        @(BiTuple e_a3ih)
        (Main.$fFoldableBiTuple @e_a3ih)
        @a_a3lb
        $dNum_a3lc

-- RHS size: {terms: 7, types: 10, coercions: 0, joins: 0/0}
$cfold_a3ij [Occ=LoopBreaker]
  :: forall e m. Monoid m => BiTuple e m -> m
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 40 0}]
$cfold_a3ij
  = \ (@e_a3ih) (@m_a3im) ($dMonoid_a3in :: Monoid m_a3im) ->
      foldMap
        @(BiTuple e_a3ih)
        (Main.$fFoldableBiTuple @e_a3ih)
        @m_a3im
        @m_a3im
        $dMonoid_a3in
        (id @m_a3im)
end Rec }

-- RHS size: {terms: 11, types: 14, coercions: 0, joins: 0/0}
$c<$_a3i3 :: forall e a b. a -> BiTuple e b -> BiTuple e a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)}]
$c<$_a3i3
  = \ (@e_a3hP)
      (@a_a3i6)
      (@b_a3i7)
      (z_a2cY :: a_a3i6)
      (ds_d4Pa :: BiTuple e_a3hP b_a3i7) ->
      case ds_d4Pa of { BiTuple a1_a2cZ _ [Occ=Dead] ->
      Main.BiTuple @e_a3hP @a_a3i6 a1_a2cZ z_a2cY
      }

-- RHS size: {terms: 12, types: 15, coercions: 0, joins: 0/0}
$cfmap_a3hR :: forall e a b. (a -> b) -> BiTuple e a -> BiTuple e b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 20] 40 10}]
$cfmap_a3hR
  = \ (@e_a3hP)
      (@a_a3hU)
      (@b_a3hV)
      (f_a2cV :: a_a3hU -> b_a3hV)
      (ds_d4P7 :: BiTuple e_a3hP a_a3hU) ->
      case ds_d4P7 of { BiTuple a1_a2cW a2_a2cX ->
      Main.BiTuple @e_a3hP @b_a3hV a1_a2cW (f_a2cV a2_a2cX)
      }

-- RHS size: {terms: 4, types: 5, coercions: 0, joins: 0/0}
Main.$fFunctorBiTuple [InlPrag=CONLIKE]
  :: forall e. Functor (BiTuple e)
[LclIdX[DFunId],
 Unf=DFun: \ (@e_a1x9) ->
       GHC.Base.C:Functor TYPE: BiTuple e_a1x9
                          $cfmap_a3hR @e_a1x9
                          $c<$_a3i3 @e_a1x9]
Main.$fFunctorBiTuple
  = \ (@e_a3hP) ->
      GHC.Base.C:Functor
        @(BiTuple e_a3hP) ($cfmap_a3hR @e_a3hP) ($c<$_a3i3 @e_a3hP)

Rec {
-- RHS size: {terms: 8, types: 9, coercions: 0, joins: 0/0}
Main.$fTraversableBiTuple [InlPrag=CONLIKE]
  :: forall fixed. Traversable (BiTuple fixed)
[LclIdX[DFunId],
 Unf=DFun: \ (@fixed_aUz) ->
       Data.Traversable.C:Traversable TYPE: BiTuple fixed_aUz
                                      Main.$fFunctorBiTuple @fixed_aUz
                                      Main.$fFoldableBiTuple @fixed_aUz
                                      $ctraverse_a4fd @fixed_aUz
                                      $csequenceA_a4ft @fixed_aUz
                                      $cmapM_a4fH @fixed_aUz
                                      $csequence_a4fX @fixed_aUz]
Main.$fTraversableBiTuple
  = \ (@fixed_a4f3) ->
      Data.Traversable.C:Traversable
        @(BiTuple fixed_a4f3)
        (Main.$fFunctorBiTuple @fixed_a4f3)
        (Main.$fFoldableBiTuple @fixed_a4f3)
        ($ctraverse_a4fd @fixed_a4f3)
        ($csequenceA_a4ft @fixed_a4f3)
        ($cmapM_a4fH @fixed_a4f3)
        ($csequence_a4fX @fixed_a4f3)

-- RHS size: {terms: 9, types: 14, coercions: 0, joins: 0/0}
$cmapM_a4fH [Occ=LoopBreaker]
  :: forall fixed (m :: * -> *) a b.
     Monad m =>
     (a -> m b) -> BiTuple fixed a -> m (BiTuple fixed b)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30] 50 0}]
$cmapM_a4fH
  = \ (@fixed_a4f3)
      (@(m_a4fK :: * -> *))
      (@a_a4fL)
      (@b_a4fM)
      ($dMonad_a4fN :: Monad m_a4fK) ->
      traverse
        @(BiTuple fixed_a4f3)
        (Main.$fTraversableBiTuple @fixed_a4f3)
        @m_a4fK
        @a_a4fL
        @b_a4fM
        (GHC.Base.$p1Monad @m_a4fK $dMonad_a4fN)

-- RHS size: {terms: 8, types: 15, coercions: 0, joins: 0/0}
$csequenceA_a4ft [Occ=LoopBreaker]
  :: forall fixed (f :: * -> *) a.
     Applicative f =>
     BiTuple fixed (f a) -> f (BiTuple fixed a)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 40 0}]
$csequenceA_a4ft
  = \ (@fixed_a4f3)
      (@(f_a4fw :: * -> *))
      (@a_a4fx)
      ($dApplicative_a4fy :: Applicative f_a4fw) ->
      traverse
        @(BiTuple fixed_a4f3)
        (Main.$fTraversableBiTuple @fixed_a4f3)
        @f_a4fw
        @(f_a4fw a_a4fx)
        @a_a4fx
        $dApplicative_a4fy
        (id @(f_a4fw a_a4fx))

-- RHS size: {terms: 8, types: 12, coercions: 0, joins: 0/0}
$csequence_a4fX [Occ=LoopBreaker]
  :: forall fixed (m :: * -> *) a.
     Monad m =>
     BiTuple fixed (m a) -> m (BiTuple fixed a)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30] 50 0}]
$csequence_a4fX
  = \ (@fixed_a4f3)
      (@(m_a4g0 :: * -> *))
      (@a_a4g1)
      ($dMonad_a4g2 :: Monad m_a4g0) ->
      sequenceA
        @(BiTuple fixed_a4f3)
        (Main.$fTraversableBiTuple @fixed_a4f3)
        @m_a4g0
        @a_a4g1
        (GHC.Base.$p1Monad @m_a4g0 $dMonad_a4g2)

-- RHS size: {terms: 19, types: 41, coercions: 0, joins: 0/2}
$ctraverse_a4fd [Occ=LoopBreaker]
  :: forall fixed (f :: * -> *) a b.
     Applicative f =>
     (a -> f b) -> BiTuple fixed a -> f (BiTuple fixed b)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 150 60}]
$ctraverse_a4fd
  = \ (@fixed_a4f3)
      (@(f_a4fg :: * -> *))
      (@a_a4fh)
      (@b_a4fi)
      ($dApplicative_a4fj :: Applicative f_a4fg)
      (eta1_a56N :: a_a4fh -> f_a4fg b_a4fi) ->
      let {
        f1_a56O
          :: BiTuple fixed_a4f3 (f_a4fg b_a4fi)
             -> f_a4fg (BiTuple fixed_a4f3 b_a4fi)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 30 0}]
        f1_a56O
          = sequenceA
              @(BiTuple fixed_a4f3)
              (Main.$fTraversableBiTuple @fixed_a4f3)
              @f_a4fg
              @b_a4fi
              $dApplicative_a4fj } in
      let {
        g_a56P
          :: BiTuple fixed_a4f3 a_a4fh -> BiTuple fixed_a4f3 (f_a4fg b_a4fi)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 50 0}]
        g_a56P
          = fmap
              @(BiTuple fixed_a4f3)
              (Data.Traversable.$p1Traversable
                 @(BiTuple fixed_a4f3) (Main.$fTraversableBiTuple @fixed_a4f3))
              @a_a4fh
              @(f_a4fg b_a4fi)
              eta1_a56N } in
      \ (x_a56Q :: BiTuple fixed_a4f3 a_a4fh) -> f1_a56O (g_a56P x_a56Q)
end Rec }

-- RHS size: {terms: 32, types: 27, coercions: 0, joins: 0/0}
$cshowsPrec_a3he
  :: forall e a. (Show e, Show a) => Int -> BiTuple e a -> ShowS
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 0 20] 350 0}]
$cshowsPrec_a3he
  = \ (@e_a3h9)
      (@a_a3ha)
      ($dShow_a3hb :: Show e_a3h9)
      ($dShow_a3hc :: Show a_a3ha)
      (a_a2cS :: Int)
      (ds_d4P0 :: BiTuple e_a3h9 a_a3ha) ->
      case ds_d4P0 of { BiTuple b1_a2cT b2_a2cU ->
      showParen
        (>= @Int GHC.Classes.$fOrdInt a_a2cS (GHC.Types.I# 11#))
        (. @String
           @String
           @String
           (showString (GHC.CString.unpackCString# "BiTuple "#))
           (. @String
              @String
              @String
              (showsPrec @e_a3h9 $dShow_a3hb (GHC.Types.I# 11#) b1_a2cT)
              (. @String
                 @String
                 @String
                 GHC.Show.showSpace
                 (showsPrec @a_a3ha $dShow_a3hc (GHC.Types.I# 11#) b2_a2cU))))
      }

Rec {
-- RHS size: {terms: 14, types: 15, coercions: 0, joins: 0/0}
Main.$fShowBiTuple [InlPrag=CONLIKE]
  :: forall e a. (Show e, Show a) => Show (BiTuple e a)
[LclIdX[DFunId],
 Unf=DFun: \ (@e_a1x2)
             (@a_a1x3)
             (v_B1 :: Show e_a1x2)
             (v_B2 :: Show a_a1x3) ->
       GHC.Show.C:Show TYPE: BiTuple e_a1x2 a_a1x3
                       $cshowsPrec_a3he @e_a1x2 @a_a1x3 v_B1 v_B2
                       $cshow_a3hz @e_a1x2 @a_a1x3 v_B1 v_B2
                       $cshowList_a3hG @e_a1x2 @a_a1x3 v_B1 v_B2]
Main.$fShowBiTuple
  = \ (@e_a3h9)
      (@a_a3ha)
      ($dShow_a3hb :: Show e_a3h9)
      ($dShow_a3hc :: Show a_a3ha) ->
      GHC.Show.C:Show
        @(BiTuple e_a3h9 a_a3ha)
        ($cshowsPrec_a3he @e_a3h9 @a_a3ha $dShow_a3hb $dShow_a3hc)
        ($cshow_a3hz @e_a3h9 @a_a3ha $dShow_a3hb $dShow_a3hc)
        ($cshowList_a3hG @e_a3h9 @a_a3ha $dShow_a3hb $dShow_a3hc)

-- RHS size: {terms: 17, types: 23, coercions: 0, joins: 0/1}
$cshowList_a3hG [Occ=LoopBreaker]
  :: forall e a. (Show e, Show a) => [BiTuple e a] -> ShowS
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 140 60}]
$cshowList_a3hG
  = \ (@e_a3h9)
      (@a_a3ha)
      ($dShow_a3hb :: Show e_a3h9)
      ($dShow_a3hc :: Show a_a3ha) ->
      let {
        $dShow_a56S :: Show (BiTuple e_a3h9 a_a3ha)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 30 0}]
        $dShow_a56S
          = Main.$fShowBiTuple @e_a3h9 @a_a3ha $dShow_a3hb $dShow_a3hc } in
      \ (ls_a56T :: [BiTuple e_a3h9 a_a3ha]) (s_a56U :: String) ->
        GHC.Show.showList__
          @(BiTuple e_a3h9 a_a3ha)
          (showsPrec @(BiTuple e_a3h9 a_a3ha) $dShow_a56S (GHC.Types.I# 0#))
          ls_a56T
          s_a56U

-- RHS size: {terms: 15, types: 19, coercions: 0, joins: 0/1}
$cshow_a3hz [Occ=LoopBreaker]
  :: forall e a. (Show e, Show a) => BiTuple e a -> String
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 110 60}]
$cshow_a3hz
  = \ (@e_a3h9)
      (@a_a3ha)
      ($dShow_a3hb :: Show e_a3h9)
      ($dShow_a3hc :: Show a_a3ha) ->
      let {
        $dShow_a56X :: Show (BiTuple e_a3h9 a_a3ha)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 30 0}]
        $dShow_a56X
          = Main.$fShowBiTuple @e_a3h9 @a_a3ha $dShow_a3hb $dShow_a3hc } in
      \ (x_a56Y :: BiTuple e_a3h9 a_a3ha) ->
        showsPrec
          @(BiTuple e_a3h9 a_a3ha)
          $dShow_a56X
          (GHC.Types.I# 0#)
          x_a56Y
          (GHC.Types.[] @Char)
end Rec }

-- RHS size: {terms: 21, types: 24, coercions: 0, joins: 0/0}
$c==_a3gP
  :: forall e a. (Eq e, Eq a) => BiTuple e a -> BiTuple e a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 20 20] 130 0}]
$c==_a3gP
  = \ (@e_a3gK)
      (@a_a3gL)
      ($dEq_a3gM :: Eq e_a3gK)
      ($dEq_a3gN :: Eq a_a3gL)
      (ds_d4OP :: BiTuple e_a3gK a_a3gL)
      (ds_d4OQ :: BiTuple e_a3gK a_a3gL) ->
      case ds_d4OP of { BiTuple a1_a2cO a2_a2cP ->
      case ds_d4OQ of { BiTuple b1_a2cQ b2_a2cR ->
      &&
        (== @e_a3gK $dEq_a3gM a1_a2cO b1_a2cQ)
        (== @a_a3gL $dEq_a3gN a2_a2cP b2_a2cR)
      }
      }

Rec {
-- RHS size: {terms: 11, types: 13, coercions: 0, joins: 0/0}
Main.$fEqBiTuple [InlPrag=CONLIKE]
  :: forall e a. (Eq e, Eq a) => Eq (BiTuple e a)
[LclIdX[DFunId],
 Unf=DFun: \ (@e_a1wV)
             (@a_a1wW)
             (v_B1 :: Eq e_a1wV)
             (v_B2 :: Eq a_a1wW) ->
       GHC.Classes.C:Eq TYPE: BiTuple e_a1wV a_a1wW
                        $c==_a3gP @e_a1wV @a_a1wW v_B1 v_B2
                        $c/=_a3h0 @e_a1wV @a_a1wW v_B1 v_B2]
Main.$fEqBiTuple
  = \ (@e_a3gK)
      (@a_a3gL)
      ($dEq_a3gM :: Eq e_a3gK)
      ($dEq_a3gN :: Eq a_a3gL) ->
      GHC.Classes.C:Eq
        @(BiTuple e_a3gK a_a3gL)
        ($c==_a3gP @e_a3gK @a_a3gL $dEq_a3gM $dEq_a3gN)
        ($c/=_a3h0 @e_a3gK @a_a3gL $dEq_a3gM $dEq_a3gN)

-- RHS size: {terms: 19, types: 22, coercions: 0, joins: 0/1}
$c/=_a3h0 [Occ=LoopBreaker]
  :: forall e a. (Eq e, Eq a) => BiTuple e a -> BiTuple e a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 120 60}]
$c/=_a3h0
  = \ (@e_a3gK)
      (@a_a3gL)
      ($dEq_a3gM :: Eq e_a3gK)
      ($dEq_a3gN :: Eq a_a3gL) ->
      let {
        $dEq_a570 :: Eq (BiTuple e_a3gK a_a3gL)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 30 0}]
        $dEq_a570
          = Main.$fEqBiTuple @e_a3gK @a_a3gL $dEq_a3gM $dEq_a3gN } in
      \ (x_a571 :: BiTuple e_a3gK a_a3gL)
        (y_a572 :: BiTuple e_a3gK a_a3gL) ->
        case == @(BiTuple e_a3gK a_a3gL) $dEq_a570 x_a571 y_a572 of {
          False -> GHC.Types.True;
          True -> GHC.Types.False
        }
end Rec }

-- RHS size: {terms: 12, types: 14, coercions: 0, joins: 0/0}
$cnull_a3fr :: forall e1 e2 a. TriEither e1 e2 a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [40] 30 30}]
$cnull_a3fr
  = \ (@e1_a3du)
      (@e2_a3dv)
      (@a_a3fu)
      (ds_d4OH :: TriEither e1_a3du e2_a3dv a_a3fu) ->
      case ds_d4OH of {
        LeftT _ [Occ=Dead] -> GHC.Types.True;
        MiddleT _ [Occ=Dead] -> GHC.Types.True;
        RightT _ [Occ=Dead] -> GHC.Types.False
      }

-- RHS size: {terms: 17, types: 19, coercions: 0, joins: 0/0}
$cfoldr_a3ed
  :: forall e1 e2 a b. (a -> b -> b) -> b -> TriEither e1 e2 a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 40] 60 0}]
$cfoldr_a3ed
  = \ (@e1_a3du)
      (@e2_a3dv)
      (@a_a3eg)
      (@b_a3eh)
      (f_a2cx :: a_a3eg -> b_a3eh -> b_a3eh)
      (z_a2cy :: b_a3eh)
      (ds_d4OG :: TriEither e1_a3du e2_a3dv a_a3eg) ->
      case ds_d4OG of {
        LeftT _ [Occ=Dead] -> z_a2cy;
        MiddleT _ [Occ=Dead] -> z_a2cy;
        RightT a1_a2cF -> f_a2cx a1_a2cF z_a2cy
      }

-- RHS size: {terms: 18, types: 21, coercions: 0, joins: 0/0}
$cfoldMap_a3dJ
  :: forall e1 e2 m a. Monoid m => (a -> m) -> TriEither e1 e2 a -> m
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 60 80] 90 0}]
$cfoldMap_a3dJ
  = \ (@e1_a3du)
      (@e2_a3dv)
      (@m_a3dM)
      (@a_a3dN)
      ($dMonoid_a3dO :: Monoid m_a3dM)
      (f_a2cG :: a_a3dN -> m_a3dM)
      (ds_d4OF :: TriEither e1_a3du e2_a3dv a_a3dN) ->
      case ds_d4OF of {
        LeftT _ [Occ=Dead] -> mempty @m_a3dM $dMonoid_a3dO;
        MiddleT _ [Occ=Dead] -> mempty @m_a3dM $dMonoid_a3dO;
        RightT a1_a2cL -> f_a2cG a1_a2cL
      }

Rec {
-- RHS size: {terms: 20, types: 39, coercions: 0, joins: 0/0}
Main.$fFoldableTriEither [InlPrag=CONLIKE]
  :: forall e1 e2. Foldable (TriEither e1 e2)
[LclIdX[DFunId],
 Unf=DFun: \ (@e1_a1wO) (@e2_a1wP) ->
       Data.Foldable.C:Foldable TYPE: TriEither e1_a1wO e2_a1wP
                                $cfold_a3dx @e1_a1wO @e2_a1wP
                                $cfoldMap_a3dJ @e1_a1wO @e2_a1wP
                                $cfoldMap'_a3dZ @e1_a1wO @e2_a1wP
                                $cfoldr_a3ed @e1_a1wO @e2_a1wP
                                $cfoldr'_a3en @e1_a1wO @e2_a1wP
                                $cfoldl_a3ez @e1_a1wO @e2_a1wP
                                $cfoldl'_a3eL @e1_a1wO @e2_a1wP
                                $cfoldr1_a3eX @e1_a1wO @e2_a1wP
                                $cfoldl1_a3f7 @e1_a1wO @e2_a1wP
                                $ctoList_a3fh @e1_a1wO @e2_a1wP
                                $cnull_a3fr @e1_a1wO @e2_a1wP
                                $clength_a3fA @e1_a1wO @e2_a1wP
                                $celem_a3fK @e1_a1wO @e2_a1wP
                                $cmaximum_a3fW @e1_a1wO @e2_a1wP
                                $cminimum_a3g8 @e1_a1wO @e2_a1wP
                                $csum_a3gk @e1_a1wO @e2_a1wP
                                $cproduct_a3gw @e1_a1wO @e2_a1wP]
Main.$fFoldableTriEither
  = \ (@e1_a3du) (@e2_a3dv) ->
      Data.Foldable.C:Foldable
        @(TriEither e1_a3du e2_a3dv)
        ($cfold_a3dx @e1_a3du @e2_a3dv)
        ($cfoldMap_a3dJ @e1_a3du @e2_a3dv)
        ($cfoldMap'_a3dZ @e1_a3du @e2_a3dv)
        ($cfoldr_a3ed @e1_a3du @e2_a3dv)
        ($cfoldr'_a3en @e1_a3du @e2_a3dv)
        ($cfoldl_a3ez @e1_a3du @e2_a3dv)
        ($cfoldl'_a3eL @e1_a3du @e2_a3dv)
        ($cfoldr1_a3eX @e1_a3du @e2_a3dv)
        ($cfoldl1_a3f7 @e1_a3du @e2_a3dv)
        ($ctoList_a3fh @e1_a3du @e2_a3dv)
        ($cnull_a3fr @e1_a3du @e2_a3dv)
        ($clength_a3fA @e1_a3du @e2_a3dv)
        ($celem_a3fK @e1_a3du @e2_a3dv)
        ($cmaximum_a3fW @e1_a3du @e2_a3dv)
        ($cminimum_a3g8 @e1_a3du @e2_a3dv)
        ($csum_a3gk @e1_a3du @e2_a3dv)
        ($cproduct_a3gw @e1_a3du @e2_a3dv)

-- RHS size: {terms: 16, types: 24, coercions: 25, joins: 0/0}
$csum_a3gk [Occ=LoopBreaker]
  :: forall e1 e2 a. Num a => TriEither e1 e2 a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 120 60}]
$csum_a3gk
  = \ (@e1_a3du) (@e2_a3dv) (@a_a3gn) ($dNum_a3go :: Num a_a3gn) ->
      ((\ (@(t_a4WR :: * -> *))
          ($dFoldable_a4WS :: Foldable t_a4WR)
          (@a_a4WT)
          ($dNum_a4WU :: Num a_a4WT) ->
          Data.Foldable.foldMap'
            @t_a4WR
            $dFoldable_a4WS
            @(base:Data.Semigroup.Internal.Sum a_a4WT)
            @a_a4WT
            (base:Data.Semigroup.Internal.$fMonoidSum @a_a4WT $dNum_a4WU)
            ((\ (ds_a52f :: a_a4WT) -> ds_a52f)
             `cast` (<a_a4WT>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Sum[0]
                                              <a_a4WT>_R)
                     :: (a_a4WT -> a_a4WT)
                        ~R# (a_a4WT -> base:Data.Semigroup.Internal.Sum a_a4WT))))
       `cast` (forall (t :: <* -> *>_N).
               <Foldable t>_R
               %<'Many>_N ->_R forall (a :: <*>_N).
                               <Num a>_R
                               %<'Many>_N ->_R <t a>_R
                               %<'Many>_N ->_R base:Data.Semigroup.Internal.N:Sum[0] <a>_R
               :: (forall {t :: * -> *} {a}.
                   (Foldable t, Num a) =>
                   t a -> base:Data.Semigroup.Internal.Sum a)
                  ~R# (forall {t :: * -> *} {a}. (Foldable t, Num a) => t a -> a)))
        @(TriEither e1_a3du e2_a3dv)
        (Main.$fFoldableTriEither @e1_a3du @e2_a3dv)
        @a_a3gn
        $dNum_a3go

-- RHS size: {terms: 26, types: 35, coercions: 8, joins: 0/2}
$cminimum_a3g8 [Occ=LoopBreaker]
  :: forall e1 e2 a. Ord a => TriEither e1 e2 a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 260 60}]
$cminimum_a3g8
  = \ (@e1_a3du) (@e2_a3dv) (@a_a3gb) ($dOrd_a3gc :: Ord a_a3gb) ->
      let {
        d_a52o :: a_a3gb
        [LclId,
         Str=b,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 110 0}]
        d_a52o
          = errorWithoutStackTrace
              @GHC.Types.LiftedRep
              @a_a3gb
              (GHC.Base.build
                 @Char
                 (\ (@b_a52t) ->
                    GHC.CString.unpackFoldrCString#
                      @b_a52t "minimum: empty structure"#)) } in
      let {
        g_a52v
          :: TriEither e1_a3du e2_a3dv a_a3gb
             -> base:Data.Functor.Utils.Min a_a3gb
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 80 0}]
        g_a52v
          = Data.Foldable.foldMap'
              @(TriEither e1_a3du e2_a3dv)
              (Main.$fFoldableTriEither @e1_a3du @e2_a3dv)
              @(base:Data.Functor.Utils.Min a_a3gb)
              @a_a3gb
              (base:Data.Functor.Utils.$fMonoidMin @a_a3gb $dOrd_a3gc)
              ((\ (ds_a53M :: a_a3gb) -> GHC.Maybe.Just @a_a3gb ds_a53M)
               `cast` (<a_a3gb>_R
                       %<'Many>_N ->_R Sym (base:Data.Functor.Utils.N:Min[0]) <a_a3gb>_N
                       :: (a_a3gb -> GHC.Maybe.Maybe a_a3gb)
                          ~R# (a_a3gb -> base:Data.Functor.Utils.Min a_a3gb))) } in
      \ (x_a53N :: TriEither e1_a3du e2_a3dv a_a3gb) ->
        case (g_a52v x_a53N)
             `cast` (base:Data.Functor.Utils.N:Min[0] <a_a3gb>_N
                     :: base:Data.Functor.Utils.Min a_a3gb ~R# GHC.Maybe.Maybe a_a3gb)
        of {
          GHC.Maybe.Nothing -> d_a52o;
          GHC.Maybe.Just v_a54h -> v_a54h
        }

-- RHS size: {terms: 26, types: 35, coercions: 8, joins: 0/2}
$cmaximum_a3fW [Occ=LoopBreaker]
  :: forall e1 e2 a. Ord a => TriEither e1 e2 a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 260 60}]
$cmaximum_a3fW
  = \ (@e1_a3du) (@e2_a3dv) (@a_a3fZ) ($dOrd_a3g0 :: Ord a_a3fZ) ->
      let {
        d_a54n :: a_a3fZ
        [LclId,
         Str=b,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 110 0}]
        d_a54n
          = errorWithoutStackTrace
              @GHC.Types.LiftedRep
              @a_a3fZ
              (GHC.Base.build
                 @Char
                 (\ (@b_a54o) ->
                    GHC.CString.unpackFoldrCString#
                      @b_a54o "maximum: empty structure"#)) } in
      let {
        g_a54p
          :: TriEither e1_a3du e2_a3dv a_a3fZ
             -> base:Data.Functor.Utils.Max a_a3fZ
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 80 0}]
        g_a54p
          = Data.Foldable.foldMap'
              @(TriEither e1_a3du e2_a3dv)
              (Main.$fFoldableTriEither @e1_a3du @e2_a3dv)
              @(base:Data.Functor.Utils.Max a_a3fZ)
              @a_a3fZ
              (base:Data.Functor.Utils.$fMonoidMax @a_a3fZ $dOrd_a3g0)
              ((\ (ds_a54r :: a_a3fZ) -> GHC.Maybe.Just @a_a3fZ ds_a54r)
               `cast` (<a_a3fZ>_R
                       %<'Many>_N ->_R Sym (base:Data.Functor.Utils.N:Max[0]) <a_a3fZ>_N
                       :: (a_a3fZ -> GHC.Maybe.Maybe a_a3fZ)
                          ~R# (a_a3fZ -> base:Data.Functor.Utils.Max a_a3fZ))) } in
      \ (x_a54s :: TriEither e1_a3du e2_a3dv a_a3fZ) ->
        case (g_a54p x_a54s)
             `cast` (base:Data.Functor.Utils.N:Max[0] <a_a3fZ>_N
                     :: base:Data.Functor.Utils.Max a_a3fZ ~R# GHC.Maybe.Maybe a_a3fZ)
        of {
          GHC.Maybe.Nothing -> d_a54n;
          GHC.Maybe.Just v_a54x -> v_a54x
        }

-- RHS size: {terms: 17, types: 23, coercions: 26, joins: 0/0}
$celem_a3fK [Occ=LoopBreaker]
  :: forall e1 e2 a. Eq a => a -> TriEither e1 e2 a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 130 60}]
$celem_a3fK
  = \ (@e1_a3du) (@e2_a3dv) (@a_a3fN) ($dEq_a3fO :: Eq a_a3fN) ->
      ((\ (@(t_a54z :: * -> *))
          ($dFoldable_a54A :: Foldable t_a54z)
          (@a_a54B)
          ($dEq_a54C :: Eq a_a54B)
          (eta_a54D :: a_a54B) ->
          foldMap
            @t_a54z
            $dFoldable_a54A
            @base:Data.Semigroup.Internal.Any
            @a_a54B
            base:Data.Semigroup.Internal.$fMonoidAny
            ((== @a_a54B $dEq_a54C eta_a54D)
             `cast` (<a_a54B>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Any[0])
                     :: (a_a54B -> Bool)
                        ~R# (a_a54B -> base:Data.Semigroup.Internal.Any))))
       `cast` (forall (t :: <* -> *>_N).
               <Foldable t>_R
               %<'Many>_N ->_R forall (a :: <*>_N).
                               <Eq a>_R
                               %<'Many>_N ->_R <a>_R
                               %<'Many>_N ->_R <t a>_R
                               %<'Many>_N ->_R base:Data.Semigroup.Internal.N:Any[0]
               :: (forall {t :: * -> *} {a}.
                   (Foldable t, Eq a) =>
                   a -> t a -> base:Data.Semigroup.Internal.Any)
                  ~R# (forall {t :: * -> *} {a}.
                       (Foldable t, Eq a) =>
                       a -> t a -> Bool)))
        @(TriEither e1_a3du e2_a3dv)
        (Main.$fFoldableTriEither @e1_a3du @e2_a3dv)
        @a_a3fN
        $dEq_a3fO

-- RHS size: {terms: 16, types: 14, coercions: 0, joins: 0/0}
$clength_a3fA [Occ=LoopBreaker]
  :: forall e1 e2 a. TriEither e1 e2 a -> Int
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=False, ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 91 0}]
$clength_a3fA
  = \ (@e1_a3du) (@e2_a3dv) (@a_a3fD) ->
      Data.Foldable.foldl'
        @(TriEither e1_a3du e2_a3dv)
        (Main.$fFoldableTriEither @e1_a3du @e2_a3dv)
        @Int
        @a_a3fD
        (\ (c_a54K :: Int) _ [Occ=Dead] ->
           case c_a54K of { GHC.Types.I# x_a54N ->
           GHC.Types.I# (GHC.Prim.+# x_a54N 1#)
           })
        (GHC.Types.I# 0#)

-- RHS size: {terms: 13, types: 20, coercions: 0, joins: 0/0}
$ctoList_a3fh [Occ=LoopBreaker]
  :: forall e1 e2 a. TriEither e1 e2 a -> [a]
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 70 40}]
$ctoList_a3fh
  = \ (@e1_a3du)
      (@e2_a3dv)
      (@a_a3fk)
      (t1_a54S :: TriEither e1_a3du e2_a3dv a_a3fk) ->
      GHC.Base.build
        @a_a3fk
        (\ (@b_a54T)
           (c_a54U [OS=OneShot] :: a_a3fk -> b_a54T -> b_a54T)
           (n_a54V [OS=OneShot] :: b_a54T) ->
           foldr
             @(TriEither e1_a3du e2_a3dv)
             (Main.$fFoldableTriEither @e1_a3du @e2_a3dv)
             @a_a3fk
             @b_a54T
             c_a54U
             n_a54V
             t1_a54S)

-- RHS size: {terms: 29, types: 34, coercions: 0, joins: 0/0}
$cfoldl1_a3f7 [Occ=LoopBreaker]
  :: forall e1 e2 a. (a -> a -> a) -> TriEither e1 e2 a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0] 260 0}]
$cfoldl1_a3f7
  = \ (@e1_a3du)
      (@e2_a3dv)
      (@a_a3fa)
      (f_a54Z :: a_a3fa -> a_a3fa -> a_a3fa)
      (xs_a550 :: TriEither e1_a3du e2_a3dv a_a3fa) ->
      case foldl
             @(TriEither e1_a3du e2_a3dv)
             (Main.$fFoldableTriEither @e1_a3du @e2_a3dv)
             @(GHC.Maybe.Maybe a_a3fa)
             @a_a3fa
             (\ (m_a551 :: GHC.Maybe.Maybe a_a3fa) (y_a552 :: a_a3fa) ->
                GHC.Maybe.Just
                  @a_a3fa
                  (case m_a551 of {
                     GHC.Maybe.Nothing -> y_a552;
                     GHC.Maybe.Just x_a555 -> f_a54Z x_a555 y_a552
                   }))
             (GHC.Maybe.Nothing @a_a3fa)
             xs_a550
      of {
        GHC.Maybe.Nothing ->
          errorWithoutStackTrace
            @GHC.Types.LiftedRep
            @a_a3fa
            (GHC.Base.build
               @Char
               (\ (@b_a558) ->
                  GHC.CString.unpackFoldrCString#
                    @b_a558 "foldl1: empty structure"#));
        GHC.Maybe.Just v_a559 -> v_a559
      }

-- RHS size: {terms: 29, types: 34, coercions: 0, joins: 0/0}
$cfoldr1_a3eX [Occ=LoopBreaker]
  :: forall e1 e2 a. (a -> a -> a) -> TriEither e1 e2 a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0] 260 0}]
$cfoldr1_a3eX
  = \ (@e1_a3du)
      (@e2_a3dv)
      (@a_a3f0)
      (f_a55f :: a_a3f0 -> a_a3f0 -> a_a3f0)
      (xs_a55g :: TriEither e1_a3du e2_a3dv a_a3f0) ->
      case foldr
             @(TriEither e1_a3du e2_a3dv)
             (Main.$fFoldableTriEither @e1_a3du @e2_a3dv)
             @a_a3f0
             @(GHC.Maybe.Maybe a_a3f0)
             (\ (x_a55h :: a_a3f0) (m_a55i :: GHC.Maybe.Maybe a_a3f0) ->
                GHC.Maybe.Just
                  @a_a3f0
                  (case m_a55i of {
                     GHC.Maybe.Nothing -> x_a55h;
                     GHC.Maybe.Just y_a55l -> f_a55f x_a55h y_a55l
                   }))
             (GHC.Maybe.Nothing @a_a3f0)
             xs_a55g
      of {
        GHC.Maybe.Nothing ->
          errorWithoutStackTrace
            @GHC.Types.LiftedRep
            @a_a3f0
            (GHC.Base.build
               @Char
               (\ (@b_a55o) ->
                  GHC.CString.unpackFoldrCString#
                    @b_a55o "foldr1: empty structure"#));
        GHC.Maybe.Just v_a55p -> v_a55p
      }

-- RHS size: {terms: 22, types: 26, coercions: 0, joins: 0/0}
$cfoldl'_a3eL [Occ=LoopBreaker]
  :: forall e1 e2 b a. (b -> a -> b) -> b -> TriEither e1 e2 a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 150 0}]
$cfoldl'_a3eL
  = \ (@e1_a3du)
      (@e2_a3dv)
      (@b_a3eO)
      (@a_a3eP)
      (f_a55w :: b_a3eO -> a_a3eP -> b_a3eO)
      (z0_a55x :: b_a3eO)
      (xs_a55y :: TriEither e1_a3du e2_a3dv a_a3eP) ->
      foldr
        @(TriEither e1_a3du e2_a3dv)
        (Main.$fFoldableTriEither @e1_a3du @e2_a3dv)
        @a_a3eP
        @(b_a3eO -> b_a3eO)
        (\ (ds_a55z :: a_a3eP)
           (ds1_a55A :: b_a3eO -> b_a3eO)
           (v_a55B [OS=OneShot] :: b_a3eO) ->
           case v_a55B of z_a55C { __DEFAULT ->
           ds1_a55A (f_a55w z_a55C ds_a55z)
           })
        (id @b_a3eO)
        xs_a55y
        z0_a55x

-- RHS size: {terms: 18, types: 26, coercions: 10, joins: 0/0}
$cfoldl_a3ez [Occ=LoopBreaker]
  :: forall e1 e2 b a. (b -> a -> b) -> b -> TriEither e1 e2 a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 130 0}]
$cfoldl_a3ez
  = \ (@e1_a3du)
      (@e2_a3dv)
      (@b_a3eC)
      (@a_a3eD)
      (eta_a55I :: b_a3eC -> a_a3eD -> b_a3eC)
      (eta1_a55J :: b_a3eC)
      (eta2_a55K :: TriEither e1_a3du e2_a3dv a_a3eD) ->
      ((foldMap
          @(TriEither e1_a3du e2_a3dv)
          (Main.$fFoldableTriEither @e1_a3du @e2_a3dv)
          @(base:Data.Semigroup.Internal.Dual
              (base:Data.Semigroup.Internal.Endo b_a3eC))
          @a_a3eD
          (base:Data.Semigroup.Internal.$fMonoidDual
             @(base:Data.Semigroup.Internal.Endo b_a3eC)
             (base:Data.Semigroup.Internal.$fMonoidEndo @b_a3eC))
          ((\ (x_a55N :: a_a3eD) (y_a55O :: b_a3eC) ->
              eta_a55I y_a55O x_a55N)
           `cast` (<a_a3eD>_R
                   %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Dual[0]
                                            (base:Data.Semigroup.Internal.N:Endo[0] <b_a3eC>_R))
                   :: (a_a3eD -> b_a3eC -> b_a3eC)
                      ~R# (a_a3eD
                           -> base:Data.Semigroup.Internal.Dual
                                (base:Data.Semigroup.Internal.Endo b_a3eC))))
          eta2_a55K)
       `cast` (base:Data.Semigroup.Internal.N:Dual[0]
                   (base:Data.Semigroup.Internal.N:Endo[0] <b_a3eC>_R)
               :: base:Data.Semigroup.Internal.Dual
                    (base:Data.Semigroup.Internal.Endo b_a3eC)
                  ~R# (b_a3eC -> b_a3eC)))
        eta1_a55J

-- RHS size: {terms: 22, types: 26, coercions: 0, joins: 0/0}
$cfoldr'_a3en [Occ=LoopBreaker]
  :: forall e1 e2 a b. (a -> b -> b) -> b -> TriEither e1 e2 a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 150 0}]
$cfoldr'_a3en
  = \ (@e1_a3du)
      (@e2_a3dv)
      (@a_a3eq)
      (@b_a3er)
      (f_a55X :: a_a3eq -> b_a3er -> b_a3er)
      (z0_a55Y :: b_a3er)
      (xs_a55Z :: TriEither e1_a3du e2_a3dv a_a3eq) ->
      foldl
        @(TriEither e1_a3du e2_a3dv)
        (Main.$fFoldableTriEither @e1_a3du @e2_a3dv)
        @(b_a3er -> b_a3er)
        @a_a3eq
        (\ (ds_a560 :: b_a3er -> b_a3er)
           (ds1_a561 :: a_a3eq)
           (v_a562 [OS=OneShot] :: b_a3er) ->
           case v_a562 of z_a563 { __DEFAULT ->
           ds_a560 (f_a55X ds1_a561 z_a563)
           })
        (id @b_a3er)
        xs_a55Z
        z0_a55Y

-- RHS size: {terms: 20, types: 22, coercions: 0, joins: 0/1}
$cfoldMap'_a3dZ [Occ=LoopBreaker]
  :: forall e1 e2 m a. Monoid m => (a -> m) -> TriEither e1 e2 a -> m
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 60] 170 0}]
$cfoldMap'_a3dZ
  = \ (@e1_a3du)
      (@e2_a3dv)
      (@m_a3e2)
      (@a_a3e3)
      ($dMonoid_a3e4 :: Monoid m_a3e2)
      (eta_a569 :: a_a3e3 -> m_a3e2) ->
      let {
        $dSemigroup_a56a :: Semigroup m_a3e2
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dSemigroup_a56a = GHC.Base.$p1Monoid @m_a3e2 $dMonoid_a3e4 } in
      Data.Foldable.foldl'
        @(TriEither e1_a3du e2_a3dv)
        (Main.$fFoldableTriEither @e1_a3du @e2_a3dv)
        @m_a3e2
        @a_a3e3
        (\ (acc_a56b :: m_a3e2) (a1_a56c :: a_a3e3) ->
           <> @m_a3e2 $dSemigroup_a56a acc_a56b (eta_a569 a1_a56c))
        (mempty @m_a3e2 $dMonoid_a3e4)

-- RHS size: {terms: 16, types: 24, coercions: 25, joins: 0/0}
$cproduct_a3gw [Occ=LoopBreaker]
  :: forall e1 e2 a. Num a => TriEither e1 e2 a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 120 60}]
$cproduct_a3gw
  = \ (@e1_a3du) (@e2_a3dv) (@a_a3gz) ($dNum_a3gA :: Num a_a3gz) ->
      ((\ (@(t_a56d :: * -> *))
          ($dFoldable_a56e :: Foldable t_a56d)
          (@a_a56f)
          ($dNum_a56g :: Num a_a56f) ->
          Data.Foldable.foldMap'
            @t_a56d
            $dFoldable_a56e
            @(base:Data.Semigroup.Internal.Product a_a56f)
            @a_a56f
            (base:Data.Semigroup.Internal.$fMonoidProduct @a_a56f $dNum_a56g)
            ((\ (ds_a56i :: a_a56f) -> ds_a56i)
             `cast` (<a_a56f>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Product[0]
                                              <a_a56f>_R)
                     :: (a_a56f -> a_a56f)
                        ~R# (a_a56f -> base:Data.Semigroup.Internal.Product a_a56f))))
       `cast` (forall (t :: <* -> *>_N).
               <Foldable t>_R
               %<'Many>_N ->_R forall (a :: <*>_N).
                               <Num a>_R
                               %<'Many>_N ->_R <t a>_R
                               %<'Many>_N ->_R base:Data.Semigroup.Internal.N:Product[0] <a>_R
               :: (forall {t :: * -> *} {a}.
                   (Foldable t, Num a) =>
                   t a -> base:Data.Semigroup.Internal.Product a)
                  ~R# (forall {t :: * -> *} {a}. (Foldable t, Num a) => t a -> a)))
        @(TriEither e1_a3du e2_a3dv)
        (Main.$fFoldableTriEither @e1_a3du @e2_a3dv)
        @a_a3gz
        $dNum_a3gA

-- RHS size: {terms: 8, types: 13, coercions: 0, joins: 0/0}
$cfold_a3dx [Occ=LoopBreaker]
  :: forall e1 e2 m. Monoid m => TriEither e1 e2 m -> m
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 40 0}]
$cfold_a3dx
  = \ (@e1_a3du)
      (@e2_a3dv)
      (@m_a3dA)
      ($dMonoid_a3dB :: Monoid m_a3dA) ->
      foldMap
        @(TriEither e1_a3du e2_a3dv)
        (Main.$fFoldableTriEither @e1_a3du @e2_a3dv)
        @m_a3dA
        @m_a3dA
        $dMonoid_a3dB
        (id @m_a3dA)
end Rec }

-- RHS size: {terms: 17, types: 25, coercions: 0, joins: 0/0}
$c<$_a3d6
  :: forall e1 e2 a b. a -> TriEither e1 e2 b -> TriEither e1 e2 a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 60] 60 30}]
$c<$_a3d6
  = \ (@e1_a3cH)
      (@e2_a3cI)
      (@a_a3d9)
      (@b_a3da)
      (z_a2cr :: a_a3d9)
      (ds_d4OB :: TriEither e1_a3cH e2_a3cI b_a3da) ->
      case ds_d4OB of {
        LeftT a1_a2cs -> Main.LeftT @e1_a3cH @e2_a3cI @a_a3d9 a1_a2cs;
        MiddleT a1_a2cu -> Main.MiddleT @e1_a3cH @e2_a3cI @a_a3d9 a1_a2cu;
        RightT _ [Occ=Dead] -> Main.RightT @e1_a3cH @e2_a3cI @a_a3d9 z_a2cr
      }

-- RHS size: {terms: 18, types: 26, coercions: 0, joins: 0/0}
$cfmap_a3cK
  :: forall e1 e2 a b.
     (a -> b) -> TriEither e1 e2 a -> TriEither e1 e2 b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 60] 80 30}]
$cfmap_a3cK
  = \ (@e1_a3cH)
      (@e2_a3cI)
      (@a_a3cN)
      (@b_a3cO)
      (f_a2cl :: a_a3cN -> b_a3cO)
      (ds_d4Ox :: TriEither e1_a3cH e2_a3cI a_a3cN) ->
      case ds_d4Ox of {
        LeftT a1_a2cm -> Main.LeftT @e1_a3cH @e2_a3cI @b_a3cO a1_a2cm;
        MiddleT a1_a2co -> Main.MiddleT @e1_a3cH @e2_a3cI @b_a3cO a1_a2co;
        RightT a1_a2cq ->
          Main.RightT @e1_a3cH @e2_a3cI @b_a3cO (f_a2cl a1_a2cq)
      }

-- RHS size: {terms: 5, types: 9, coercions: 0, joins: 0/0}
Main.$fFunctorTriEither [InlPrag=CONLIKE]
  :: forall e1 e2. Functor (TriEither e1 e2)
[LclIdX[DFunId],
 Unf=DFun: \ (@e1_a1wH) (@e2_a1wI) ->
       GHC.Base.C:Functor TYPE: TriEither e1_a1wH e2_a1wI
                          $cfmap_a3cK @e1_a1wH @e2_a1wI
                          $c<$_a3d6 @e1_a1wH @e2_a1wI]
Main.$fFunctorTriEither
  = \ (@e1_a3cH) (@e2_a3cI) ->
      GHC.Base.C:Functor
        @(TriEither e1_a3cH e2_a3cI)
        ($cfmap_a3cK @e1_a3cH @e2_a3cI)
        ($c<$_a3d6 @e1_a3cH @e2_a3cI)

Rec {
-- RHS size: {terms: 9, types: 17, coercions: 0, joins: 0/0}
Main.$fTraversableTriEither [InlPrag=CONLIKE]
  :: forall fixed1 fixed2. Traversable (TriEither fixed1 fixed2)
[LclIdX[DFunId],
 Unf=DFun: \ (@fixed1_aUx) (@fixed2_aUy) ->
       Data.Traversable.C:Traversable TYPE: TriEither
                                              fixed1_aUx fixed2_aUy
                                      Main.$fFunctorTriEither @fixed1_aUx @fixed2_aUy
                                      Main.$fFoldableTriEither @fixed1_aUx @fixed2_aUy
                                      $ctraverse_a4e3 @fixed1_aUx @fixed2_aUy
                                      $csequenceA_a4ej @fixed1_aUx @fixed2_aUy
                                      $cmapM_a4ex @fixed1_aUx @fixed2_aUy
                                      $csequence_a4eN @fixed1_aUx @fixed2_aUy]
Main.$fTraversableTriEither
  = \ (@fixed1_a4dS) (@fixed2_a4dT) ->
      Data.Traversable.C:Traversable
        @(TriEither fixed1_a4dS fixed2_a4dT)
        (Main.$fFunctorTriEither @fixed1_a4dS @fixed2_a4dT)
        (Main.$fFoldableTriEither @fixed1_a4dS @fixed2_a4dT)
        ($ctraverse_a4e3 @fixed1_a4dS @fixed2_a4dT)
        ($csequenceA_a4ej @fixed1_a4dS @fixed2_a4dT)
        ($cmapM_a4ex @fixed1_a4dS @fixed2_a4dT)
        ($csequence_a4eN @fixed1_a4dS @fixed2_a4dT)

-- RHS size: {terms: 10, types: 17, coercions: 0, joins: 0/0}
$cmapM_a4ex [Occ=LoopBreaker]
  :: forall fixed1 fixed2 (m :: * -> *) a b.
     Monad m =>
     (a -> m b)
     -> TriEither fixed1 fixed2 a -> m (TriEither fixed1 fixed2 b)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30] 50 0}]
$cmapM_a4ex
  = \ (@fixed1_a4dS)
      (@fixed2_a4dT)
      (@(m_a4eA :: * -> *))
      (@a_a4eB)
      (@b_a4eC)
      ($dMonad_a4eD :: Monad m_a4eA) ->
      traverse
        @(TriEither fixed1_a4dS fixed2_a4dT)
        (Main.$fTraversableTriEither @fixed1_a4dS @fixed2_a4dT)
        @m_a4eA
        @a_a4eB
        @b_a4eC
        (GHC.Base.$p1Monad @m_a4eA $dMonad_a4eD)

-- RHS size: {terms: 9, types: 18, coercions: 0, joins: 0/0}
$csequenceA_a4ej [Occ=LoopBreaker]
  :: forall fixed1 fixed2 (f :: * -> *) a.
     Applicative f =>
     TriEither fixed1 fixed2 (f a) -> f (TriEither fixed1 fixed2 a)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 40 0}]
$csequenceA_a4ej
  = \ (@fixed1_a4dS)
      (@fixed2_a4dT)
      (@(f_a4em :: * -> *))
      (@a_a4en)
      ($dApplicative_a4eo :: Applicative f_a4em) ->
      traverse
        @(TriEither fixed1_a4dS fixed2_a4dT)
        (Main.$fTraversableTriEither @fixed1_a4dS @fixed2_a4dT)
        @f_a4em
        @(f_a4em a_a4en)
        @a_a4en
        $dApplicative_a4eo
        (id @(f_a4em a_a4en))

-- RHS size: {terms: 9, types: 15, coercions: 0, joins: 0/0}
$csequence_a4eN [Occ=LoopBreaker]
  :: forall fixed1 fixed2 (m :: * -> *) a.
     Monad m =>
     TriEither fixed1 fixed2 (m a) -> m (TriEither fixed1 fixed2 a)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30] 50 0}]
$csequence_a4eN
  = \ (@fixed1_a4dS)
      (@fixed2_a4dT)
      (@(m_a4eQ :: * -> *))
      (@a_a4eR)
      ($dMonad_a4eS :: Monad m_a4eQ) ->
      sequenceA
        @(TriEither fixed1_a4dS fixed2_a4dT)
        (Main.$fTraversableTriEither @fixed1_a4dS @fixed2_a4dT)
        @m_a4eQ
        @a_a4eR
        (GHC.Base.$p1Monad @m_a4eQ $dMonad_a4eS)

-- RHS size: {terms: 20, types: 52, coercions: 0, joins: 0/2}
$ctraverse_a4e3 [Occ=LoopBreaker]
  :: forall fixed1 fixed2 (f :: * -> *) a b.
     Applicative f =>
     (a -> f b)
     -> TriEither fixed1 fixed2 a -> f (TriEither fixed1 fixed2 b)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 150 60}]
$ctraverse_a4e3
  = \ (@fixed1_a4dS)
      (@fixed2_a4dT)
      (@(f_a4e6 :: * -> *))
      (@a_a4e7)
      (@b_a4e8)
      ($dApplicative_a4e9 :: Applicative f_a4e6)
      (eta1_a56N :: a_a4e7 -> f_a4e6 b_a4e8) ->
      let {
        f1_a56O
          :: TriEither fixed1_a4dS fixed2_a4dT (f_a4e6 b_a4e8)
             -> f_a4e6 (TriEither fixed1_a4dS fixed2_a4dT b_a4e8)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 30 0}]
        f1_a56O
          = sequenceA
              @(TriEither fixed1_a4dS fixed2_a4dT)
              (Main.$fTraversableTriEither @fixed1_a4dS @fixed2_a4dT)
              @f_a4e6
              @b_a4e8
              $dApplicative_a4e9 } in
      let {
        g_a56P
          :: TriEither fixed1_a4dS fixed2_a4dT a_a4e7
             -> TriEither fixed1_a4dS fixed2_a4dT (f_a4e6 b_a4e8)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 50 0}]
        g_a56P
          = fmap
              @(TriEither fixed1_a4dS fixed2_a4dT)
              (Data.Traversable.$p1Traversable
                 @(TriEither fixed1_a4dS fixed2_a4dT)
                 (Main.$fTraversableTriEither @fixed1_a4dS @fixed2_a4dT))
              @a_a4e7
              @(f_a4e6 b_a4e8)
              eta1_a56N } in
      \ (x_a56Q :: TriEither fixed1_a4dS fixed2_a4dT a_a4e7) ->
        f1_a56O (g_a56P x_a56Q)
end Rec }

-- RHS size: {terms: 58, types: 36, coercions: 0, joins: 0/0}
$cshowsPrec_a3bY
  :: forall e1 e2 a.
     (Show e1, Show e2, Show a) =>
     Int -> TriEither e1 e2 a -> ShowS
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 30 0 500] 720 0}]
$cshowsPrec_a3bY
  = \ (@e1_a3bR)
      (@e2_a3bS)
      (@a_a3bT)
      ($dShow_a3bU :: Show e1_a3bR)
      ($dShow_a3bV :: Show e2_a3bS)
      ($dShow_a3bW :: Show a_a3bT)
      (a_a2cf :: Int)
      (ds_d4Oo :: TriEither e1_a3bR e2_a3bS a_a3bT) ->
      case ds_d4Oo of {
        LeftT b1_a2cg ->
          showParen
            (>= @Int GHC.Classes.$fOrdInt a_a2cf (GHC.Types.I# 11#))
            (. @String
               @String
               @String
               (showString (GHC.CString.unpackCString# "LeftT "#))
               (showsPrec @e1_a3bR $dShow_a3bU (GHC.Types.I# 11#) b1_a2cg));
        MiddleT b1_a2ci ->
          showParen
            (>= @Int GHC.Classes.$fOrdInt a_a2cf (GHC.Types.I# 11#))
            (. @String
               @String
               @String
               (showString (GHC.CString.unpackCString# "MiddleT "#))
               (showsPrec @e2_a3bS $dShow_a3bV (GHC.Types.I# 11#) b1_a2ci));
        RightT b1_a2ck ->
          showParen
            (>= @Int GHC.Classes.$fOrdInt a_a2cf (GHC.Types.I# 11#))
            (. @String
               @String
               @String
               (showString (GHC.CString.unpackCString# "RightT "#))
               (showsPrec @a_a3bT $dShow_a3bW (GHC.Types.I# 11#) b1_a2ck))
      }

Rec {
-- RHS size: {terms: 19, types: 22, coercions: 0, joins: 0/0}
Main.$fShowTriEither [InlPrag=CONLIKE]
  :: forall e1 e2 a.
     (Show e1, Show e2, Show a) =>
     Show (TriEither e1 e2 a)
[LclIdX[DFunId],
 Unf=DFun: \ (@e1_a1wz)
             (@e2_a1wA)
             (@a_a1wB)
             (v_B1 :: Show e1_a1wz)
             (v_B2 :: Show e2_a1wA)
             (v_B3 :: Show a_a1wB) ->
       GHC.Show.C:Show TYPE: TriEither e1_a1wz e2_a1wA a_a1wB
                       $cshowsPrec_a3bY @e1_a1wz @e2_a1wA @a_a1wB v_B1 v_B2 v_B3
                       $cshow_a3cr @e1_a1wz @e2_a1wA @a_a1wB v_B1 v_B2 v_B3
                       $cshowList_a3cy @e1_a1wz @e2_a1wA @a_a1wB v_B1 v_B2 v_B3]
Main.$fShowTriEither
  = \ (@e1_a3bR)
      (@e2_a3bS)
      (@a_a3bT)
      ($dShow_a3bU :: Show e1_a3bR)
      ($dShow_a3bV :: Show e2_a3bS)
      ($dShow_a3bW :: Show a_a3bT) ->
      GHC.Show.C:Show
        @(TriEither e1_a3bR e2_a3bS a_a3bT)
        ($cshowsPrec_a3bY
           @e1_a3bR @e2_a3bS @a_a3bT $dShow_a3bU $dShow_a3bV $dShow_a3bW)
        ($cshow_a3cr
           @e1_a3bR @e2_a3bS @a_a3bT $dShow_a3bU $dShow_a3bV $dShow_a3bW)
        ($cshowList_a3cy
           @e1_a3bR @e2_a3bS @a_a3bT $dShow_a3bU $dShow_a3bV $dShow_a3bW)

-- RHS size: {terms: 20, types: 31, coercions: 0, joins: 0/1}
$cshowList_a3cy [Occ=LoopBreaker]
  :: forall e1 e2 a.
     (Show e1, Show e2, Show a) =>
     [TriEither e1 e2 a] -> ShowS
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0] 150 60}]
$cshowList_a3cy
  = \ (@e1_a3bR)
      (@e2_a3bS)
      (@a_a3bT)
      ($dShow_a3bU :: Show e1_a3bR)
      ($dShow_a3bV :: Show e2_a3bS)
      ($dShow_a3bW :: Show a_a3bT) ->
      let {
        $dShow_a56S :: Show (TriEither e1_a3bR e2_a3bS a_a3bT)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 40 0}]
        $dShow_a56S
          = Main.$fShowTriEither
              @e1_a3bR @e2_a3bS @a_a3bT $dShow_a3bU $dShow_a3bV $dShow_a3bW } in
      \ (ls_a56T :: [TriEither e1_a3bR e2_a3bS a_a3bT])
        (s_a56U :: String) ->
        GHC.Show.showList__
          @(TriEither e1_a3bR e2_a3bS a_a3bT)
          (showsPrec
             @(TriEither e1_a3bR e2_a3bS a_a3bT) $dShow_a56S (GHC.Types.I# 0#))
          ls_a56T
          s_a56U

-- RHS size: {terms: 18, types: 26, coercions: 0, joins: 0/1}
$cshow_a3cr [Occ=LoopBreaker]
  :: forall e1 e2 a.
     (Show e1, Show e2, Show a) =>
     TriEither e1 e2 a -> String
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0] 120 60}]
$cshow_a3cr
  = \ (@e1_a3bR)
      (@e2_a3bS)
      (@a_a3bT)
      ($dShow_a3bU :: Show e1_a3bR)
      ($dShow_a3bV :: Show e2_a3bS)
      ($dShow_a3bW :: Show a_a3bT) ->
      let {
        $dShow_a56X :: Show (TriEither e1_a3bR e2_a3bS a_a3bT)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 40 0}]
        $dShow_a56X
          = Main.$fShowTriEither
              @e1_a3bR @e2_a3bS @a_a3bT $dShow_a3bU $dShow_a3bV $dShow_a3bW } in
      \ (x_a56Y :: TriEither e1_a3bR e2_a3bS a_a3bT) ->
        showsPrec
          @(TriEither e1_a3bR e2_a3bS a_a3bT)
          $dShow_a56X
          (GHC.Types.I# 0#)
          x_a56Y
          (GHC.Types.[] @Char)
end Rec }

-- RHS size: {terms: 64, types: 63, coercions: 0, joins: 0/0}
$c==_a3bb
  :: forall e1 e2 a.
     (Eq e1, Eq e2, Eq a) =>
     TriEither e1 e2 a -> TriEither e1 e2 a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 30 340 210] 513 10}]
$c==_a3bb
  = \ (@e1_a3b4)
      (@e2_a3b5)
      (@a_a3b6)
      ($dEq_a3b7 :: Eq e1_a3b4)
      ($dEq_a3b8 :: Eq e2_a3b5)
      ($dEq_a3b9 :: Eq a_a3b6)
      (a_a2c5 :: TriEither e1_a3b4 e2_a3b5 a_a3b6)
      (b_a2c6 :: TriEither e1_a3b4 e2_a3b5 a_a3b6) ->
      case case GHC.Prim.dataToTag#
                  @(TriEither e1_a3b4 e2_a3b5 a_a3b6) a_a2c5
           of a#_a2c7
           { __DEFAULT ->
           case GHC.Prim.dataToTag# @(TriEither e1_a3b4 e2_a3b5 a_a3b6) b_a2c6
           of b#_a2c8
           { __DEFAULT ->
           GHC.Prim./=# a#_a2c7 b#_a2c8
           }
           }
      of ds_d4NX
      { __DEFAULT ->
      case ds_d4NX of {
        __DEFAULT ->
          case a_a2c5 of {
            LeftT a1_a2c9 ->
              case b_a2c6 of {
                __DEFAULT ->
                  case Control.Exception.Base.patError
                         @GHC.Types.LiftedRep @() "Gy08.hs:38:69-70|case"#
                  of {
                  };
                LeftT b1_a2ca -> == @e1_a3b4 $dEq_a3b7 a1_a2c9 b1_a2ca
              };
            MiddleT a1_a2cb ->
              case b_a2c6 of {
                __DEFAULT ->
                  case Control.Exception.Base.patError
                         @GHC.Types.LiftedRep @() "Gy08.hs:38:69-70|case"#
                  of {
                  };
                MiddleT b1_a2cc -> == @e2_a3b5 $dEq_a3b8 a1_a2cb b1_a2cc
              };
            RightT a1_a2cd ->
              case b_a2c6 of {
                __DEFAULT ->
                  case Control.Exception.Base.patError
                         @GHC.Types.LiftedRep @() "Gy08.hs:38:69-70|case"#
                  of {
                  };
                RightT b1_a2ce -> == @a_a3b6 $dEq_a3b9 a1_a2cd b1_a2ce
              }
          };
        1# -> GHC.Types.False
      }
      }

Rec {
-- RHS size: {terms: 15, types: 19, coercions: 0, joins: 0/0}
Main.$fEqTriEither [InlPrag=CONLIKE]
  :: forall e1 e2 a. (Eq e1, Eq e2, Eq a) => Eq (TriEither e1 e2 a)
[LclIdX[DFunId],
 Unf=DFun: \ (@e1_a1wr)
             (@e2_a1ws)
             (@a_a1wt)
             (v_B1 :: Eq e1_a1wr)
             (v_B2 :: Eq e2_a1ws)
             (v_B3 :: Eq a_a1wt) ->
       GHC.Classes.C:Eq TYPE: TriEither e1_a1wr e2_a1ws a_a1wt
                        $c==_a3bb @e1_a1wr @e2_a1ws @a_a1wt v_B1 v_B2 v_B3
                        $c/=_a3bI @e1_a1wr @e2_a1ws @a_a1wt v_B1 v_B2 v_B3]
Main.$fEqTriEither
  = \ (@e1_a3b4)
      (@e2_a3b5)
      (@a_a3b6)
      ($dEq_a3b7 :: Eq e1_a3b4)
      ($dEq_a3b8 :: Eq e2_a3b5)
      ($dEq_a3b9 :: Eq a_a3b6) ->
      GHC.Classes.C:Eq
        @(TriEither e1_a3b4 e2_a3b5 a_a3b6)
        ($c==_a3bb @e1_a3b4 @e2_a3b5 @a_a3b6 $dEq_a3b7 $dEq_a3b8 $dEq_a3b9)
        ($c/=_a3bI @e1_a3b4 @e2_a3b5 @a_a3b6 $dEq_a3b7 $dEq_a3b8 $dEq_a3b9)

-- RHS size: {terms: 22, types: 30, coercions: 0, joins: 0/1}
$c/=_a3bI [Occ=LoopBreaker]
  :: forall e1 e2 a.
     (Eq e1, Eq e2, Eq a) =>
     TriEither e1 e2 a -> TriEither e1 e2 a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0] 130 60}]
$c/=_a3bI
  = \ (@e1_a3b4)
      (@e2_a3b5)
      (@a_a3b6)
      ($dEq_a3b7 :: Eq e1_a3b4)
      ($dEq_a3b8 :: Eq e2_a3b5)
      ($dEq_a3b9 :: Eq a_a3b6) ->
      let {
        $dEq_a570 :: Eq (TriEither e1_a3b4 e2_a3b5 a_a3b6)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 40 0}]
        $dEq_a570
          = Main.$fEqTriEither
              @e1_a3b4 @e2_a3b5 @a_a3b6 $dEq_a3b7 $dEq_a3b8 $dEq_a3b9 } in
      \ (x_a571 :: TriEither e1_a3b4 e2_a3b5 a_a3b6)
        (y_a572 :: TriEither e1_a3b4 e2_a3b5 a_a3b6) ->
        case == @(TriEither e1_a3b4 e2_a3b5 a_a3b6) $dEq_a570 x_a571 y_a572
        of {
          False -> GHC.Types.True;
          True -> GHC.Types.False
        }
end Rec }

Rec {
-- RHS size: {terms: 19, types: 20, coercions: 0, joins: 0/0}
Main.$fFoldableBiList [InlPrag=CONLIKE]
  :: forall a. Foldable (BiList a)
[LclIdX[DFunId],
 Unf=DFun: \ (@a_a1wl) ->
       Data.Foldable.C:Foldable TYPE: BiList a_a1wl
                                $cfold_a37a @a_a1wl
                                $cfoldMap_a37m @a_a1wl
                                $cfoldMap'_a37M @a_a1wl
                                $cfoldr_a380 @a_a1wl
                                $cfoldr'_a38D @a_a1wl
                                $cfoldl_a38P @a_a1wl
                                $cfoldl'_a391 @a_a1wl
                                $cfoldr1_a39d @a_a1wl
                                $cfoldl1_a39n @a_a1wl
                                $ctoList_a39x @a_a1wl
                                $cnull_a39H @a_a1wl
                                $clength_a39U @a_a1wl
                                $celem_a3a4 @a_a1wl
                                $cmaximum_a3ag @a_a1wl
                                $cminimum_a3as @a_a1wl
                                $csum_a3aE @a_a1wl
                                $cproduct_a3aQ @a_a1wl]
Main.$fFoldableBiList
  = \ (@a_a378) ->
      Data.Foldable.C:Foldable
        @(BiList a_a378)
        ($cfold_a37a @a_a378)
        ($cfoldMap_a37m @a_a378)
        ($cfoldMap'_a37M @a_a378)
        ($cfoldr_a380 @a_a378)
        ($cfoldr'_a38D @a_a378)
        ($cfoldl_a38P @a_a378)
        ($cfoldl'_a391 @a_a378)
        ($cfoldr1_a39d @a_a378)
        ($cfoldl1_a39n @a_a378)
        ($ctoList_a39x @a_a378)
        ($cnull_a39H @a_a378)
        ($clength_a39U @a_a378)
        ($celem_a3a4 @a_a378)
        ($cmaximum_a3ag @a_a378)
        ($cminimum_a3as @a_a378)
        ($csum_a3aE @a_a378)
        ($cproduct_a3aQ @a_a378)

-- RHS size: {terms: 15, types: 21, coercions: 25, joins: 0/0}
$csum_a3aE [Occ=LoopBreaker]
  :: forall a a. Num a => BiList a a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 120 60}]
$csum_a3aE
  = \ (@a_a378) (@a_a3aH) ($dNum_a3aI :: Num a_a3aH) ->
      ((\ (@(t_a4WR :: * -> *))
          ($dFoldable_a4WS :: Foldable t_a4WR)
          (@a_a4WT)
          ($dNum_a4WU :: Num a_a4WT) ->
          Data.Foldable.foldMap'
            @t_a4WR
            $dFoldable_a4WS
            @(base:Data.Semigroup.Internal.Sum a_a4WT)
            @a_a4WT
            (base:Data.Semigroup.Internal.$fMonoidSum @a_a4WT $dNum_a4WU)
            ((\ (ds_a52f :: a_a4WT) -> ds_a52f)
             `cast` (<a_a4WT>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Sum[0]
                                              <a_a4WT>_R)
                     :: (a_a4WT -> a_a4WT)
                        ~R# (a_a4WT -> base:Data.Semigroup.Internal.Sum a_a4WT))))
       `cast` (forall (t :: <* -> *>_N).
               <Foldable t>_R
               %<'Many>_N ->_R forall (a :: <*>_N).
                               <Num a>_R
                               %<'Many>_N ->_R <t a>_R
                               %<'Many>_N ->_R base:Data.Semigroup.Internal.N:Sum[0] <a>_R
               :: (forall {t :: * -> *} {a}.
                   (Foldable t, Num a) =>
                   t a -> base:Data.Semigroup.Internal.Sum a)
                  ~R# (forall {t :: * -> *} {a}. (Foldable t, Num a) => t a -> a)))
        @(BiList a_a378) (Main.$fFoldableBiList @a_a378) @a_a3aH $dNum_a3aI

-- RHS size: {terms: 25, types: 30, coercions: 8, joins: 0/2}
$cminimum_a3as [Occ=LoopBreaker]
  :: forall a a. Ord a => BiList a a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 260 60}]
$cminimum_a3as
  = \ (@a_a378) (@a_a3av) ($dOrd_a3aw :: Ord a_a3av) ->
      let {
        d_a52o :: a_a3av
        [LclId,
         Str=b,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 110 0}]
        d_a52o
          = errorWithoutStackTrace
              @GHC.Types.LiftedRep
              @a_a3av
              (GHC.Base.build
                 @Char
                 (\ (@b_a52t) ->
                    GHC.CString.unpackFoldrCString#
                      @b_a52t "minimum: empty structure"#)) } in
      let {
        g_a52v
          :: BiList a_a378 a_a3av -> base:Data.Functor.Utils.Min a_a3av
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 80 0}]
        g_a52v
          = Data.Foldable.foldMap'
              @(BiList a_a378)
              (Main.$fFoldableBiList @a_a378)
              @(base:Data.Functor.Utils.Min a_a3av)
              @a_a3av
              (base:Data.Functor.Utils.$fMonoidMin @a_a3av $dOrd_a3aw)
              ((\ (ds_a53M :: a_a3av) -> GHC.Maybe.Just @a_a3av ds_a53M)
               `cast` (<a_a3av>_R
                       %<'Many>_N ->_R Sym (base:Data.Functor.Utils.N:Min[0]) <a_a3av>_N
                       :: (a_a3av -> GHC.Maybe.Maybe a_a3av)
                          ~R# (a_a3av -> base:Data.Functor.Utils.Min a_a3av))) } in
      \ (x_a53N :: BiList a_a378 a_a3av) ->
        case (g_a52v x_a53N)
             `cast` (base:Data.Functor.Utils.N:Min[0] <a_a3av>_N
                     :: base:Data.Functor.Utils.Min a_a3av ~R# GHC.Maybe.Maybe a_a3av)
        of {
          GHC.Maybe.Nothing -> d_a52o;
          GHC.Maybe.Just v_a54h -> v_a54h
        }

-- RHS size: {terms: 25, types: 30, coercions: 8, joins: 0/2}
$cmaximum_a3ag [Occ=LoopBreaker]
  :: forall a a. Ord a => BiList a a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 260 60}]
$cmaximum_a3ag
  = \ (@a_a378) (@a_a3aj) ($dOrd_a3ak :: Ord a_a3aj) ->
      let {
        d_a54n :: a_a3aj
        [LclId,
         Str=b,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 110 0}]
        d_a54n
          = errorWithoutStackTrace
              @GHC.Types.LiftedRep
              @a_a3aj
              (GHC.Base.build
                 @Char
                 (\ (@b_a54o) ->
                    GHC.CString.unpackFoldrCString#
                      @b_a54o "maximum: empty structure"#)) } in
      let {
        g_a54p
          :: BiList a_a378 a_a3aj -> base:Data.Functor.Utils.Max a_a3aj
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 80 0}]
        g_a54p
          = Data.Foldable.foldMap'
              @(BiList a_a378)
              (Main.$fFoldableBiList @a_a378)
              @(base:Data.Functor.Utils.Max a_a3aj)
              @a_a3aj
              (base:Data.Functor.Utils.$fMonoidMax @a_a3aj $dOrd_a3ak)
              ((\ (ds_a54r :: a_a3aj) -> GHC.Maybe.Just @a_a3aj ds_a54r)
               `cast` (<a_a3aj>_R
                       %<'Many>_N ->_R Sym (base:Data.Functor.Utils.N:Max[0]) <a_a3aj>_N
                       :: (a_a3aj -> GHC.Maybe.Maybe a_a3aj)
                          ~R# (a_a3aj -> base:Data.Functor.Utils.Max a_a3aj))) } in
      \ (x_a54s :: BiList a_a378 a_a3aj) ->
        case (g_a54p x_a54s)
             `cast` (base:Data.Functor.Utils.N:Max[0] <a_a3aj>_N
                     :: base:Data.Functor.Utils.Max a_a3aj ~R# GHC.Maybe.Maybe a_a3aj)
        of {
          GHC.Maybe.Nothing -> d_a54n;
          GHC.Maybe.Just v_a54x -> v_a54x
        }

-- RHS size: {terms: 16, types: 20, coercions: 26, joins: 0/0}
$celem_a3a4 [Occ=LoopBreaker]
  :: forall a a. Eq a => a -> BiList a a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 130 60}]
$celem_a3a4
  = \ (@a_a378) (@a_a3a7) ($dEq_a3a8 :: Eq a_a3a7) ->
      ((\ (@(t_a54z :: * -> *))
          ($dFoldable_a54A :: Foldable t_a54z)
          (@a_a54B)
          ($dEq_a54C :: Eq a_a54B)
          (eta_a54D :: a_a54B) ->
          foldMap
            @t_a54z
            $dFoldable_a54A
            @base:Data.Semigroup.Internal.Any
            @a_a54B
            base:Data.Semigroup.Internal.$fMonoidAny
            ((== @a_a54B $dEq_a54C eta_a54D)
             `cast` (<a_a54B>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Any[0])
                     :: (a_a54B -> Bool)
                        ~R# (a_a54B -> base:Data.Semigroup.Internal.Any))))
       `cast` (forall (t :: <* -> *>_N).
               <Foldable t>_R
               %<'Many>_N ->_R forall (a :: <*>_N).
                               <Eq a>_R
                               %<'Many>_N ->_R <a>_R
                               %<'Many>_N ->_R <t a>_R
                               %<'Many>_N ->_R base:Data.Semigroup.Internal.N:Any[0]
               :: (forall {t :: * -> *} {a}.
                   (Foldable t, Eq a) =>
                   a -> t a -> base:Data.Semigroup.Internal.Any)
                  ~R# (forall {t :: * -> *} {a}.
                       (Foldable t, Eq a) =>
                       a -> t a -> Bool)))
        @(BiList a_a378) (Main.$fFoldableBiList @a_a378) @a_a3a7 $dEq_a3a8

-- RHS size: {terms: 15, types: 11, coercions: 0, joins: 0/0}
$clength_a39U [Occ=LoopBreaker] :: forall a a. BiList a a -> Int
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=False, ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 91 0}]
$clength_a39U
  = \ (@a_a378) (@a_a39X) ->
      Data.Foldable.foldl'
        @(BiList a_a378)
        (Main.$fFoldableBiList @a_a378)
        @Int
        @a_a39X
        (\ (c_a54K :: Int) _ [Occ=Dead] ->
           case c_a54K of { GHC.Types.I# x_a54N ->
           GHC.Types.I# (GHC.Prim.+# x_a54N 1#)
           })
        (GHC.Types.I# 0#)

-- RHS size: {terms: 13, types: 20, coercions: 0, joins: 0/0}
$cnull_a39H [Occ=LoopBreaker] :: forall a a. BiList a a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [40] 60 20}]
$cnull_a39H
  = \ (@a_a378) (@a_a39K) (ds_d4NM :: BiList a_a378 a_a39K) ->
      case ds_d4NM of {
        ACons _ [Occ=Dead] a2_a2c4 ->
          null
            @(BiList a_a378) (Main.$fFoldableBiList @a_a378) @a_a39K a2_a2c4;
        BCons _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.False;
        ABNill -> GHC.Types.True
      }

-- RHS size: {terms: 12, types: 16, coercions: 0, joins: 0/0}
$ctoList_a39x [Occ=LoopBreaker] :: forall a a. BiList a a -> [a]
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 70 40}]
$ctoList_a39x
  = \ (@a_a378) (@a_a39A) (t1_a54S :: BiList a_a378 a_a39A) ->
      GHC.Base.build
        @a_a39A
        (\ (@b_a54T)
           (c_a54U [OS=OneShot] :: a_a39A -> b_a54T -> b_a54T)
           (n_a54V [OS=OneShot] :: b_a54T) ->
           foldr
             @(BiList a_a378)
             (Main.$fFoldableBiList @a_a378)
             @a_a39A
             @b_a54T
             c_a54U
             n_a54V
             t1_a54S)

-- RHS size: {terms: 28, types: 30, coercions: 0, joins: 0/0}
$cfoldl1_a39n [Occ=LoopBreaker]
  :: forall a a. (a -> a -> a) -> BiList a a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0] 260 0}]
$cfoldl1_a39n
  = \ (@a_a378)
      (@a_a39q)
      (f_a54Z :: a_a39q -> a_a39q -> a_a39q)
      (xs_a550 :: BiList a_a378 a_a39q) ->
      case foldl
             @(BiList a_a378)
             (Main.$fFoldableBiList @a_a378)
             @(GHC.Maybe.Maybe a_a39q)
             @a_a39q
             (\ (m_a551 :: GHC.Maybe.Maybe a_a39q) (y_a552 :: a_a39q) ->
                GHC.Maybe.Just
                  @a_a39q
                  (case m_a551 of {
                     GHC.Maybe.Nothing -> y_a552;
                     GHC.Maybe.Just x_a555 -> f_a54Z x_a555 y_a552
                   }))
             (GHC.Maybe.Nothing @a_a39q)
             xs_a550
      of {
        GHC.Maybe.Nothing ->
          errorWithoutStackTrace
            @GHC.Types.LiftedRep
            @a_a39q
            (GHC.Base.build
               @Char
               (\ (@b_a558) ->
                  GHC.CString.unpackFoldrCString#
                    @b_a558 "foldl1: empty structure"#));
        GHC.Maybe.Just v_a559 -> v_a559
      }

-- RHS size: {terms: 28, types: 30, coercions: 0, joins: 0/0}
$cfoldr1_a39d [Occ=LoopBreaker]
  :: forall a a. (a -> a -> a) -> BiList a a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0] 260 0}]
$cfoldr1_a39d
  = \ (@a_a378)
      (@a_a39g)
      (f_a55f :: a_a39g -> a_a39g -> a_a39g)
      (xs_a55g :: BiList a_a378 a_a39g) ->
      case foldr
             @(BiList a_a378)
             (Main.$fFoldableBiList @a_a378)
             @a_a39g
             @(GHC.Maybe.Maybe a_a39g)
             (\ (x_a55h :: a_a39g) (m_a55i :: GHC.Maybe.Maybe a_a39g) ->
                GHC.Maybe.Just
                  @a_a39g
                  (case m_a55i of {
                     GHC.Maybe.Nothing -> x_a55h;
                     GHC.Maybe.Just y_a55l -> f_a55f x_a55h y_a55l
                   }))
             (GHC.Maybe.Nothing @a_a39g)
             xs_a55g
      of {
        GHC.Maybe.Nothing ->
          errorWithoutStackTrace
            @GHC.Types.LiftedRep
            @a_a39g
            (GHC.Base.build
               @Char
               (\ (@b_a55o) ->
                  GHC.CString.unpackFoldrCString#
                    @b_a55o "foldr1: empty structure"#));
        GHC.Maybe.Just v_a55p -> v_a55p
      }

-- RHS size: {terms: 21, types: 22, coercions: 0, joins: 0/0}
$cfoldl'_a391 [Occ=LoopBreaker]
  :: forall a b a. (b -> a -> b) -> b -> BiList a a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 150 0}]
$cfoldl'_a391
  = \ (@a_a378)
      (@b_a394)
      (@a_a395)
      (f_a55w :: b_a394 -> a_a395 -> b_a394)
      (z0_a55x :: b_a394)
      (xs_a55y :: BiList a_a378 a_a395) ->
      foldr
        @(BiList a_a378)
        (Main.$fFoldableBiList @a_a378)
        @a_a395
        @(b_a394 -> b_a394)
        (\ (ds_a55z :: a_a395)
           (ds1_a55A :: b_a394 -> b_a394)
           (v_a55B [OS=OneShot] :: b_a394) ->
           case v_a55B of z_a55C { __DEFAULT ->
           ds1_a55A (f_a55w z_a55C ds_a55z)
           })
        (id @b_a394)
        xs_a55y
        z0_a55x

-- RHS size: {terms: 17, types: 22, coercions: 10, joins: 0/0}
$cfoldl_a38P [Occ=LoopBreaker]
  :: forall a b a. (b -> a -> b) -> b -> BiList a a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 130 0}]
$cfoldl_a38P
  = \ (@a_a378)
      (@b_a38S)
      (@a_a38T)
      (eta_a55I :: b_a38S -> a_a38T -> b_a38S)
      (eta1_a55J :: b_a38S)
      (eta2_a55K :: BiList a_a378 a_a38T) ->
      ((foldMap
          @(BiList a_a378)
          (Main.$fFoldableBiList @a_a378)
          @(base:Data.Semigroup.Internal.Dual
              (base:Data.Semigroup.Internal.Endo b_a38S))
          @a_a38T
          (base:Data.Semigroup.Internal.$fMonoidDual
             @(base:Data.Semigroup.Internal.Endo b_a38S)
             (base:Data.Semigroup.Internal.$fMonoidEndo @b_a38S))
          ((\ (x_a55N :: a_a38T) (y_a55O :: b_a38S) ->
              eta_a55I y_a55O x_a55N)
           `cast` (<a_a38T>_R
                   %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Dual[0]
                                            (base:Data.Semigroup.Internal.N:Endo[0] <b_a38S>_R))
                   :: (a_a38T -> b_a38S -> b_a38S)
                      ~R# (a_a38T
                           -> base:Data.Semigroup.Internal.Dual
                                (base:Data.Semigroup.Internal.Endo b_a38S))))
          eta2_a55K)
       `cast` (base:Data.Semigroup.Internal.N:Dual[0]
                   (base:Data.Semigroup.Internal.N:Endo[0] <b_a38S>_R)
               :: base:Data.Semigroup.Internal.Dual
                    (base:Data.Semigroup.Internal.Endo b_a38S)
                  ~R# (b_a38S -> b_a38S)))
        eta1_a55J

-- RHS size: {terms: 21, types: 22, coercions: 0, joins: 0/0}
$cfoldr'_a38D [Occ=LoopBreaker]
  :: forall a a b. (a -> b -> b) -> b -> BiList a a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 150 0}]
$cfoldr'_a38D
  = \ (@a_a378)
      (@a_a38G)
      (@b_a38H)
      (f_a55X :: a_a38G -> b_a38H -> b_a38H)
      (z0_a55Y :: b_a38H)
      (xs_a55Z :: BiList a_a378 a_a38G) ->
      foldl
        @(BiList a_a378)
        (Main.$fFoldableBiList @a_a378)
        @(b_a38H -> b_a38H)
        @a_a38G
        (\ (ds_a560 :: b_a38H -> b_a38H)
           (ds1_a561 :: a_a38G)
           (v_a562 [OS=OneShot] :: b_a38H) ->
           case v_a562 of z_a563 { __DEFAULT ->
           ds_a560 (f_a55X ds1_a561 z_a563)
           })
        (id @b_a38H)
        xs_a55Z
        z0_a55Y

-- RHS size: {terms: 24, types: 31, coercions: 0, joins: 0/0}
$cfoldr_a380 [Occ=LoopBreaker]
  :: forall a a b. (a -> b -> b) -> b -> BiList a a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 90] 160 0}]
$cfoldr_a380
  = \ (@a_a378)
      (@a_a383)
      (@b_a384)
      (f_a2bI :: a_a383 -> b_a384 -> b_a384)
      (z_a2bJ :: b_a384)
      (ds_d4NL :: BiList a_a378 a_a383) ->
      case ds_d4NL of {
        ACons _ [Occ=Dead] a2_a2bL ->
          foldr
            @(BiList a_a378)
            (Main.$fFoldableBiList @a_a378)
            @a_a383
            @b_a384
            f_a2bI
            z_a2bJ
            a2_a2bL;
        BCons a1_a2bQ a2_a2bR ->
          f_a2bI
            a1_a2bQ
            (foldr
               @(BiList a_a378)
               (Main.$fFoldableBiList @a_a378)
               @a_a383
               @b_a384
               f_a2bI
               z_a2bJ
               a2_a2bR);
        ABNill -> z_a2bJ
      }

-- RHS size: {terms: 19, types: 19, coercions: 0, joins: 0/1}
$cfoldMap'_a37M [Occ=LoopBreaker]
  :: forall a m a. Monoid m => (a -> m) -> BiList a a -> m
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 60] 170 0}]
$cfoldMap'_a37M
  = \ (@a_a378)
      (@m_a37P)
      (@a_a37Q)
      ($dMonoid_a37R :: Monoid m_a37P)
      (eta_a569 :: a_a37Q -> m_a37P) ->
      let {
        $dSemigroup_a56a :: Semigroup m_a37P
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dSemigroup_a56a = GHC.Base.$p1Monoid @m_a37P $dMonoid_a37R } in
      Data.Foldable.foldl'
        @(BiList a_a378)
        (Main.$fFoldableBiList @a_a378)
        @m_a37P
        @a_a37Q
        (\ (acc_a56b :: m_a37P) (a1_a56c :: a_a37Q) ->
           <> @m_a37P $dSemigroup_a56a acc_a56b (eta_a569 a1_a56c))
        (mempty @m_a37P $dMonoid_a37R)

-- RHS size: {terms: 27, types: 33, coercions: 0, joins: 0/0}
$cfoldMap_a37m [Occ=LoopBreaker]
  :: forall a m a. Monoid m => (a -> m) -> BiList a a -> m
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 60 110] 210 0}]
$cfoldMap_a37m
  = \ (@a_a378)
      (@m_a37p)
      (@a_a37q)
      ($dMonoid_a37r :: Monoid m_a37p)
      (f_a2bW :: a_a37q -> m_a37p)
      (ds_d4NK :: BiList a_a378 a_a37q) ->
      case ds_d4NK of {
        ACons _ [Occ=Dead] a2_a2bY ->
          foldMap
            @(BiList a_a378)
            (Main.$fFoldableBiList @a_a378)
            @m_a37p
            @a_a37q
            $dMonoid_a37r
            f_a2bW
            a2_a2bY;
        BCons a1_a2c0 a2_a2c1 ->
          mappend
            @m_a37p
            $dMonoid_a37r
            (f_a2bW a1_a2c0)
            (foldMap
               @(BiList a_a378)
               (Main.$fFoldableBiList @a_a378)
               @m_a37p
               @a_a37q
               $dMonoid_a37r
               f_a2bW
               a2_a2c1);
        ABNill -> mempty @m_a37p $dMonoid_a37r
      }

-- RHS size: {terms: 15, types: 21, coercions: 25, joins: 0/0}
$cproduct_a3aQ [Occ=LoopBreaker]
  :: forall a a. Num a => BiList a a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 120 60}]
$cproduct_a3aQ
  = \ (@a_a378) (@a_a3aT) ($dNum_a3aU :: Num a_a3aT) ->
      ((\ (@(t_a56d :: * -> *))
          ($dFoldable_a56e :: Foldable t_a56d)
          (@a_a56f)
          ($dNum_a56g :: Num a_a56f) ->
          Data.Foldable.foldMap'
            @t_a56d
            $dFoldable_a56e
            @(base:Data.Semigroup.Internal.Product a_a56f)
            @a_a56f
            (base:Data.Semigroup.Internal.$fMonoidProduct @a_a56f $dNum_a56g)
            ((\ (ds_a56i :: a_a56f) -> ds_a56i)
             `cast` (<a_a56f>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Product[0]
                                              <a_a56f>_R)
                     :: (a_a56f -> a_a56f)
                        ~R# (a_a56f -> base:Data.Semigroup.Internal.Product a_a56f))))
       `cast` (forall (t :: <* -> *>_N).
               <Foldable t>_R
               %<'Many>_N ->_R forall (a :: <*>_N).
                               <Num a>_R
                               %<'Many>_N ->_R <t a>_R
                               %<'Many>_N ->_R base:Data.Semigroup.Internal.N:Product[0] <a>_R
               :: (forall {t :: * -> *} {a}.
                   (Foldable t, Num a) =>
                   t a -> base:Data.Semigroup.Internal.Product a)
                  ~R# (forall {t :: * -> *} {a}. (Foldable t, Num a) => t a -> a)))
        @(BiList a_a378) (Main.$fFoldableBiList @a_a378) @a_a3aT $dNum_a3aU

-- RHS size: {terms: 7, types: 10, coercions: 0, joins: 0/0}
$cfold_a37a [Occ=LoopBreaker]
  :: forall a m. Monoid m => BiList a m -> m
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 40 0}]
$cfold_a37a
  = \ (@a_a378) (@m_a37d) ($dMonoid_a37e :: Monoid m_a37d) ->
      foldMap
        @(BiList a_a378)
        (Main.$fFoldableBiList @a_a378)
        @m_a37d
        @m_a37d
        $dMonoid_a37e
        (id @m_a37d)
end Rec }

Rec {
-- RHS size: {terms: 4, types: 5, coercions: 0, joins: 0/0}
Main.$fFunctorBiList [InlPrag=CONLIKE]
  :: forall a. Functor (BiList a)
[LclIdX[DFunId],
 Unf=DFun: \ (@a_a1wf) ->
       GHC.Base.C:Functor TYPE: BiList a_a1wf
                          $cfmap_a36a @a_a1wf
                          $c<$_a36D @a_a1wf]
Main.$fFunctorBiList
  = \ (@a_a368) ->
      GHC.Base.C:Functor
        @(BiList a_a368) ($cfmap_a36a @a_a368) ($c<$_a36D @a_a368)

-- RHS size: {terms: 23, types: 34, coercions: 0, joins: 0/0}
$c<$_a36D [Occ=LoopBreaker]
  :: forall a a b. a -> BiList a b -> BiList a a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 90] 130 30}]
$c<$_a36D
  = \ (@a_a368)
      (@a_a36G)
      (@b_a36H)
      (z_a2bB :: a_a36G)
      (ds_d4NF :: BiList a_a368 b_a36H) ->
      case ds_d4NF of {
        ACons a1_a2bC a2_a2bD ->
          Main.ACons
            @a_a368
            @a_a36G
            a1_a2bC
            (<$
               @(BiList a_a368)
               (Main.$fFunctorBiList @a_a368)
               @a_a36G
               @b_a36H
               z_a2bB
               a2_a2bD);
        BCons _ [Occ=Dead] a2_a2bG ->
          Main.BCons
            @a_a368
            @a_a36G
            z_a2bB
            (<$
               @(BiList a_a368)
               (Main.$fFunctorBiList @a_a368)
               @a_a36G
               @b_a36H
               z_a2bB
               a2_a2bG);
        ABNill -> Main.ABNill @a_a368 @a_a36G
      }

-- RHS size: {terms: 24, types: 35, coercions: 0, joins: 0/0}
$cfmap_a36a [Occ=LoopBreaker]
  :: forall a a b. (a -> b) -> BiList a a -> BiList a b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 90] 150 30}]
$cfmap_a36a
  = \ (@a_a368)
      (@a_a36d)
      (@b_a36e)
      (f_a2bu :: a_a36d -> b_a36e)
      (ds_d4NA :: BiList a_a368 a_a36d) ->
      case ds_d4NA of {
        ACons a1_a2bv a2_a2bw ->
          Main.ACons
            @a_a368
            @b_a36e
            a1_a2bv
            (fmap
               @(BiList a_a368)
               (Main.$fFunctorBiList @a_a368)
               @a_a36d
               @b_a36e
               f_a2bu
               a2_a2bw);
        BCons a1_a2by a2_a2bz ->
          Main.BCons
            @a_a368
            @b_a36e
            (f_a2bu a1_a2by)
            (fmap
               @(BiList a_a368)
               (Main.$fFunctorBiList @a_a368)
               @a_a36d
               @b_a36e
               f_a2bu
               a2_a2bz);
        ABNill -> Main.ABNill @a_a368 @b_a36e
      }
end Rec }

Rec {
-- RHS size: {terms: 8, types: 9, coercions: 0, joins: 0/0}
Main.$fTraversableBiList [InlPrag=CONLIKE]
  :: forall fixed. Traversable (BiList fixed)
[LclIdX[DFunId],
 Unf=DFun: \ (@fixed_aUw) ->
       Data.Traversable.C:Traversable TYPE: BiList fixed_aUw
                                      Main.$fFunctorBiList @fixed_aUw
                                      Main.$fFoldableBiList @fixed_aUw
                                      $ctraverse_a4cS @fixed_aUw
                                      $csequenceA_a4d8 @fixed_aUw
                                      $cmapM_a4dm @fixed_aUw
                                      $csequence_a4dC @fixed_aUw]
Main.$fTraversableBiList
  = \ (@fixed_a4cI) ->
      Data.Traversable.C:Traversable
        @(BiList fixed_a4cI)
        (Main.$fFunctorBiList @fixed_a4cI)
        (Main.$fFoldableBiList @fixed_a4cI)
        ($ctraverse_a4cS @fixed_a4cI)
        ($csequenceA_a4d8 @fixed_a4cI)
        ($cmapM_a4dm @fixed_a4cI)
        ($csequence_a4dC @fixed_a4cI)

-- RHS size: {terms: 9, types: 14, coercions: 0, joins: 0/0}
$cmapM_a4dm [Occ=LoopBreaker]
  :: forall fixed (m :: * -> *) a b.
     Monad m =>
     (a -> m b) -> BiList fixed a -> m (BiList fixed b)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30] 50 0}]
$cmapM_a4dm
  = \ (@fixed_a4cI)
      (@(m_a4dp :: * -> *))
      (@a_a4dq)
      (@b_a4dr)
      ($dMonad_a4ds :: Monad m_a4dp) ->
      traverse
        @(BiList fixed_a4cI)
        (Main.$fTraversableBiList @fixed_a4cI)
        @m_a4dp
        @a_a4dq
        @b_a4dr
        (GHC.Base.$p1Monad @m_a4dp $dMonad_a4ds)

-- RHS size: {terms: 8, types: 15, coercions: 0, joins: 0/0}
$csequenceA_a4d8 [Occ=LoopBreaker]
  :: forall fixed (f :: * -> *) a.
     Applicative f =>
     BiList fixed (f a) -> f (BiList fixed a)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 40 0}]
$csequenceA_a4d8
  = \ (@fixed_a4cI)
      (@(f_a4db :: * -> *))
      (@a_a4dc)
      ($dApplicative_a4dd :: Applicative f_a4db) ->
      traverse
        @(BiList fixed_a4cI)
        (Main.$fTraversableBiList @fixed_a4cI)
        @f_a4db
        @(f_a4db a_a4dc)
        @a_a4dc
        $dApplicative_a4dd
        (id @(f_a4db a_a4dc))

-- RHS size: {terms: 8, types: 12, coercions: 0, joins: 0/0}
$csequence_a4dC [Occ=LoopBreaker]
  :: forall fixed (m :: * -> *) a.
     Monad m =>
     BiList fixed (m a) -> m (BiList fixed a)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30] 50 0}]
$csequence_a4dC
  = \ (@fixed_a4cI)
      (@(m_a4dF :: * -> *))
      (@a_a4dG)
      ($dMonad_a4dH :: Monad m_a4dF) ->
      sequenceA
        @(BiList fixed_a4cI)
        (Main.$fTraversableBiList @fixed_a4cI)
        @m_a4dF
        @a_a4dG
        (GHC.Base.$p1Monad @m_a4dF $dMonad_a4dH)

-- RHS size: {terms: 19, types: 41, coercions: 0, joins: 0/2}
$ctraverse_a4cS [Occ=LoopBreaker]
  :: forall fixed (f :: * -> *) a b.
     Applicative f =>
     (a -> f b) -> BiList fixed a -> f (BiList fixed b)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 150 60}]
$ctraverse_a4cS
  = \ (@fixed_a4cI)
      (@(f_a4cV :: * -> *))
      (@a_a4cW)
      (@b_a4cX)
      ($dApplicative_a4cY :: Applicative f_a4cV)
      (eta1_a56N :: a_a4cW -> f_a4cV b_a4cX) ->
      let {
        f1_a56O
          :: BiList fixed_a4cI (f_a4cV b_a4cX)
             -> f_a4cV (BiList fixed_a4cI b_a4cX)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 30 0}]
        f1_a56O
          = sequenceA
              @(BiList fixed_a4cI)
              (Main.$fTraversableBiList @fixed_a4cI)
              @f_a4cV
              @b_a4cX
              $dApplicative_a4cY } in
      let {
        g_a56P
          :: BiList fixed_a4cI a_a4cW -> BiList fixed_a4cI (f_a4cV b_a4cX)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 50 0}]
        g_a56P
          = fmap
              @(BiList fixed_a4cI)
              (Data.Traversable.$p1Traversable
                 @(BiList fixed_a4cI) (Main.$fTraversableBiList @fixed_a4cI))
              @a_a4cW
              @(f_a4cV b_a4cX)
              eta1_a56N } in
      \ (x_a56Q :: BiList fixed_a4cI a_a4cW) -> f1_a56O (g_a56P x_a56Q)
end Rec }

Rec {
-- RHS size: {terms: 14, types: 15, coercions: 0, joins: 0/0}
Main.$fShowBiList [InlPrag=CONLIKE]
  :: forall a b. (Show a, Show b) => Show (BiList a b)
[LclIdX[DFunId],
 Unf=DFun: \ (@a_a1w8)
             (@b_a1w9)
             (v_B1 :: Show a_a1w8)
             (v_B2 :: Show b_a1w9) ->
       GHC.Show.C:Show TYPE: BiList a_a1w8 b_a1w9
                       $cshowsPrec_a35g @a_a1w8 @b_a1w9 v_B1 v_B2
                       $cshow_a35S @a_a1w8 @b_a1w9 v_B1 v_B2
                       $cshowList_a35Z @a_a1w8 @b_a1w9 v_B1 v_B2]
Main.$fShowBiList
  = \ (@a_a35b)
      (@b_a35c)
      ($dShow_a35d :: Show a_a35b)
      ($dShow_a35e :: Show b_a35c) ->
      GHC.Show.C:Show
        @(BiList a_a35b b_a35c)
        ($cshowsPrec_a35g @a_a35b @b_a35c $dShow_a35d $dShow_a35e)
        ($cshow_a35S @a_a35b @b_a35c $dShow_a35d $dShow_a35e)
        ($cshowList_a35Z @a_a35b @b_a35c $dShow_a35d $dShow_a35e)

-- RHS size: {terms: 15, types: 19, coercions: 0, joins: 0/1}
$cshow_a35S [Occ=LoopBreaker]
  :: forall a b. (Show a, Show b) => BiList a b -> String
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 110 60}]
$cshow_a35S
  = \ (@a_a35b)
      (@b_a35c)
      ($dShow_a35d :: Show a_a35b)
      ($dShow_a35e :: Show b_a35c) ->
      let {
        $dShow_a56X :: Show (BiList a_a35b b_a35c)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 30 0}]
        $dShow_a56X
          = Main.$fShowBiList @a_a35b @b_a35c $dShow_a35d $dShow_a35e } in
      \ (x_a56Y :: BiList a_a35b b_a35c) ->
        showsPrec
          @(BiList a_a35b b_a35c)
          $dShow_a56X
          (GHC.Types.I# 0#)
          x_a56Y
          (GHC.Types.[] @Char)

-- RHS size: {terms: 17, types: 23, coercions: 0, joins: 0/1}
$cshowList_a35Z [Occ=LoopBreaker]
  :: forall a b. (Show a, Show b) => [BiList a b] -> ShowS
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 140 60}]
$cshowList_a35Z
  = \ (@a_a35b)
      (@b_a35c)
      ($dShow_a35d :: Show a_a35b)
      ($dShow_a35e :: Show b_a35c) ->
      let {
        $dShow_a56S :: Show (BiList a_a35b b_a35c)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 30 0}]
        $dShow_a56S
          = Main.$fShowBiList @a_a35b @b_a35c $dShow_a35d $dShow_a35e } in
      \ (ls_a56T :: [BiList a_a35b b_a35c]) (s_a56U :: String) ->
        GHC.Show.showList__
          @(BiList a_a35b b_a35c)
          (showsPrec @(BiList a_a35b b_a35c) $dShow_a56S (GHC.Types.I# 0#))
          ls_a56T
          s_a56U

-- RHS size: {terms: 64, types: 55, coercions: 0, joins: 0/1}
$cshowsPrec_a35g [Occ=LoopBreaker]
  :: forall a b. (Show a, Show b) => Int -> BiList a b -> ShowS
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=NEVER}]
$cshowsPrec_a35g
  = \ (@a_a35b)
      (@b_a35c)
      ($dShow_a35d :: Show a_a35b)
      ($dShow_a35e :: Show b_a35c) ->
      let {
        $dShow_a35z :: Show (BiList a_a35b b_a35c)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 30 0}]
        $dShow_a35z
          = Main.$fShowBiList @a_a35b @b_a35c $dShow_a35d $dShow_a35e } in
      \ (a_a2bo :: Int) (ds_d4Nt :: BiList a_a35b b_a35c) ->
        case ds_d4Nt of {
          ACons b1_a2bp b2_a2bq ->
            showParen
              (>= @Int GHC.Classes.$fOrdInt a_a2bo (GHC.Types.I# 11#))
              (. @String
                 @String
                 @String
                 (showString (GHC.CString.unpackCString# "ACons "#))
                 (. @String
                    @String
                    @String
                    (showsPrec @a_a35b $dShow_a35d (GHC.Types.I# 11#) b1_a2bp)
                    (. @String
                       @String
                       @String
                       GHC.Show.showSpace
                       (showsPrec
                          @(BiList a_a35b b_a35c) $dShow_a35z (GHC.Types.I# 11#) b2_a2bq))));
          BCons b1_a2bs b2_a2bt ->
            showParen
              (>= @Int GHC.Classes.$fOrdInt a_a2bo (GHC.Types.I# 11#))
              (. @String
                 @String
                 @String
                 (showString (GHC.CString.unpackCString# "BCons "#))
                 (. @String
                    @String
                    @String
                    (showsPrec @b_a35c $dShow_a35e (GHC.Types.I# 11#) b1_a2bs)
                    (. @String
                       @String
                       @String
                       GHC.Show.showSpace
                       (showsPrec
                          @(BiList a_a35b b_a35c) $dShow_a35z (GHC.Types.I# 11#) b2_a2bt))));
          ABNill -> showString (GHC.CString.unpackCString# "ABNill"#)
        }
end Rec }

Rec {
-- RHS size: {terms: 11, types: 13, coercions: 0, joins: 0/0}
Main.$fEqBiList [InlPrag=CONLIKE]
  :: forall a b. (Eq a, Eq b) => Eq (BiList a b)
[LclIdX[DFunId],
 Unf=DFun: \ (@a_a1w1)
             (@b_a1w2)
             (v_B1 :: Eq a_a1w1)
             (v_B2 :: Eq b_a1w2) ->
       GHC.Classes.C:Eq TYPE: BiList a_a1w1 b_a1w2
                        $c==_a34x @a_a1w1 @b_a1w2 v_B1 v_B2
                        $c/=_a352 @a_a1w1 @b_a1w2 v_B1 v_B2]
Main.$fEqBiList
  = \ (@a_a34s)
      (@b_a34t)
      ($dEq_a34u :: Eq a_a34s)
      ($dEq_a34v :: Eq b_a34t) ->
      GHC.Classes.C:Eq
        @(BiList a_a34s b_a34t)
        ($c==_a34x @a_a34s @b_a34t $dEq_a34u $dEq_a34v)
        ($c/=_a352 @a_a34s @b_a34t $dEq_a34u $dEq_a34v)

-- RHS size: {terms: 19, types: 22, coercions: 0, joins: 0/1}
$c/=_a352 [Occ=LoopBreaker]
  :: forall a b. (Eq a, Eq b) => BiList a b -> BiList a b -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 120 60}]
$c/=_a352
  = \ (@a_a34s)
      (@b_a34t)
      ($dEq_a34u :: Eq a_a34s)
      ($dEq_a34v :: Eq b_a34t) ->
      let {
        $dEq_a570 :: Eq (BiList a_a34s b_a34t)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 30 0}]
        $dEq_a570
          = Main.$fEqBiList @a_a34s @b_a34t $dEq_a34u $dEq_a34v } in
      \ (x_a571 :: BiList a_a34s b_a34t)
        (y_a572 :: BiList a_a34s b_a34t) ->
        case == @(BiList a_a34s b_a34t) $dEq_a570 x_a571 y_a572 of {
          False -> GHC.Types.True;
          True -> GHC.Types.False
        }

-- RHS size: {terms: 66, types: 67, coercions: 0, joins: 0/1}
$c==_a34x [Occ=LoopBreaker]
  :: forall a b. (Eq a, Eq b) => BiList a b -> BiList a b -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30] 563 60}]
$c==_a34x
  = \ (@a_a34s)
      (@b_a34t)
      ($dEq_a34u :: Eq a_a34s)
      ($dEq_a34v :: Eq b_a34t) ->
      let {
        $dEq_a34S :: Eq (BiList a_a34s b_a34t)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 30 0}]
        $dEq_a34S
          = Main.$fEqBiList @a_a34s @b_a34t $dEq_a34u $dEq_a34v } in
      \ (a_a2bc :: BiList a_a34s b_a34t)
        (b_a2bd :: BiList a_a34s b_a34t) ->
        case case GHC.Prim.dataToTag# @(BiList a_a34s b_a34t) a_a2bc
             of a#_a2be
             { __DEFAULT ->
             case GHC.Prim.dataToTag# @(BiList a_a34s b_a34t) b_a2bd of b#_a2bf
             { __DEFAULT ->
             GHC.Prim./=# a#_a2be b#_a2bf
             }
             }
        of ds_d4N4
        { __DEFAULT ->
        case ds_d4N4 of {
          __DEFAULT ->
            case a_a2bc of {
              __DEFAULT -> GHC.Types.True;
              ACons a1_a2bg a2_a2bh ->
                case b_a2bd of {
                  __DEFAULT ->
                    case Control.Exception.Base.patError
                           @GHC.Types.LiftedRep @() "Gy08.hs:39:82-83|case"#
                    of {
                    };
                  ACons b1_a2bi b2_a2bj ->
                    &&
                      (== @a_a34s $dEq_a34u a1_a2bg b1_a2bi)
                      (== @(BiList a_a34s b_a34t) $dEq_a34S a2_a2bh b2_a2bj)
                };
              BCons a1_a2bk a2_a2bl ->
                case b_a2bd of {
                  __DEFAULT ->
                    case Control.Exception.Base.patError
                           @GHC.Types.LiftedRep @() "Gy08.hs:39:82-83|case"#
                    of {
                    };
                  BCons b1_a2bm b2_a2bn ->
                    &&
                      (== @b_a34t $dEq_a34v a1_a2bk b1_a2bm)
                      (== @(BiList a_a34s b_a34t) $dEq_a34S a2_a2bl b2_a2bn)
                }
            };
          1# -> GHC.Types.False
        }
        }
end Rec }

-- RHS size: {terms: 10, types: 17, coercions: 0, joins: 0/0}
$cnull_a337
  :: forall (f :: * -> *) a. Foldable f => Apply f a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 20] 40 0}]
$cnull_a337
  = \ (@(f_a30Y :: * -> *))
      ($dFoldable_a30Z :: Foldable f_a30Y)
      (@a_a33a)
      (ds_d4ML :: Apply f_a30Y a_a33a) ->
      case ds_d4ML of { MkApply a1_a2bb ->
      null @f_a30Y $dFoldable_a30Z @a_a33a a1_a2bb
      }

-- RHS size: {terms: 15, types: 23, coercions: 0, joins: 0/0}
$cfoldr_a31G
  :: forall (f :: * -> *) a b.
     Foldable f =>
     (a -> b -> b) -> b -> Apply f a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 0 0 20] 60 0}]
$cfoldr_a31G
  = \ (@(f_a30Y :: * -> *))
      ($dFoldable_a30Z :: Foldable f_a30Y)
      (@a_a31J)
      (@b_a31K)
      (f_a2b4 :: a_a31J -> b_a31K -> b_a31K)
      (z_a2b5 :: b_a31K)
      (ds_d4Mw :: Apply f_a30Y a_a31J) ->
      case ds_d4Mw of { MkApply a1_a2b6 ->
      foldr @f_a30Y $dFoldable_a30Z @a_a31J @b_a31K f_a2b4 z_a2b5 a1_a2b6
      }

-- RHS size: {terms: 15, types: 23, coercions: 0, joins: 0/0}
$cfoldMap_a31d
  :: forall (f :: * -> *) m a.
     (Foldable f, Monoid m) =>
     (a -> m) -> Apply f a -> m
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 0 0 20] 60 0}]
$cfoldMap_a31d
  = \ (@(f_a30Y :: * -> *))
      ($dFoldable_a30Z :: Foldable f_a30Y)
      (@m_a31g)
      (@a_a31h)
      ($dMonoid_a31i :: Monoid m_a31g)
      (f_a2b9 :: a_a31h -> m_a31g)
      (ds_d4Mr :: Apply f_a30Y a_a31h) ->
      case ds_d4Mr of { MkApply a1_a2ba ->
      foldMap
        @f_a30Y
        $dFoldable_a30Z
        @m_a31g
        @a_a31h
        $dMonoid_a31i
        f_a2b9
        a1_a2ba
      }

Rec {
-- RHS size: {terms: 37, types: 24, coercions: 0, joins: 0/0}
Main.$fFoldableApply [InlPrag=CONLIKE]
  :: forall (f :: * -> *). Foldable f => Foldable (Apply f)
[LclIdX[DFunId],
 Unf=DFun: \ (@(f_a1vV :: * -> *)) (v_B1 :: Foldable f_a1vV) ->
       Data.Foldable.C:Foldable TYPE: Apply f_a1vV
                                $cfold_a311 @f_a1vV v_B1
                                $cfoldMap_a31d @f_a1vV v_B1
                                $cfoldMap'_a31s @f_a1vV v_B1
                                $cfoldr_a31G @f_a1vV v_B1
                                $cfoldr'_a323 @f_a1vV v_B1
                                $cfoldl_a32f @f_a1vV v_B1
                                $cfoldl'_a32r @f_a1vV v_B1
                                $cfoldr1_a32D @f_a1vV v_B1
                                $cfoldl1_a32N @f_a1vV v_B1
                                $ctoList_a32X @f_a1vV v_B1
                                $cnull_a337 @f_a1vV v_B1
                                $clength_a33i @f_a1vV v_B1
                                $celem_a33s @f_a1vV v_B1
                                $cmaximum_a33E @f_a1vV v_B1
                                $cminimum_a33Q @f_a1vV v_B1
                                $csum_a342 @f_a1vV v_B1
                                $cproduct_a34e @f_a1vV v_B1]
Main.$fFoldableApply
  = \ (@(f_a30Y :: * -> *)) ($dFoldable_a30Z :: Foldable f_a30Y) ->
      Data.Foldable.C:Foldable
        @(Apply f_a30Y)
        ($cfold_a311 @f_a30Y $dFoldable_a30Z)
        ($cfoldMap_a31d @f_a30Y $dFoldable_a30Z)
        ($cfoldMap'_a31s @f_a30Y $dFoldable_a30Z)
        ($cfoldr_a31G @f_a30Y $dFoldable_a30Z)
        ($cfoldr'_a323 @f_a30Y $dFoldable_a30Z)
        ($cfoldl_a32f @f_a30Y $dFoldable_a30Z)
        ($cfoldl'_a32r @f_a30Y $dFoldable_a30Z)
        ($cfoldr1_a32D @f_a30Y $dFoldable_a30Z)
        ($cfoldl1_a32N @f_a30Y $dFoldable_a30Z)
        ($ctoList_a32X @f_a30Y $dFoldable_a30Z)
        ($cnull_a337 @f_a30Y $dFoldable_a30Z)
        ($clength_a33i @f_a30Y $dFoldable_a30Z)
        ($celem_a33s @f_a30Y $dFoldable_a30Z)
        ($cmaximum_a33E @f_a30Y $dFoldable_a30Z)
        ($cminimum_a33Q @f_a30Y $dFoldable_a30Z)
        ($csum_a342 @f_a30Y $dFoldable_a30Z)
        ($cproduct_a34e @f_a30Y $dFoldable_a30Z)

-- RHS size: {terms: 17, types: 25, coercions: 25, joins: 0/0}
$csum_a342 [Occ=LoopBreaker]
  :: forall (f :: * -> *) a. (Foldable f, Num a) => Apply f a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 140 60}]
$csum_a342
  = \ (@(f_a30Y :: * -> *))
      ($dFoldable_a30Z :: Foldable f_a30Y)
      (@a_a345)
      ($dNum_a346 :: Num a_a345) ->
      ((\ (@(t_a4WR :: * -> *))
          ($dFoldable_a4WS :: Foldable t_a4WR)
          (@a_a4WT)
          ($dNum_a4WU :: Num a_a4WT) ->
          Data.Foldable.foldMap'
            @t_a4WR
            $dFoldable_a4WS
            @(base:Data.Semigroup.Internal.Sum a_a4WT)
            @a_a4WT
            (base:Data.Semigroup.Internal.$fMonoidSum @a_a4WT $dNum_a4WU)
            ((\ (ds_a52f :: a_a4WT) -> ds_a52f)
             `cast` (<a_a4WT>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Sum[0]
                                              <a_a4WT>_R)
                     :: (a_a4WT -> a_a4WT)
                        ~R# (a_a4WT -> base:Data.Semigroup.Internal.Sum a_a4WT))))
       `cast` (forall (t :: <* -> *>_N).
               <Foldable t>_R
               %<'Many>_N ->_R forall (a :: <*>_N).
                               <Num a>_R
                               %<'Many>_N ->_R <t a>_R
                               %<'Many>_N ->_R base:Data.Semigroup.Internal.N:Sum[0] <a>_R
               :: (forall {t :: * -> *} {a}.
                   (Foldable t, Num a) =>
                   t a -> base:Data.Semigroup.Internal.Sum a)
                  ~R# (forall {t :: * -> *} {a}. (Foldable t, Num a) => t a -> a)))
        @(Apply f_a30Y)
        (Main.$fFoldableApply @f_a30Y $dFoldable_a30Z)
        @a_a345
        $dNum_a346

-- RHS size: {terms: 27, types: 36, coercions: 8, joins: 0/2}
$cminimum_a33Q [Occ=LoopBreaker]
  :: forall (f :: * -> *) a. (Foldable f, Ord a) => Apply f a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 280 60}]
$cminimum_a33Q
  = \ (@(f_a30Y :: * -> *))
      ($dFoldable_a30Z :: Foldable f_a30Y)
      (@a_a33T)
      ($dOrd_a33U :: Ord a_a33T) ->
      let {
        d_a52o :: a_a33T
        [LclId,
         Str=b,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 110 0}]
        d_a52o
          = errorWithoutStackTrace
              @GHC.Types.LiftedRep
              @a_a33T
              (GHC.Base.build
                 @Char
                 (\ (@b_a52t) ->
                    GHC.CString.unpackFoldrCString#
                      @b_a52t "minimum: empty structure"#)) } in
      let {
        g_a52v :: Apply f_a30Y a_a33T -> base:Data.Functor.Utils.Min a_a33T
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 100 0}]
        g_a52v
          = Data.Foldable.foldMap'
              @(Apply f_a30Y)
              (Main.$fFoldableApply @f_a30Y $dFoldable_a30Z)
              @(base:Data.Functor.Utils.Min a_a33T)
              @a_a33T
              (base:Data.Functor.Utils.$fMonoidMin @a_a33T $dOrd_a33U)
              ((\ (ds_a53M :: a_a33T) -> GHC.Maybe.Just @a_a33T ds_a53M)
               `cast` (<a_a33T>_R
                       %<'Many>_N ->_R Sym (base:Data.Functor.Utils.N:Min[0]) <a_a33T>_N
                       :: (a_a33T -> GHC.Maybe.Maybe a_a33T)
                          ~R# (a_a33T -> base:Data.Functor.Utils.Min a_a33T))) } in
      \ (x_a53N :: Apply f_a30Y a_a33T) ->
        case (g_a52v x_a53N)
             `cast` (base:Data.Functor.Utils.N:Min[0] <a_a33T>_N
                     :: base:Data.Functor.Utils.Min a_a33T ~R# GHC.Maybe.Maybe a_a33T)
        of {
          GHC.Maybe.Nothing -> d_a52o;
          GHC.Maybe.Just v_a54h -> v_a54h
        }

-- RHS size: {terms: 27, types: 36, coercions: 8, joins: 0/2}
$cmaximum_a33E [Occ=LoopBreaker]
  :: forall (f :: * -> *) a. (Foldable f, Ord a) => Apply f a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 280 60}]
$cmaximum_a33E
  = \ (@(f_a30Y :: * -> *))
      ($dFoldable_a30Z :: Foldable f_a30Y)
      (@a_a33H)
      ($dOrd_a33I :: Ord a_a33H) ->
      let {
        d_a54n :: a_a33H
        [LclId,
         Str=b,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 110 0}]
        d_a54n
          = errorWithoutStackTrace
              @GHC.Types.LiftedRep
              @a_a33H
              (GHC.Base.build
                 @Char
                 (\ (@b_a54o) ->
                    GHC.CString.unpackFoldrCString#
                      @b_a54o "maximum: empty structure"#)) } in
      let {
        g_a54p :: Apply f_a30Y a_a33H -> base:Data.Functor.Utils.Max a_a33H
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 100 0}]
        g_a54p
          = Data.Foldable.foldMap'
              @(Apply f_a30Y)
              (Main.$fFoldableApply @f_a30Y $dFoldable_a30Z)
              @(base:Data.Functor.Utils.Max a_a33H)
              @a_a33H
              (base:Data.Functor.Utils.$fMonoidMax @a_a33H $dOrd_a33I)
              ((\ (ds_a54r :: a_a33H) -> GHC.Maybe.Just @a_a33H ds_a54r)
               `cast` (<a_a33H>_R
                       %<'Many>_N ->_R Sym (base:Data.Functor.Utils.N:Max[0]) <a_a33H>_N
                       :: (a_a33H -> GHC.Maybe.Maybe a_a33H)
                          ~R# (a_a33H -> base:Data.Functor.Utils.Max a_a33H))) } in
      \ (x_a54s :: Apply f_a30Y a_a33H) ->
        case (g_a54p x_a54s)
             `cast` (base:Data.Functor.Utils.N:Max[0] <a_a33H>_N
                     :: base:Data.Functor.Utils.Max a_a33H ~R# GHC.Maybe.Maybe a_a33H)
        of {
          GHC.Maybe.Nothing -> d_a54n;
          GHC.Maybe.Just v_a54x -> v_a54x
        }

-- RHS size: {terms: 18, types: 24, coercions: 26, joins: 0/0}
$celem_a33s [Occ=LoopBreaker]
  :: forall (f :: * -> *) a.
     (Foldable f, Eq a) =>
     a -> Apply f a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 150 60}]
$celem_a33s
  = \ (@(f_a30Y :: * -> *))
      ($dFoldable_a30Z :: Foldable f_a30Y)
      (@a_a33v)
      ($dEq_a33w :: Eq a_a33v) ->
      ((\ (@(t_a54z :: * -> *))
          ($dFoldable_a54A :: Foldable t_a54z)
          (@a_a54B)
          ($dEq_a54C :: Eq a_a54B)
          (eta_a54D :: a_a54B) ->
          foldMap
            @t_a54z
            $dFoldable_a54A
            @base:Data.Semigroup.Internal.Any
            @a_a54B
            base:Data.Semigroup.Internal.$fMonoidAny
            ((== @a_a54B $dEq_a54C eta_a54D)
             `cast` (<a_a54B>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Any[0])
                     :: (a_a54B -> Bool)
                        ~R# (a_a54B -> base:Data.Semigroup.Internal.Any))))
       `cast` (forall (t :: <* -> *>_N).
               <Foldable t>_R
               %<'Many>_N ->_R forall (a :: <*>_N).
                               <Eq a>_R
                               %<'Many>_N ->_R <a>_R
                               %<'Many>_N ->_R <t a>_R
                               %<'Many>_N ->_R base:Data.Semigroup.Internal.N:Any[0]
               :: (forall {t :: * -> *} {a}.
                   (Foldable t, Eq a) =>
                   a -> t a -> base:Data.Semigroup.Internal.Any)
                  ~R# (forall {t :: * -> *} {a}.
                       (Foldable t, Eq a) =>
                       a -> t a -> Bool)))
        @(Apply f_a30Y)
        (Main.$fFoldableApply @f_a30Y $dFoldable_a30Z)
        @a_a33v
        $dEq_a33w

-- RHS size: {terms: 17, types: 15, coercions: 0, joins: 0/0}
$clength_a33i [Occ=LoopBreaker]
  :: forall (f :: * -> *) a. Foldable f => Apply f a -> Int
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 111 0}]
$clength_a33i
  = \ (@(f_a30Y :: * -> *))
      ($dFoldable_a30Z :: Foldable f_a30Y)
      (@a_a33l) ->
      Data.Foldable.foldl'
        @(Apply f_a30Y)
        (Main.$fFoldableApply @f_a30Y $dFoldable_a30Z)
        @Int
        @a_a33l
        (\ (c_a54K :: Int) _ [Occ=Dead] ->
           case c_a54K of { GHC.Types.I# x_a54N ->
           GHC.Types.I# (GHC.Prim.+# x_a54N 1#)
           })
        (GHC.Types.I# 0#)

-- RHS size: {terms: 16, types: 25, coercions: 0, joins: 0/1}
$ctoList_a32X [Occ=LoopBreaker]
  :: forall (f :: * -> *) a. Foldable f => Apply f a -> [a]
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 110 60}]
$ctoList_a32X
  = \ (@(f_a30Y :: * -> *))
      ($dFoldable_a30Z :: Foldable f_a30Y)
      (@a_a330) ->
      let {
        $dFoldable_a54Q :: Foldable (Apply f_a30Y)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dFoldable_a54Q = Main.$fFoldableApply @f_a30Y $dFoldable_a30Z } in
      \ (t1_a54S :: Apply f_a30Y a_a330) ->
        GHC.Base.build
          @a_a330
          (\ (@b_a54T)
             (c_a54U [OS=OneShot] :: a_a330 -> b_a54T -> b_a54T)
             (n_a54V [OS=OneShot] :: b_a54T) ->
             foldr
               @(Apply f_a30Y)
               $dFoldable_a54Q
               @a_a330
               @b_a54T
               c_a54U
               n_a54V
               t1_a54S)

-- RHS size: {terms: 32, types: 39, coercions: 0, joins: 0/1}
$cfoldl1_a32N [Occ=LoopBreaker]
  :: forall (f :: * -> *) a.
     Foldable f =>
     (a -> a -> a) -> Apply f a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 310 60}]
$cfoldl1_a32N
  = \ (@(f_a30Y :: * -> *))
      ($dFoldable_a30Z :: Foldable f_a30Y)
      (@a_a32Q) ->
      let {
        $dFoldable_a54X :: Foldable (Apply f_a30Y)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dFoldable_a54X = Main.$fFoldableApply @f_a30Y $dFoldable_a30Z } in
      \ (f_a54Z :: a_a32Q -> a_a32Q -> a_a32Q)
        (xs_a550 :: Apply f_a30Y a_a32Q) ->
        case foldl
               @(Apply f_a30Y)
               $dFoldable_a54X
               @(GHC.Maybe.Maybe a_a32Q)
               @a_a32Q
               (\ (m_a551 :: GHC.Maybe.Maybe a_a32Q) (y_a552 :: a_a32Q) ->
                  GHC.Maybe.Just
                    @a_a32Q
                    (case m_a551 of {
                       GHC.Maybe.Nothing -> y_a552;
                       GHC.Maybe.Just x_a555 -> f_a54Z x_a555 y_a552
                     }))
               (GHC.Maybe.Nothing @a_a32Q)
               xs_a550
        of {
          GHC.Maybe.Nothing ->
            errorWithoutStackTrace
              @GHC.Types.LiftedRep
              @a_a32Q
              (GHC.Base.build
                 @Char
                 (\ (@b_a558) ->
                    GHC.CString.unpackFoldrCString#
                      @b_a558 "foldl1: empty structure"#));
          GHC.Maybe.Just v_a559 -> v_a559
        }

-- RHS size: {terms: 32, types: 39, coercions: 0, joins: 0/1}
$cfoldr1_a32D [Occ=LoopBreaker]
  :: forall (f :: * -> *) a.
     Foldable f =>
     (a -> a -> a) -> Apply f a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 310 60}]
$cfoldr1_a32D
  = \ (@(f_a30Y :: * -> *))
      ($dFoldable_a30Z :: Foldable f_a30Y)
      (@a_a32G) ->
      let {
        $dFoldable_a55d :: Foldable (Apply f_a30Y)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dFoldable_a55d = Main.$fFoldableApply @f_a30Y $dFoldable_a30Z } in
      \ (f_a55f :: a_a32G -> a_a32G -> a_a32G)
        (xs_a55g :: Apply f_a30Y a_a32G) ->
        case foldr
               @(Apply f_a30Y)
               $dFoldable_a55d
               @a_a32G
               @(GHC.Maybe.Maybe a_a32G)
               (\ (x_a55h :: a_a32G) (m_a55i :: GHC.Maybe.Maybe a_a32G) ->
                  GHC.Maybe.Just
                    @a_a32G
                    (case m_a55i of {
                       GHC.Maybe.Nothing -> x_a55h;
                       GHC.Maybe.Just y_a55l -> f_a55f x_a55h y_a55l
                     }))
               (GHC.Maybe.Nothing @a_a32G)
               xs_a55g
        of {
          GHC.Maybe.Nothing ->
            errorWithoutStackTrace
              @GHC.Types.LiftedRep
              @a_a32G
              (GHC.Base.build
                 @Char
                 (\ (@b_a55o) ->
                    GHC.CString.unpackFoldrCString#
                      @b_a55o "foldr1: empty structure"#));
          GHC.Maybe.Just v_a55p -> v_a55p
        }

-- RHS size: {terms: 25, types: 31, coercions: 0, joins: 0/1}
$cfoldl'_a32r [Occ=LoopBreaker]
  :: forall (f :: * -> *) b a.
     Foldable f =>
     (b -> a -> b) -> b -> Apply f a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 210 60}]
$cfoldl'_a32r
  = \ (@(f_a30Y :: * -> *))
      ($dFoldable_a30Z :: Foldable f_a30Y)
      (@b_a32u)
      (@a_a32v) ->
      let {
        $dFoldable_a55t :: Foldable (Apply f_a30Y)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dFoldable_a55t = Main.$fFoldableApply @f_a30Y $dFoldable_a30Z } in
      \ (f_a55w :: b_a32u -> a_a32v -> b_a32u)
        (z0_a55x :: b_a32u)
        (xs_a55y :: Apply f_a30Y a_a32v) ->
        foldr
          @(Apply f_a30Y)
          $dFoldable_a55t
          @a_a32v
          @(b_a32u -> b_a32u)
          (\ (ds_a55z :: a_a32v)
             (ds1_a55A :: b_a32u -> b_a32u)
             (v_a55B [OS=OneShot] :: b_a32u) ->
             case v_a55B of z_a55C { __DEFAULT ->
             ds1_a55A (f_a55w z_a55C ds_a55z)
             })
          (id @b_a32u)
          xs_a55y
          z0_a55x

-- RHS size: {terms: 21, types: 31, coercions: 10, joins: 0/1}
$cfoldl_a32f [Occ=LoopBreaker]
  :: forall (f :: * -> *) b a.
     Foldable f =>
     (b -> a -> b) -> b -> Apply f a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 190 60}]
$cfoldl_a32f
  = \ (@(f_a30Y :: * -> *))
      ($dFoldable_a30Z :: Foldable f_a30Y)
      (@b_a32i)
      (@a_a32j) ->
      let {
        $dFoldable_a55F :: Foldable (Apply f_a30Y)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dFoldable_a55F = Main.$fFoldableApply @f_a30Y $dFoldable_a30Z } in
      \ (eta_a55I :: b_a32i -> a_a32j -> b_a32i)
        (eta1_a55J :: b_a32i)
        (eta2_a55K :: Apply f_a30Y a_a32j) ->
        ((foldMap
            @(Apply f_a30Y)
            $dFoldable_a55F
            @(base:Data.Semigroup.Internal.Dual
                (base:Data.Semigroup.Internal.Endo b_a32i))
            @a_a32j
            (base:Data.Semigroup.Internal.$fMonoidDual
               @(base:Data.Semigroup.Internal.Endo b_a32i)
               (base:Data.Semigroup.Internal.$fMonoidEndo @b_a32i))
            ((\ (x_a55N :: a_a32j) (y_a55O :: b_a32i) ->
                eta_a55I y_a55O x_a55N)
             `cast` (<a_a32j>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Dual[0]
                                              (base:Data.Semigroup.Internal.N:Endo[0] <b_a32i>_R))
                     :: (a_a32j -> b_a32i -> b_a32i)
                        ~R# (a_a32j
                             -> base:Data.Semigroup.Internal.Dual
                                  (base:Data.Semigroup.Internal.Endo b_a32i))))
            eta2_a55K)
         `cast` (base:Data.Semigroup.Internal.N:Dual[0]
                     (base:Data.Semigroup.Internal.N:Endo[0] <b_a32i>_R)
                 :: base:Data.Semigroup.Internal.Dual
                      (base:Data.Semigroup.Internal.Endo b_a32i)
                    ~R# (b_a32i -> b_a32i)))
          eta1_a55J

-- RHS size: {terms: 25, types: 31, coercions: 0, joins: 0/1}
$cfoldr'_a323 [Occ=LoopBreaker]
  :: forall (f :: * -> *) a b.
     Foldable f =>
     (a -> b -> b) -> b -> Apply f a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 210 60}]
$cfoldr'_a323
  = \ (@(f_a30Y :: * -> *))
      ($dFoldable_a30Z :: Foldable f_a30Y)
      (@a_a326)
      (@b_a327) ->
      let {
        $dFoldable_a55U :: Foldable (Apply f_a30Y)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dFoldable_a55U = Main.$fFoldableApply @f_a30Y $dFoldable_a30Z } in
      \ (f_a55X :: a_a326 -> b_a327 -> b_a327)
        (z0_a55Y :: b_a327)
        (xs_a55Z :: Apply f_a30Y a_a326) ->
        foldl
          @(Apply f_a30Y)
          $dFoldable_a55U
          @(b_a327 -> b_a327)
          @a_a326
          (\ (ds_a560 :: b_a327 -> b_a327)
             (ds1_a561 :: a_a326)
             (v_a562 [OS=OneShot] :: b_a327) ->
             case v_a562 of z_a563 { __DEFAULT ->
             ds_a560 (f_a55X ds1_a561 z_a563)
             })
          (id @b_a327)
          xs_a55Z
          z0_a55Y

-- RHS size: {terms: 23, types: 27, coercions: 0, joins: 0/2}
$cfoldMap'_a31s [Occ=LoopBreaker]
  :: forall (f :: * -> *) m a.
     (Foldable f, Monoid m) =>
     (a -> m) -> Apply f a -> m
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 60] 210 60}]
$cfoldMap'_a31s
  = \ (@(f_a30Y :: * -> *))
      ($dFoldable_a30Z :: Foldable f_a30Y)
      (@m_a31v)
      (@a_a31w)
      ($dMonoid_a31x :: Monoid m_a31v) ->
      let {
        $dFoldable_a565 :: Foldable (Apply f_a30Y)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dFoldable_a565 = Main.$fFoldableApply @f_a30Y $dFoldable_a30Z } in
      \ (eta_a569 :: a_a31w -> m_a31v) ->
        let {
          $dSemigroup_a56a :: Semigroup m_a31v
          [LclId,
           Unf=Unf{Src=<vanilla>, TopLvl=False,
                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                   Guidance=IF_ARGS [] 20 0}]
          $dSemigroup_a56a = GHC.Base.$p1Monoid @m_a31v $dMonoid_a31x } in
        Data.Foldable.foldl'
          @(Apply f_a30Y)
          $dFoldable_a565
          @m_a31v
          @a_a31w
          (\ (acc_a56b :: m_a31v) (a1_a56c :: a_a31w) ->
             <> @m_a31v $dSemigroup_a56a acc_a56b (eta_a569 a1_a56c))
          (mempty @m_a31v $dMonoid_a31x)

-- RHS size: {terms: 17, types: 25, coercions: 25, joins: 0/0}
$cproduct_a34e [Occ=LoopBreaker]
  :: forall (f :: * -> *) a. (Foldable f, Num a) => Apply f a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 140 60}]
$cproduct_a34e
  = \ (@(f_a30Y :: * -> *))
      ($dFoldable_a30Z :: Foldable f_a30Y)
      (@a_a34h)
      ($dNum_a34i :: Num a_a34h) ->
      ((\ (@(t_a56d :: * -> *))
          ($dFoldable_a56e :: Foldable t_a56d)
          (@a_a56f)
          ($dNum_a56g :: Num a_a56f) ->
          Data.Foldable.foldMap'
            @t_a56d
            $dFoldable_a56e
            @(base:Data.Semigroup.Internal.Product a_a56f)
            @a_a56f
            (base:Data.Semigroup.Internal.$fMonoidProduct @a_a56f $dNum_a56g)
            ((\ (ds_a56i :: a_a56f) -> ds_a56i)
             `cast` (<a_a56f>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Product[0]
                                              <a_a56f>_R)
                     :: (a_a56f -> a_a56f)
                        ~R# (a_a56f -> base:Data.Semigroup.Internal.Product a_a56f))))
       `cast` (forall (t :: <* -> *>_N).
               <Foldable t>_R
               %<'Many>_N ->_R forall (a :: <*>_N).
                               <Num a>_R
                               %<'Many>_N ->_R <t a>_R
                               %<'Many>_N ->_R base:Data.Semigroup.Internal.N:Product[0] <a>_R
               :: (forall {t :: * -> *} {a}.
                   (Foldable t, Num a) =>
                   t a -> base:Data.Semigroup.Internal.Product a)
                  ~R# (forall {t :: * -> *} {a}. (Foldable t, Num a) => t a -> a)))
        @(Apply f_a30Y)
        (Main.$fFoldableApply @f_a30Y $dFoldable_a30Z)
        @a_a34h
        $dNum_a34i

-- RHS size: {terms: 9, types: 14, coercions: 0, joins: 0/0}
$cfold_a311 [Occ=LoopBreaker]
  :: forall (f :: * -> *) m. (Foldable f, Monoid m) => Apply f m -> m
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 60 0}]
$cfold_a311
  = \ (@(f_a30Y :: * -> *))
      ($dFoldable_a30Z :: Foldable f_a30Y)
      (@m_a314)
      ($dMonoid_a315 :: Monoid m_a314) ->
      foldMap
        @(Apply f_a30Y)
        (Main.$fFoldableApply @f_a30Y $dFoldable_a30Z)
        @m_a314
        @m_a314
        $dMonoid_a315
        (id @m_a314)
end Rec }

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
$cp2Traversable_a4bG
  :: forall {f :: * -> *}. Traversable f => Foldable (Apply f)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30] 40 0}]
$cp2Traversable_a4bG
  = \ (@(f_a4bx :: * -> *))
      ($dTraversable_a4by :: Traversable f_a4bx) ->
      Main.$fFoldableApply
        @f_a4bx
        (Data.Traversable.$p2Traversable @f_a4bx $dTraversable_a4by)

-- RHS size: {terms: 14, types: 23, coercions: 0, joins: 0/0}
$c<$_a30F
  :: forall (f :: * -> *) a b.
     Functor f =>
     a -> Apply f b -> Apply f a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 0 20] 60 10}]
$c<$_a30F
  = \ (@(f_a30l :: * -> *))
      ($dFunctor_a30m :: Functor f_a30l)
      (@a_a30I)
      (@b_a30J)
      (z_a2b2 :: a_a30I)
      (ds_d4Mj :: Apply f_a30l b_a30J) ->
      case ds_d4Mj of { MkApply a1_a2b3 ->
      Main.MkApply
        @(*)
        @f_a30l
        @a_a30I
        (<$ @f_a30l $dFunctor_a30m @a_a30I @b_a30J z_a2b2 a1_a2b3)
      }

-- RHS size: {terms: 14, types: 24, coercions: 0, joins: 0/0}
$cfmap_a30o
  :: forall (f :: * -> *) a b.
     Functor f =>
     (a -> b) -> Apply f a -> Apply f b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 0 20] 60 10}]
$cfmap_a30o
  = \ (@(f_a30l :: * -> *))
      ($dFunctor_a30m :: Functor f_a30l)
      (@a_a30r)
      (@b_a30s)
      (f_a2b0 :: a_a30r -> b_a30s)
      (ds_d4Mf :: Apply f_a30l a_a30r) ->
      case ds_d4Mf of { MkApply a1_a2b1 ->
      Main.MkApply
        @(*)
        @f_a30l
        @b_a30s
        (fmap @f_a30l $dFunctor_a30m @a_a30r @b_a30s f_a2b0 a1_a2b1)
      }

-- RHS size: {terms: 7, types: 9, coercions: 0, joins: 0/0}
Main.$fFunctorApply [InlPrag=CONLIKE]
  :: forall (f :: * -> *). Functor f => Functor (Apply f)
[LclIdX[DFunId],
 Unf=DFun: \ (@(f_a1vP :: * -> *)) (v_B1 :: Functor f_a1vP) ->
       GHC.Base.C:Functor TYPE: Apply f_a1vP
                          $cfmap_a30o @f_a1vP v_B1
                          $c<$_a30F @f_a1vP v_B1]
Main.$fFunctorApply
  = \ (@(f_a30l :: * -> *)) ($dFunctor_a30m :: Functor f_a30l) ->
      GHC.Base.C:Functor
        @(Apply f_a30l)
        ($cfmap_a30o @f_a30l $dFunctor_a30m)
        ($c<$_a30F @f_a30l $dFunctor_a30m)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
$cp1Traversable_a4bC
  :: forall {f :: * -> *}. Traversable f => Functor (Apply f)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30] 40 0}]
$cp1Traversable_a4bC
  = \ (@(f_a4bx :: * -> *))
      ($dTraversable_a4by :: Traversable f_a4bx) ->
      Main.$fFunctorApply
        @f_a4bx
        (Data.Traversable.$p1Traversable @f_a4bx $dTraversable_a4by)

Rec {
-- RHS size: {terms: 15, types: 13, coercions: 0, joins: 0/0}
Main.$fTraversableApply [InlPrag=CONLIKE]
  :: forall (f :: * -> *). Traversable f => Traversable (Apply f)
[LclIdX[DFunId],
 Unf=DFun: \ (@(f_aUv :: * -> *)) (v_B1 :: Traversable f_aUv) ->
       Data.Traversable.C:Traversable TYPE: Apply f_aUv
                                      $cp1Traversable_a4bC @f_aUv v_B1
                                      $cp2Traversable_a4bG @f_aUv v_B1
                                      $ctraverse_a4bI @f_aUv v_B1
                                      $csequenceA_a4bY @f_aUv v_B1
                                      $cmapM_a4cc @f_aUv v_B1
                                      $csequence_a4cs @f_aUv v_B1]
Main.$fTraversableApply
  = \ (@(f_a4bx :: * -> *))
      ($dTraversable_a4by :: Traversable f_a4bx) ->
      Data.Traversable.C:Traversable
        @(Apply f_a4bx)
        ($cp1Traversable_a4bC @f_a4bx $dTraversable_a4by)
        ($cp2Traversable_a4bG @f_a4bx $dTraversable_a4by)
        ($ctraverse_a4bI @f_a4bx $dTraversable_a4by)
        ($csequenceA_a4bY @f_a4bx $dTraversable_a4by)
        ($cmapM_a4cc @f_a4bx $dTraversable_a4by)
        ($csequence_a4cs @f_a4bx $dTraversable_a4by)

-- RHS size: {terms: 11, types: 18, coercions: 0, joins: 0/0}
$cmapM_a4cc [Occ=LoopBreaker]
  :: forall (f :: * -> *) (m :: * -> *) a b.
     (Traversable f, Monad m) =>
     (a -> m b) -> Apply f a -> m (Apply f b)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 30] 70 0}]
$cmapM_a4cc
  = \ (@(f_a4bx :: * -> *))
      ($dTraversable_a4by :: Traversable f_a4bx)
      (@(m_a4cf :: * -> *))
      (@a_a4cg)
      (@b_a4ch)
      ($dMonad_a4ci :: Monad m_a4cf) ->
      traverse
        @(Apply f_a4bx)
        (Main.$fTraversableApply @f_a4bx $dTraversable_a4by)
        @m_a4cf
        @a_a4cg
        @b_a4ch
        (GHC.Base.$p1Monad @m_a4cf $dMonad_a4ci)

-- RHS size: {terms: 10, types: 19, coercions: 0, joins: 0/0}
$csequenceA_a4bY [Occ=LoopBreaker]
  :: forall (f :: * -> *) (f :: * -> *) a.
     (Traversable f, Applicative f) =>
     Apply f (f a) -> f (Apply f a)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 60 0}]
$csequenceA_a4bY
  = \ (@(f_a4bx :: * -> *))
      ($dTraversable_a4by :: Traversable f_a4bx)
      (@(f_a4c1 :: * -> *))
      (@a_a4c2)
      ($dApplicative_a4c3 :: Applicative f_a4c1) ->
      traverse
        @(Apply f_a4bx)
        (Main.$fTraversableApply @f_a4bx $dTraversable_a4by)
        @f_a4c1
        @(f_a4c1 a_a4c2)
        @a_a4c2
        $dApplicative_a4c3
        (id @(f_a4c1 a_a4c2))

-- RHS size: {terms: 10, types: 16, coercions: 0, joins: 0/0}
$csequence_a4cs [Occ=LoopBreaker]
  :: forall (f :: * -> *) (m :: * -> *) a.
     (Traversable f, Monad m) =>
     Apply f (m a) -> m (Apply f a)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 30] 70 0}]
$csequence_a4cs
  = \ (@(f_a4bx :: * -> *))
      ($dTraversable_a4by :: Traversable f_a4bx)
      (@(m_a4cv :: * -> *))
      (@a_a4cw)
      ($dMonad_a4cx :: Monad m_a4cv) ->
      sequenceA
        @(Apply f_a4bx)
        (Main.$fTraversableApply @f_a4bx $dTraversable_a4by)
        @m_a4cv
        @a_a4cw
        (GHC.Base.$p1Monad @m_a4cv $dMonad_a4cx)

-- RHS size: {terms: 23, types: 55, coercions: 0, joins: 0/3}
$ctraverse_a4bI [Occ=LoopBreaker]
  :: forall (f :: * -> *) (f :: * -> *) a b.
     (Traversable f, Applicative f) =>
     (a -> f b) -> Apply f a -> f (Apply f b)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 190 60}]
$ctraverse_a4bI
  = \ (@(f_a4bx :: * -> *))
      ($dTraversable_a4by :: Traversable f_a4bx)
      (@(f_a4bL :: * -> *))
      (@a_a4bM)
      (@b_a4bN)
      ($dApplicative_a4bO :: Applicative f_a4bL) ->
      let {
        $dTraversable_a56I :: Traversable (Apply f_a4bx)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dTraversable_a56I
          = Main.$fTraversableApply @f_a4bx $dTraversable_a4by } in
      \ (eta1_a56N :: a_a4bM -> f_a4bL b_a4bN) ->
        let {
          f1_a56O
            :: Apply f_a4bx (f_a4bL b_a4bN) -> f_a4bL (Apply f_a4bx b_a4bN)
          [LclId,
           Unf=Unf{Src=<vanilla>, TopLvl=False,
                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                   Guidance=IF_ARGS [] 30 0}]
          f1_a56O
            = sequenceA
                @(Apply f_a4bx)
                $dTraversable_a56I
                @f_a4bL
                @b_a4bN
                $dApplicative_a4bO } in
        let {
          g_a56P :: Apply f_a4bx a_a4bM -> Apply f_a4bx (f_a4bL b_a4bN)
          [LclId,
           Unf=Unf{Src=<vanilla>, TopLvl=False,
                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                   Guidance=IF_ARGS [] 50 0}]
          g_a56P
            = fmap
                @(Apply f_a4bx)
                (Data.Traversable.$p1Traversable
                   @(Apply f_a4bx) $dTraversable_a56I)
                @a_a4bM
                @(f_a4bL b_a4bN)
                eta1_a56N } in
        \ (x_a56Q :: Apply f_a4bx a_a4bM) -> f1_a56O (g_a56P x_a56Q)
end Rec }

-- RHS size: {terms: 24, types: 24, coercions: 0, joins: 0/0}
$cshowsPrec_a2ZS
  :: forall k (f :: k -> *) (a :: k).
     Show (f a) =>
     Int -> Apply f a -> ShowS
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 0 20] 240 0}]
$cshowsPrec_a2ZS
  = \ (@k_a2ZN)
      (@(f_a2ZO :: k_a2ZN -> *))
      (@(a_a2ZP :: k_a2ZN))
      ($dShow_a2ZQ :: Show (f_a2ZO a_a2ZP))
      (a_a2aY :: Int)
      (ds_d4M6 :: Apply f_a2ZO a_a2ZP) ->
      case ds_d4M6 of { MkApply b1_a2aZ ->
      showParen
        (>= @Int GHC.Classes.$fOrdInt a_a2aY (GHC.Types.I# 11#))
        (. @String
           @String
           @String
           (showString (GHC.CString.unpackCString# "MkApply "#))
           (showsPrec
              @(f_a2ZO a_a2ZP) $dShow_a2ZQ (GHC.Types.I# 11#) b1_a2aZ))
      }

Rec {
-- RHS size: {terms: 11, types: 20, coercions: 0, joins: 0/0}
Main.$fShowApply [InlPrag=CONLIKE]
  :: forall k (f :: k -> *) (a :: k). Show (f a) => Show (Apply f a)
[LclIdX[DFunId],
 Unf=DFun: \ (@k_a1vH)
             (@(f_a1vI :: k_a1vH -> *))
             (@(a_a1vJ :: k_a1vH))
             (v_B1 :: Show (f_a1vI a_a1vJ)) ->
       GHC.Show.C:Show TYPE: Apply f_a1vI a_a1vJ
                       $cshowsPrec_a2ZS @k_a1vH @f_a1vI @a_a1vJ v_B1
                       $cshow_a305 @k_a1vH @f_a1vI @a_a1vJ v_B1
                       $cshowList_a30c @k_a1vH @f_a1vI @a_a1vJ v_B1]
Main.$fShowApply
  = \ (@k_a2ZN)
      (@(f_a2ZO :: k_a2ZN -> *))
      (@(a_a2ZP :: k_a2ZN))
      ($dShow_a2ZQ :: Show (f_a2ZO a_a2ZP)) ->
      GHC.Show.C:Show
        @(Apply f_a2ZO a_a2ZP)
        ($cshowsPrec_a2ZS @k_a2ZN @f_a2ZO @a_a2ZP $dShow_a2ZQ)
        ($cshow_a305 @k_a2ZN @f_a2ZO @a_a2ZP $dShow_a2ZQ)
        ($cshowList_a30c @k_a2ZN @f_a2ZO @a_a2ZP $dShow_a2ZQ)

-- RHS size: {terms: 16, types: 29, coercions: 0, joins: 0/1}
$cshowList_a30c [Occ=LoopBreaker]
  :: forall k (f :: k -> *) (a :: k).
     Show (f a) =>
     [Apply f a] -> ShowS
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 130 60}]
$cshowList_a30c
  = \ (@k_a2ZN)
      (@(f_a2ZO :: k_a2ZN -> *))
      (@(a_a2ZP :: k_a2ZN))
      ($dShow_a2ZQ :: Show (f_a2ZO a_a2ZP)) ->
      let {
        $dShow_a56S :: Show (Apply f_a2ZO a_a2ZP)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dShow_a56S
          = Main.$fShowApply @k_a2ZN @f_a2ZO @a_a2ZP $dShow_a2ZQ } in
      \ (ls_a56T :: [Apply f_a2ZO a_a2ZP]) (s_a56U :: String) ->
        GHC.Show.showList__
          @(Apply f_a2ZO a_a2ZP)
          (showsPrec @(Apply f_a2ZO a_a2ZP) $dShow_a56S (GHC.Types.I# 0#))
          ls_a56T
          s_a56U

-- RHS size: {terms: 14, types: 24, coercions: 0, joins: 0/1}
$cshow_a305 [Occ=LoopBreaker]
  :: forall k (f :: k -> *) (a :: k).
     Show (f a) =>
     Apply f a -> String
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 100 60}]
$cshow_a305
  = \ (@k_a2ZN)
      (@(f_a2ZO :: k_a2ZN -> *))
      (@(a_a2ZP :: k_a2ZN))
      ($dShow_a2ZQ :: Show (f_a2ZO a_a2ZP)) ->
      let {
        $dShow_a56X :: Show (Apply f_a2ZO a_a2ZP)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dShow_a56X
          = Main.$fShowApply @k_a2ZN @f_a2ZO @a_a2ZP $dShow_a2ZQ } in
      \ (x_a56Y :: Apply f_a2ZO a_a2ZP) ->
        showsPrec
          @(Apply f_a2ZO a_a2ZP)
          $dShow_a56X
          (GHC.Types.I# 0#)
          x_a56Y
          (GHC.Types.[] @Char)
end Rec }

-- RHS size: {terms: 16, types: 29, coercions: 0, joins: 0/0}
$c==_a2Zv
  :: forall k (f :: k -> *) (a :: k).
     Eq (f a) =>
     Apply f a -> Apply f a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 20 20] 60 0}]
$c==_a2Zv
  = \ (@k_a2Zq)
      (@(f_a2Zr :: k_a2Zq -> *))
      (@(a_a2Zs :: k_a2Zq))
      ($dEq_a2Zt :: Eq (f_a2Zr a_a2Zs))
      (ds_d4LY :: Apply f_a2Zr a_a2Zs)
      (ds_d4LZ :: Apply f_a2Zr a_a2Zs) ->
      case ds_d4LY of { MkApply a1_a2aW ->
      case ds_d4LZ of { MkApply b1_a2aX ->
      == @(f_a2Zr a_a2Zs) $dEq_a2Zt a1_a2aW b1_a2aX
      }
      }

Rec {
-- RHS size: {terms: 9, types: 17, coercions: 0, joins: 0/0}
Main.$fEqApply [InlPrag=CONLIKE]
  :: forall k (f :: k -> *) (a :: k). Eq (f a) => Eq (Apply f a)
[LclIdX[DFunId],
 Unf=DFun: \ (@k_a1vz)
             (@(f_a1vA :: k_a1vz -> *))
             (@(a_a1vB :: k_a1vz))
             (v_B1 :: Eq (f_a1vA a_a1vB)) ->
       GHC.Classes.C:Eq TYPE: Apply f_a1vA a_a1vB
                        $c==_a2Zv @k_a1vz @f_a1vA @a_a1vB v_B1
                        $c/=_a2ZE @k_a1vz @f_a1vA @a_a1vB v_B1]
Main.$fEqApply
  = \ (@k_a2Zq)
      (@(f_a2Zr :: k_a2Zq -> *))
      (@(a_a2Zs :: k_a2Zq))
      ($dEq_a2Zt :: Eq (f_a2Zr a_a2Zs)) ->
      GHC.Classes.C:Eq
        @(Apply f_a2Zr a_a2Zs)
        ($c==_a2Zv @k_a2Zq @f_a2Zr @a_a2Zs $dEq_a2Zt)
        ($c/=_a2ZE @k_a2Zq @f_a2Zr @a_a2Zs $dEq_a2Zt)

-- RHS size: {terms: 18, types: 28, coercions: 0, joins: 0/1}
$c/=_a2ZE [Occ=LoopBreaker]
  :: forall k (f :: k -> *) (a :: k).
     Eq (f a) =>
     Apply f a -> Apply f a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 110 60}]
$c/=_a2ZE
  = \ (@k_a2Zq)
      (@(f_a2Zr :: k_a2Zq -> *))
      (@(a_a2Zs :: k_a2Zq))
      ($dEq_a2Zt :: Eq (f_a2Zr a_a2Zs)) ->
      let {
        $dEq_a570 :: Eq (Apply f_a2Zr a_a2Zs)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dEq_a570 = Main.$fEqApply @k_a2Zq @f_a2Zr @a_a2Zs $dEq_a2Zt } in
      \ (x_a571 :: Apply f_a2Zr a_a2Zs)
        (y_a572 :: Apply f_a2Zr a_a2Zs) ->
        case == @(Apply f_a2Zr a_a2Zs) $dEq_a570 x_a571 y_a572 of {
          False -> GHC.Types.True;
          True -> GHC.Types.False
        }
end Rec }

Rec {
-- RHS size: {terms: 37, types: 24, coercions: 0, joins: 0/0}
Main.$fFoldableFix [InlPrag=CONLIKE]
  :: forall (f :: * -> *). Foldable f => Foldable (Fix f)
[LclIdX[DFunId],
 Unf=DFun: \ (@(f_a1vt :: * -> *)) (v_B1 :: Foldable f_a1vt) ->
       Data.Foldable.C:Foldable TYPE: Fix f_a1vt
                                $cfold_a2VN @f_a1vt v_B1
                                $cfoldMap_a2VZ @f_a1vt v_B1
                                $cfoldMap'_a2Wj @f_a1vt v_B1
                                $cfoldr_a2Wx @f_a1vt v_B1
                                $cfoldr'_a2WY @f_a1vt v_B1
                                $cfoldl_a2Xa @f_a1vt v_B1
                                $cfoldl'_a2Xm @f_a1vt v_B1
                                $cfoldr1_a2Xy @f_a1vt v_B1
                                $cfoldl1_a2XI @f_a1vt v_B1
                                $ctoList_a2XS @f_a1vt v_B1
                                $cnull_a2Y2 @f_a1vt v_B1
                                $clength_a2Yg @f_a1vt v_B1
                                $celem_a2Yq @f_a1vt v_B1
                                $cmaximum_a2YC @f_a1vt v_B1
                                $cminimum_a2YO @f_a1vt v_B1
                                $csum_a2Z0 @f_a1vt v_B1
                                $cproduct_a2Zc @f_a1vt v_B1]
Main.$fFoldableFix
  = \ (@(f_a2VK :: * -> *)) ($dFoldable_a2VL :: Foldable f_a2VK) ->
      Data.Foldable.C:Foldable
        @(Fix f_a2VK)
        ($cfold_a2VN @f_a2VK $dFoldable_a2VL)
        ($cfoldMap_a2VZ @f_a2VK $dFoldable_a2VL)
        ($cfoldMap'_a2Wj @f_a2VK $dFoldable_a2VL)
        ($cfoldr_a2Wx @f_a2VK $dFoldable_a2VL)
        ($cfoldr'_a2WY @f_a2VK $dFoldable_a2VL)
        ($cfoldl_a2Xa @f_a2VK $dFoldable_a2VL)
        ($cfoldl'_a2Xm @f_a2VK $dFoldable_a2VL)
        ($cfoldr1_a2Xy @f_a2VK $dFoldable_a2VL)
        ($cfoldl1_a2XI @f_a2VK $dFoldable_a2VL)
        ($ctoList_a2XS @f_a2VK $dFoldable_a2VL)
        ($cnull_a2Y2 @f_a2VK $dFoldable_a2VL)
        ($clength_a2Yg @f_a2VK $dFoldable_a2VL)
        ($celem_a2Yq @f_a2VK $dFoldable_a2VL)
        ($cmaximum_a2YC @f_a2VK $dFoldable_a2VL)
        ($cminimum_a2YO @f_a2VK $dFoldable_a2VL)
        ($csum_a2Z0 @f_a2VK $dFoldable_a2VL)
        ($cproduct_a2Zc @f_a2VK $dFoldable_a2VL)

-- RHS size: {terms: 17, types: 25, coercions: 25, joins: 0/0}
$csum_a2Z0 [Occ=LoopBreaker]
  :: forall (f :: * -> *) a. (Foldable f, Num a) => Fix f a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 140 60}]
$csum_a2Z0
  = \ (@(f_a2VK :: * -> *))
      ($dFoldable_a2VL :: Foldable f_a2VK)
      (@a_a2Z3)
      ($dNum_a2Z4 :: Num a_a2Z3) ->
      ((\ (@(t_a4WR :: * -> *))
          ($dFoldable_a4WS :: Foldable t_a4WR)
          (@a_a4WT)
          ($dNum_a4WU :: Num a_a4WT) ->
          Data.Foldable.foldMap'
            @t_a4WR
            $dFoldable_a4WS
            @(base:Data.Semigroup.Internal.Sum a_a4WT)
            @a_a4WT
            (base:Data.Semigroup.Internal.$fMonoidSum @a_a4WT $dNum_a4WU)
            ((\ (ds_a52f :: a_a4WT) -> ds_a52f)
             `cast` (<a_a4WT>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Sum[0]
                                              <a_a4WT>_R)
                     :: (a_a4WT -> a_a4WT)
                        ~R# (a_a4WT -> base:Data.Semigroup.Internal.Sum a_a4WT))))
       `cast` (forall (t :: <* -> *>_N).
               <Foldable t>_R
               %<'Many>_N ->_R forall (a :: <*>_N).
                               <Num a>_R
                               %<'Many>_N ->_R <t a>_R
                               %<'Many>_N ->_R base:Data.Semigroup.Internal.N:Sum[0] <a>_R
               :: (forall {t :: * -> *} {a}.
                   (Foldable t, Num a) =>
                   t a -> base:Data.Semigroup.Internal.Sum a)
                  ~R# (forall {t :: * -> *} {a}. (Foldable t, Num a) => t a -> a)))
        @(Fix f_a2VK)
        (Main.$fFoldableFix @f_a2VK $dFoldable_a2VL)
        @a_a2Z3
        $dNum_a2Z4

-- RHS size: {terms: 27, types: 36, coercions: 8, joins: 0/2}
$cminimum_a2YO [Occ=LoopBreaker]
  :: forall (f :: * -> *) a. (Foldable f, Ord a) => Fix f a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 280 60}]
$cminimum_a2YO
  = \ (@(f_a2VK :: * -> *))
      ($dFoldable_a2VL :: Foldable f_a2VK)
      (@a_a2YR)
      ($dOrd_a2YS :: Ord a_a2YR) ->
      let {
        d_a52o :: a_a2YR
        [LclId,
         Str=b,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 110 0}]
        d_a52o
          = errorWithoutStackTrace
              @GHC.Types.LiftedRep
              @a_a2YR
              (GHC.Base.build
                 @Char
                 (\ (@b_a52t) ->
                    GHC.CString.unpackFoldrCString#
                      @b_a52t "minimum: empty structure"#)) } in
      let {
        g_a52v :: Fix f_a2VK a_a2YR -> base:Data.Functor.Utils.Min a_a2YR
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 100 0}]
        g_a52v
          = Data.Foldable.foldMap'
              @(Fix f_a2VK)
              (Main.$fFoldableFix @f_a2VK $dFoldable_a2VL)
              @(base:Data.Functor.Utils.Min a_a2YR)
              @a_a2YR
              (base:Data.Functor.Utils.$fMonoidMin @a_a2YR $dOrd_a2YS)
              ((\ (ds_a53M :: a_a2YR) -> GHC.Maybe.Just @a_a2YR ds_a53M)
               `cast` (<a_a2YR>_R
                       %<'Many>_N ->_R Sym (base:Data.Functor.Utils.N:Min[0]) <a_a2YR>_N
                       :: (a_a2YR -> GHC.Maybe.Maybe a_a2YR)
                          ~R# (a_a2YR -> base:Data.Functor.Utils.Min a_a2YR))) } in
      \ (x_a53N :: Fix f_a2VK a_a2YR) ->
        case (g_a52v x_a53N)
             `cast` (base:Data.Functor.Utils.N:Min[0] <a_a2YR>_N
                     :: base:Data.Functor.Utils.Min a_a2YR ~R# GHC.Maybe.Maybe a_a2YR)
        of {
          GHC.Maybe.Nothing -> d_a52o;
          GHC.Maybe.Just v_a54h -> v_a54h
        }

-- RHS size: {terms: 27, types: 36, coercions: 8, joins: 0/2}
$cmaximum_a2YC [Occ=LoopBreaker]
  :: forall (f :: * -> *) a. (Foldable f, Ord a) => Fix f a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 280 60}]
$cmaximum_a2YC
  = \ (@(f_a2VK :: * -> *))
      ($dFoldable_a2VL :: Foldable f_a2VK)
      (@a_a2YF)
      ($dOrd_a2YG :: Ord a_a2YF) ->
      let {
        d_a54n :: a_a2YF
        [LclId,
         Str=b,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 110 0}]
        d_a54n
          = errorWithoutStackTrace
              @GHC.Types.LiftedRep
              @a_a2YF
              (GHC.Base.build
                 @Char
                 (\ (@b_a54o) ->
                    GHC.CString.unpackFoldrCString#
                      @b_a54o "maximum: empty structure"#)) } in
      let {
        g_a54p :: Fix f_a2VK a_a2YF -> base:Data.Functor.Utils.Max a_a2YF
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 100 0}]
        g_a54p
          = Data.Foldable.foldMap'
              @(Fix f_a2VK)
              (Main.$fFoldableFix @f_a2VK $dFoldable_a2VL)
              @(base:Data.Functor.Utils.Max a_a2YF)
              @a_a2YF
              (base:Data.Functor.Utils.$fMonoidMax @a_a2YF $dOrd_a2YG)
              ((\ (ds_a54r :: a_a2YF) -> GHC.Maybe.Just @a_a2YF ds_a54r)
               `cast` (<a_a2YF>_R
                       %<'Many>_N ->_R Sym (base:Data.Functor.Utils.N:Max[0]) <a_a2YF>_N
                       :: (a_a2YF -> GHC.Maybe.Maybe a_a2YF)
                          ~R# (a_a2YF -> base:Data.Functor.Utils.Max a_a2YF))) } in
      \ (x_a54s :: Fix f_a2VK a_a2YF) ->
        case (g_a54p x_a54s)
             `cast` (base:Data.Functor.Utils.N:Max[0] <a_a2YF>_N
                     :: base:Data.Functor.Utils.Max a_a2YF ~R# GHC.Maybe.Maybe a_a2YF)
        of {
          GHC.Maybe.Nothing -> d_a54n;
          GHC.Maybe.Just v_a54x -> v_a54x
        }

-- RHS size: {terms: 18, types: 24, coercions: 26, joins: 0/0}
$celem_a2Yq [Occ=LoopBreaker]
  :: forall (f :: * -> *) a.
     (Foldable f, Eq a) =>
     a -> Fix f a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 150 60}]
$celem_a2Yq
  = \ (@(f_a2VK :: * -> *))
      ($dFoldable_a2VL :: Foldable f_a2VK)
      (@a_a2Yt)
      ($dEq_a2Yu :: Eq a_a2Yt) ->
      ((\ (@(t_a54z :: * -> *))
          ($dFoldable_a54A :: Foldable t_a54z)
          (@a_a54B)
          ($dEq_a54C :: Eq a_a54B)
          (eta_a54D :: a_a54B) ->
          foldMap
            @t_a54z
            $dFoldable_a54A
            @base:Data.Semigroup.Internal.Any
            @a_a54B
            base:Data.Semigroup.Internal.$fMonoidAny
            ((== @a_a54B $dEq_a54C eta_a54D)
             `cast` (<a_a54B>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Any[0])
                     :: (a_a54B -> Bool)
                        ~R# (a_a54B -> base:Data.Semigroup.Internal.Any))))
       `cast` (forall (t :: <* -> *>_N).
               <Foldable t>_R
               %<'Many>_N ->_R forall (a :: <*>_N).
                               <Eq a>_R
                               %<'Many>_N ->_R <a>_R
                               %<'Many>_N ->_R <t a>_R
                               %<'Many>_N ->_R base:Data.Semigroup.Internal.N:Any[0]
               :: (forall {t :: * -> *} {a}.
                   (Foldable t, Eq a) =>
                   a -> t a -> base:Data.Semigroup.Internal.Any)
                  ~R# (forall {t :: * -> *} {a}.
                       (Foldable t, Eq a) =>
                       a -> t a -> Bool)))
        @(Fix f_a2VK)
        (Main.$fFoldableFix @f_a2VK $dFoldable_a2VL)
        @a_a2Yt
        $dEq_a2Yu

-- RHS size: {terms: 17, types: 15, coercions: 0, joins: 0/0}
$clength_a2Yg [Occ=LoopBreaker]
  :: forall (f :: * -> *) a. Foldable f => Fix f a -> Int
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 111 0}]
$clength_a2Yg
  = \ (@(f_a2VK :: * -> *))
      ($dFoldable_a2VL :: Foldable f_a2VK)
      (@a_a2Yj) ->
      Data.Foldable.foldl'
        @(Fix f_a2VK)
        (Main.$fFoldableFix @f_a2VK $dFoldable_a2VL)
        @Int
        @a_a2Yj
        (\ (c_a54K :: Int) _ [Occ=Dead] ->
           case c_a54K of { GHC.Types.I# x_a54N ->
           GHC.Types.I# (GHC.Prim.+# x_a54N 1#)
           })
        (GHC.Types.I# 0#)

-- RHS size: {terms: 15, types: 32, coercions: 0, joins: 0/1}
$cnull_a2Y2 [Occ=LoopBreaker]
  :: forall (f :: * -> *) a. Foldable f => Fix f a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 110 60}]
$cnull_a2Y2
  = \ (@(f_a2VK :: * -> *))
      ($dFoldable_a2VL :: Foldable f_a2VK)
      (@a_a2Y5) ->
      let {
        $dFoldable_a2Yc :: Foldable (Fix f_a2VK)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dFoldable_a2Yc = Main.$fFoldableFix @f_a2VK $dFoldable_a2VL } in
      \ (ds_d4LH :: Fix f_a2VK a_a2Y5) ->
        case ds_d4LH of { MkFix a1_a2aV ->
        all
          @f_a2VK
          @(Fix f_a2VK a_a2Y5)
          $dFoldable_a2VL
          (null @(Fix f_a2VK) $dFoldable_a2Yc @a_a2Y5)
          a1_a2aV
        }

-- RHS size: {terms: 16, types: 25, coercions: 0, joins: 0/1}
$ctoList_a2XS [Occ=LoopBreaker]
  :: forall (f :: * -> *) a. Foldable f => Fix f a -> [a]
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 110 60}]
$ctoList_a2XS
  = \ (@(f_a2VK :: * -> *))
      ($dFoldable_a2VL :: Foldable f_a2VK)
      (@a_a2XV) ->
      let {
        $dFoldable_a54Q :: Foldable (Fix f_a2VK)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dFoldable_a54Q = Main.$fFoldableFix @f_a2VK $dFoldable_a2VL } in
      \ (t1_a54S :: Fix f_a2VK a_a2XV) ->
        GHC.Base.build
          @a_a2XV
          (\ (@b_a54T)
             (c_a54U [OS=OneShot] :: a_a2XV -> b_a54T -> b_a54T)
             (n_a54V [OS=OneShot] :: b_a54T) ->
             foldr
               @(Fix f_a2VK)
               $dFoldable_a54Q
               @a_a2XV
               @b_a54T
               c_a54U
               n_a54V
               t1_a54S)

-- RHS size: {terms: 32, types: 39, coercions: 0, joins: 0/1}
$cfoldl1_a2XI [Occ=LoopBreaker]
  :: forall (f :: * -> *) a.
     Foldable f =>
     (a -> a -> a) -> Fix f a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 310 60}]
$cfoldl1_a2XI
  = \ (@(f_a2VK :: * -> *))
      ($dFoldable_a2VL :: Foldable f_a2VK)
      (@a_a2XL) ->
      let {
        $dFoldable_a54X :: Foldable (Fix f_a2VK)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dFoldable_a54X = Main.$fFoldableFix @f_a2VK $dFoldable_a2VL } in
      \ (f_a54Z :: a_a2XL -> a_a2XL -> a_a2XL)
        (xs_a550 :: Fix f_a2VK a_a2XL) ->
        case foldl
               @(Fix f_a2VK)
               $dFoldable_a54X
               @(GHC.Maybe.Maybe a_a2XL)
               @a_a2XL
               (\ (m_a551 :: GHC.Maybe.Maybe a_a2XL) (y_a552 :: a_a2XL) ->
                  GHC.Maybe.Just
                    @a_a2XL
                    (case m_a551 of {
                       GHC.Maybe.Nothing -> y_a552;
                       GHC.Maybe.Just x_a555 -> f_a54Z x_a555 y_a552
                     }))
               (GHC.Maybe.Nothing @a_a2XL)
               xs_a550
        of {
          GHC.Maybe.Nothing ->
            errorWithoutStackTrace
              @GHC.Types.LiftedRep
              @a_a2XL
              (GHC.Base.build
                 @Char
                 (\ (@b_a558) ->
                    GHC.CString.unpackFoldrCString#
                      @b_a558 "foldl1: empty structure"#));
          GHC.Maybe.Just v_a559 -> v_a559
        }

-- RHS size: {terms: 32, types: 39, coercions: 0, joins: 0/1}
$cfoldr1_a2Xy [Occ=LoopBreaker]
  :: forall (f :: * -> *) a.
     Foldable f =>
     (a -> a -> a) -> Fix f a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 310 60}]
$cfoldr1_a2Xy
  = \ (@(f_a2VK :: * -> *))
      ($dFoldable_a2VL :: Foldable f_a2VK)
      (@a_a2XB) ->
      let {
        $dFoldable_a55d :: Foldable (Fix f_a2VK)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dFoldable_a55d = Main.$fFoldableFix @f_a2VK $dFoldable_a2VL } in
      \ (f_a55f :: a_a2XB -> a_a2XB -> a_a2XB)
        (xs_a55g :: Fix f_a2VK a_a2XB) ->
        case foldr
               @(Fix f_a2VK)
               $dFoldable_a55d
               @a_a2XB
               @(GHC.Maybe.Maybe a_a2XB)
               (\ (x_a55h :: a_a2XB) (m_a55i :: GHC.Maybe.Maybe a_a2XB) ->
                  GHC.Maybe.Just
                    @a_a2XB
                    (case m_a55i of {
                       GHC.Maybe.Nothing -> x_a55h;
                       GHC.Maybe.Just y_a55l -> f_a55f x_a55h y_a55l
                     }))
               (GHC.Maybe.Nothing @a_a2XB)
               xs_a55g
        of {
          GHC.Maybe.Nothing ->
            errorWithoutStackTrace
              @GHC.Types.LiftedRep
              @a_a2XB
              (GHC.Base.build
                 @Char
                 (\ (@b_a55o) ->
                    GHC.CString.unpackFoldrCString#
                      @b_a55o "foldr1: empty structure"#));
          GHC.Maybe.Just v_a55p -> v_a55p
        }

-- RHS size: {terms: 25, types: 31, coercions: 0, joins: 0/1}
$cfoldl'_a2Xm [Occ=LoopBreaker]
  :: forall (f :: * -> *) b a.
     Foldable f =>
     (b -> a -> b) -> b -> Fix f a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 210 60}]
$cfoldl'_a2Xm
  = \ (@(f_a2VK :: * -> *))
      ($dFoldable_a2VL :: Foldable f_a2VK)
      (@b_a2Xp)
      (@a_a2Xq) ->
      let {
        $dFoldable_a55t :: Foldable (Fix f_a2VK)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dFoldable_a55t = Main.$fFoldableFix @f_a2VK $dFoldable_a2VL } in
      \ (f_a55w :: b_a2Xp -> a_a2Xq -> b_a2Xp)
        (z0_a55x :: b_a2Xp)
        (xs_a55y :: Fix f_a2VK a_a2Xq) ->
        foldr
          @(Fix f_a2VK)
          $dFoldable_a55t
          @a_a2Xq
          @(b_a2Xp -> b_a2Xp)
          (\ (ds_a55z :: a_a2Xq)
             (ds1_a55A :: b_a2Xp -> b_a2Xp)
             (v_a55B [OS=OneShot] :: b_a2Xp) ->
             case v_a55B of z_a55C { __DEFAULT ->
             ds1_a55A (f_a55w z_a55C ds_a55z)
             })
          (id @b_a2Xp)
          xs_a55y
          z0_a55x

-- RHS size: {terms: 21, types: 31, coercions: 10, joins: 0/1}
$cfoldl_a2Xa [Occ=LoopBreaker]
  :: forall (f :: * -> *) b a.
     Foldable f =>
     (b -> a -> b) -> b -> Fix f a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 190 60}]
$cfoldl_a2Xa
  = \ (@(f_a2VK :: * -> *))
      ($dFoldable_a2VL :: Foldable f_a2VK)
      (@b_a2Xd)
      (@a_a2Xe) ->
      let {
        $dFoldable_a55F :: Foldable (Fix f_a2VK)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dFoldable_a55F = Main.$fFoldableFix @f_a2VK $dFoldable_a2VL } in
      \ (eta_a55I :: b_a2Xd -> a_a2Xe -> b_a2Xd)
        (eta1_a55J :: b_a2Xd)
        (eta2_a55K :: Fix f_a2VK a_a2Xe) ->
        ((foldMap
            @(Fix f_a2VK)
            $dFoldable_a55F
            @(base:Data.Semigroup.Internal.Dual
                (base:Data.Semigroup.Internal.Endo b_a2Xd))
            @a_a2Xe
            (base:Data.Semigroup.Internal.$fMonoidDual
               @(base:Data.Semigroup.Internal.Endo b_a2Xd)
               (base:Data.Semigroup.Internal.$fMonoidEndo @b_a2Xd))
            ((\ (x_a55N :: a_a2Xe) (y_a55O :: b_a2Xd) ->
                eta_a55I y_a55O x_a55N)
             `cast` (<a_a2Xe>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Dual[0]
                                              (base:Data.Semigroup.Internal.N:Endo[0] <b_a2Xd>_R))
                     :: (a_a2Xe -> b_a2Xd -> b_a2Xd)
                        ~R# (a_a2Xe
                             -> base:Data.Semigroup.Internal.Dual
                                  (base:Data.Semigroup.Internal.Endo b_a2Xd))))
            eta2_a55K)
         `cast` (base:Data.Semigroup.Internal.N:Dual[0]
                     (base:Data.Semigroup.Internal.N:Endo[0] <b_a2Xd>_R)
                 :: base:Data.Semigroup.Internal.Dual
                      (base:Data.Semigroup.Internal.Endo b_a2Xd)
                    ~R# (b_a2Xd -> b_a2Xd)))
          eta1_a55J

-- RHS size: {terms: 25, types: 31, coercions: 0, joins: 0/1}
$cfoldr'_a2WY [Occ=LoopBreaker]
  :: forall (f :: * -> *) a b.
     Foldable f =>
     (a -> b -> b) -> b -> Fix f a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 210 60}]
$cfoldr'_a2WY
  = \ (@(f_a2VK :: * -> *))
      ($dFoldable_a2VL :: Foldable f_a2VK)
      (@a_a2X1)
      (@b_a2X2) ->
      let {
        $dFoldable_a55U :: Foldable (Fix f_a2VK)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dFoldable_a55U = Main.$fFoldableFix @f_a2VK $dFoldable_a2VL } in
      \ (f_a55X :: a_a2X1 -> b_a2X2 -> b_a2X2)
        (z0_a55Y :: b_a2X2)
        (xs_a55Z :: Fix f_a2VK a_a2X1) ->
        foldl
          @(Fix f_a2VK)
          $dFoldable_a55U
          @(b_a2X2 -> b_a2X2)
          @a_a2X1
          (\ (ds_a560 :: b_a2X2 -> b_a2X2)
             (ds1_a561 :: a_a2X1)
             (v_a562 [OS=OneShot] :: b_a2X2) ->
             case v_a562 of z_a563 { __DEFAULT ->
             ds_a560 (f_a55X ds1_a561 z_a563)
             })
          (id @b_a2X2)
          xs_a55Z
          z0_a55Y

-- RHS size: {terms: 24, types: 44, coercions: 0, joins: 0/1}
$cfoldr_a2Wx [Occ=LoopBreaker]
  :: forall (f :: * -> *) a b.
     Foldable f =>
     (a -> b -> b) -> b -> Fix f a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30] 190 60}]
$cfoldr_a2Wx
  = \ (@(f_a2VK :: * -> *))
      ($dFoldable_a2VL :: Foldable f_a2VK)
      (@a_a2WA)
      (@b_a2WB) ->
      let {
        $dFoldable_a2WT :: Foldable (Fix f_a2VK)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dFoldable_a2WT = Main.$fFoldableFix @f_a2VK $dFoldable_a2VL } in
      \ (f_a2aM :: a_a2WA -> b_a2WB -> b_a2WB)
        (z_a2aN :: b_a2WB)
        (ds_d4Ls :: Fix f_a2VK a_a2WA) ->
        case ds_d4Ls of { MkFix a1_a2aO ->
        foldr
          @f_a2VK
          $dFoldable_a2VL
          @(Fix f_a2VK a_a2WA)
          @b_a2WB
          (\ (b1_a2aR :: Fix f_a2VK a_a2WA) (b2_a2aS :: b_a2WB) ->
             foldr
               @(Fix f_a2VK)
               $dFoldable_a2WT
               @a_a2WA
               @b_a2WB
               f_a2aM
               b2_a2aS
               b1_a2aR)
          z_a2aN
          a1_a2aO
        }

-- RHS size: {terms: 23, types: 27, coercions: 0, joins: 0/2}
$cfoldMap'_a2Wj [Occ=LoopBreaker]
  :: forall (f :: * -> *) m a.
     (Foldable f, Monoid m) =>
     (a -> m) -> Fix f a -> m
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 60] 210 60}]
$cfoldMap'_a2Wj
  = \ (@(f_a2VK :: * -> *))
      ($dFoldable_a2VL :: Foldable f_a2VK)
      (@m_a2Wm)
      (@a_a2Wn)
      ($dMonoid_a2Wo :: Monoid m_a2Wm) ->
      let {
        $dFoldable_a565 :: Foldable (Fix f_a2VK)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dFoldable_a565 = Main.$fFoldableFix @f_a2VK $dFoldable_a2VL } in
      \ (eta_a569 :: a_a2Wn -> m_a2Wm) ->
        let {
          $dSemigroup_a56a :: Semigroup m_a2Wm
          [LclId,
           Unf=Unf{Src=<vanilla>, TopLvl=False,
                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                   Guidance=IF_ARGS [] 20 0}]
          $dSemigroup_a56a = GHC.Base.$p1Monoid @m_a2Wm $dMonoid_a2Wo } in
        Data.Foldable.foldl'
          @(Fix f_a2VK)
          $dFoldable_a565
          @m_a2Wm
          @a_a2Wn
          (\ (acc_a56b :: m_a2Wm) (a1_a56c :: a_a2Wn) ->
             <> @m_a2Wm $dSemigroup_a56a acc_a56b (eta_a569 a1_a56c))
          (mempty @m_a2Wm $dMonoid_a2Wo)

-- RHS size: {terms: 21, types: 39, coercions: 0, joins: 0/1}
$cfoldMap_a2VZ [Occ=LoopBreaker]
  :: forall (f :: * -> *) m a.
     (Foldable f, Monoid m) =>
     (a -> m) -> Fix f a -> m
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 0] 150 60}]
$cfoldMap_a2VZ
  = \ (@(f_a2VK :: * -> *))
      ($dFoldable_a2VL :: Foldable f_a2VK)
      (@m_a2W2)
      (@a_a2W3)
      ($dMonoid_a2W4 :: Monoid m_a2W2) ->
      let {
        $dFoldable_a2Wd :: Foldable (Fix f_a2VK)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dFoldable_a2Wd = Main.$fFoldableFix @f_a2VK $dFoldable_a2VL } in
      \ (f_a2aT :: a_a2W3 -> m_a2W2) (ds_d4Ln :: Fix f_a2VK a_a2W3) ->
        case ds_d4Ln of { MkFix a1_a2aU ->
        foldMap
          @f_a2VK
          $dFoldable_a2VL
          @m_a2W2
          @(Fix f_a2VK a_a2W3)
          $dMonoid_a2W4
          (foldMap
             @(Fix f_a2VK) $dFoldable_a2Wd @m_a2W2 @a_a2W3 $dMonoid_a2W4 f_a2aT)
          a1_a2aU
        }

-- RHS size: {terms: 17, types: 25, coercions: 25, joins: 0/0}
$cproduct_a2Zc [Occ=LoopBreaker]
  :: forall (f :: * -> *) a. (Foldable f, Num a) => Fix f a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 140 60}]
$cproduct_a2Zc
  = \ (@(f_a2VK :: * -> *))
      ($dFoldable_a2VL :: Foldable f_a2VK)
      (@a_a2Zf)
      ($dNum_a2Zg :: Num a_a2Zf) ->
      ((\ (@(t_a56d :: * -> *))
          ($dFoldable_a56e :: Foldable t_a56d)
          (@a_a56f)
          ($dNum_a56g :: Num a_a56f) ->
          Data.Foldable.foldMap'
            @t_a56d
            $dFoldable_a56e
            @(base:Data.Semigroup.Internal.Product a_a56f)
            @a_a56f
            (base:Data.Semigroup.Internal.$fMonoidProduct @a_a56f $dNum_a56g)
            ((\ (ds_a56i :: a_a56f) -> ds_a56i)
             `cast` (<a_a56f>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Product[0]
                                              <a_a56f>_R)
                     :: (a_a56f -> a_a56f)
                        ~R# (a_a56f -> base:Data.Semigroup.Internal.Product a_a56f))))
       `cast` (forall (t :: <* -> *>_N).
               <Foldable t>_R
               %<'Many>_N ->_R forall (a :: <*>_N).
                               <Num a>_R
                               %<'Many>_N ->_R <t a>_R
                               %<'Many>_N ->_R base:Data.Semigroup.Internal.N:Product[0] <a>_R
               :: (forall {t :: * -> *} {a}.
                   (Foldable t, Num a) =>
                   t a -> base:Data.Semigroup.Internal.Product a)
                  ~R# (forall {t :: * -> *} {a}. (Foldable t, Num a) => t a -> a)))
        @(Fix f_a2VK)
        (Main.$fFoldableFix @f_a2VK $dFoldable_a2VL)
        @a_a2Zf
        $dNum_a2Zg

-- RHS size: {terms: 9, types: 14, coercions: 0, joins: 0/0}
$cfold_a2VN [Occ=LoopBreaker]
  :: forall (f :: * -> *) m. (Foldable f, Monoid m) => Fix f m -> m
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 60 0}]
$cfold_a2VN
  = \ (@(f_a2VK :: * -> *))
      ($dFoldable_a2VL :: Foldable f_a2VK)
      (@m_a2VQ)
      ($dMonoid_a2VR :: Monoid m_a2VQ) ->
      foldMap
        @(Fix f_a2VK)
        (Main.$fFoldableFix @f_a2VK $dFoldable_a2VL)
        @m_a2VQ
        @m_a2VQ
        $dMonoid_a2VR
        (id @m_a2VQ)
end Rec }

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
$cp2Traversable_a4av
  :: forall {f :: * -> *}. Traversable f => Foldable (Fix f)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30] 40 0}]
$cp2Traversable_a4av
  = \ (@(f_a4am :: * -> *))
      ($dTraversable_a4an :: Traversable f_a4am) ->
      Main.$fFoldableFix
        @f_a4am
        (Data.Traversable.$p2Traversable @f_a4am $dTraversable_a4an)

Rec {
-- RHS size: {terms: 7, types: 9, coercions: 0, joins: 0/0}
Main.$fFunctorFix [InlPrag=CONLIKE]
  :: forall (f :: * -> *). Functor f => Functor (Fix f)
[LclIdX[DFunId],
 Unf=DFun: \ (@(f_a1vn :: * -> *)) (v_B1 :: Functor f_a1vn) ->
       GHC.Base.C:Functor TYPE: Fix f_a1vn
                          $cfmap_a2V2 @f_a1vn v_B1
                          $c<$_a2Vn @f_a1vn v_B1]
Main.$fFunctorFix
  = \ (@(f_a2UZ :: * -> *)) ($dFunctor_a2V0 :: Functor f_a2UZ) ->
      GHC.Base.C:Functor
        @(Fix f_a2UZ)
        ($cfmap_a2V2 @f_a2UZ $dFunctor_a2V0)
        ($c<$_a2Vn @f_a2UZ $dFunctor_a2V0)

-- RHS size: {terms: 21, types: 46, coercions: 0, joins: 0/1}
$c<$_a2Vn [Occ=LoopBreaker]
  :: forall (f :: * -> *) a b. Functor f => a -> Fix f b -> Fix f a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30] 160 60}]
$c<$_a2Vn
  = \ (@(f_a2UZ :: * -> *))
      ($dFunctor_a2V0 :: Functor f_a2UZ)
      (@a_a2Vq)
      (@b_a2Vr) ->
      let {
        $dFunctor_a2VD :: Functor (Fix f_a2UZ)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dFunctor_a2VD = Main.$fFunctorFix @f_a2UZ $dFunctor_a2V0 } in
      \ (z_a2aJ :: a_a2Vq) (ds_d4Lf :: Fix f_a2UZ b_a2Vr) ->
        case ds_d4Lf of { MkFix a1_a2aK ->
        Main.MkFix
          @(*)
          @f_a2UZ
          @a_a2Vq
          (fmap
             @f_a2UZ
             $dFunctor_a2V0
             @(Fix f_a2UZ b_a2Vr)
             @(Fix f_a2UZ a_a2Vq)
             (\ (b1_a2aL :: Fix f_a2UZ b_a2Vr) ->
                <$ @(Fix f_a2UZ) $dFunctor_a2VD @a_a2Vq @b_a2Vr z_a2aJ b1_a2aL)
             a1_a2aK)
        }

-- RHS size: {terms: 21, types: 47, coercions: 0, joins: 0/1}
$cfmap_a2V2 [Occ=LoopBreaker]
  :: forall (f :: * -> *) a b.
     Functor f =>
     (a -> b) -> Fix f a -> Fix f b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30] 160 60}]
$cfmap_a2V2
  = \ (@(f_a2UZ :: * -> *))
      ($dFunctor_a2V0 :: Functor f_a2UZ)
      (@a_a2V5)
      (@b_a2V6) ->
      let {
        $dFunctor_a2Vi :: Functor (Fix f_a2UZ)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dFunctor_a2Vi = Main.$fFunctorFix @f_a2UZ $dFunctor_a2V0 } in
      \ (f_a2aG :: a_a2V5 -> b_a2V6) (ds_d4Lb :: Fix f_a2UZ a_a2V5) ->
        case ds_d4Lb of { MkFix a1_a2aH ->
        Main.MkFix
          @(*)
          @f_a2UZ
          @b_a2V6
          (fmap
             @f_a2UZ
             $dFunctor_a2V0
             @(Fix f_a2UZ a_a2V5)
             @(Fix f_a2UZ b_a2V6)
             (\ (b1_a2aI :: Fix f_a2UZ a_a2V5) ->
                fmap @(Fix f_a2UZ) $dFunctor_a2Vi @a_a2V5 @b_a2V6 f_a2aG b1_a2aI)
             a1_a2aH)
        }
end Rec }

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
$cp1Traversable_a4ar
  :: forall {f :: * -> *}. Traversable f => Functor (Fix f)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30] 40 0}]
$cp1Traversable_a4ar
  = \ (@(f_a4am :: * -> *))
      ($dTraversable_a4an :: Traversable f_a4am) ->
      Main.$fFunctorFix
        @f_a4am
        (Data.Traversable.$p1Traversable @f_a4am $dTraversable_a4an)

Rec {
-- RHS size: {terms: 15, types: 13, coercions: 0, joins: 0/0}
Main.$fTraversableFix [InlPrag=CONLIKE]
  :: forall (f :: * -> *). Traversable f => Traversable (Fix f)
[LclIdX[DFunId],
 Unf=DFun: \ (@(f_aUu :: * -> *)) (v_B1 :: Traversable f_aUu) ->
       Data.Traversable.C:Traversable TYPE: Fix f_aUu
                                      $cp1Traversable_a4ar @f_aUu v_B1
                                      $cp2Traversable_a4av @f_aUu v_B1
                                      $ctraverse_a4ax @f_aUu v_B1
                                      $csequenceA_a4aN @f_aUu v_B1
                                      $cmapM_a4b1 @f_aUu v_B1
                                      $csequence_a4bh @f_aUu v_B1]
Main.$fTraversableFix
  = \ (@(f_a4am :: * -> *))
      ($dTraversable_a4an :: Traversable f_a4am) ->
      Data.Traversable.C:Traversable
        @(Fix f_a4am)
        ($cp1Traversable_a4ar @f_a4am $dTraversable_a4an)
        ($cp2Traversable_a4av @f_a4am $dTraversable_a4an)
        ($ctraverse_a4ax @f_a4am $dTraversable_a4an)
        ($csequenceA_a4aN @f_a4am $dTraversable_a4an)
        ($cmapM_a4b1 @f_a4am $dTraversable_a4an)
        ($csequence_a4bh @f_a4am $dTraversable_a4an)

-- RHS size: {terms: 11, types: 18, coercions: 0, joins: 0/0}
$cmapM_a4b1 [Occ=LoopBreaker]
  :: forall (f :: * -> *) (m :: * -> *) a b.
     (Traversable f, Monad m) =>
     (a -> m b) -> Fix f a -> m (Fix f b)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 30] 70 0}]
$cmapM_a4b1
  = \ (@(f_a4am :: * -> *))
      ($dTraversable_a4an :: Traversable f_a4am)
      (@(m_a4b4 :: * -> *))
      (@a_a4b5)
      (@b_a4b6)
      ($dMonad_a4b7 :: Monad m_a4b4) ->
      traverse
        @(Fix f_a4am)
        (Main.$fTraversableFix @f_a4am $dTraversable_a4an)
        @m_a4b4
        @a_a4b5
        @b_a4b6
        (GHC.Base.$p1Monad @m_a4b4 $dMonad_a4b7)

-- RHS size: {terms: 10, types: 19, coercions: 0, joins: 0/0}
$csequenceA_a4aN [Occ=LoopBreaker]
  :: forall (f :: * -> *) (f :: * -> *) a.
     (Traversable f, Applicative f) =>
     Fix f (f a) -> f (Fix f a)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 60 0}]
$csequenceA_a4aN
  = \ (@(f_a4am :: * -> *))
      ($dTraversable_a4an :: Traversable f_a4am)
      (@(f_a4aQ :: * -> *))
      (@a_a4aR)
      ($dApplicative_a4aS :: Applicative f_a4aQ) ->
      traverse
        @(Fix f_a4am)
        (Main.$fTraversableFix @f_a4am $dTraversable_a4an)
        @f_a4aQ
        @(f_a4aQ a_a4aR)
        @a_a4aR
        $dApplicative_a4aS
        (id @(f_a4aQ a_a4aR))

-- RHS size: {terms: 10, types: 16, coercions: 0, joins: 0/0}
$csequence_a4bh [Occ=LoopBreaker]
  :: forall (f :: * -> *) (m :: * -> *) a.
     (Traversable f, Monad m) =>
     Fix f (m a) -> m (Fix f a)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 30] 70 0}]
$csequence_a4bh
  = \ (@(f_a4am :: * -> *))
      ($dTraversable_a4an :: Traversable f_a4am)
      (@(m_a4bk :: * -> *))
      (@a_a4bl)
      ($dMonad_a4bm :: Monad m_a4bk) ->
      sequenceA
        @(Fix f_a4am)
        (Main.$fTraversableFix @f_a4am $dTraversable_a4an)
        @m_a4bk
        @a_a4bl
        (GHC.Base.$p1Monad @m_a4bk $dMonad_a4bm)

-- RHS size: {terms: 23, types: 55, coercions: 0, joins: 0/3}
$ctraverse_a4ax [Occ=LoopBreaker]
  :: forall (f :: * -> *) (f :: * -> *) a b.
     (Traversable f, Applicative f) =>
     (a -> f b) -> Fix f a -> f (Fix f b)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 190 60}]
$ctraverse_a4ax
  = \ (@(f_a4am :: * -> *))
      ($dTraversable_a4an :: Traversable f_a4am)
      (@(f_a4aA :: * -> *))
      (@a_a4aB)
      (@b_a4aC)
      ($dApplicative_a4aD :: Applicative f_a4aA) ->
      let {
        $dTraversable_a56I :: Traversable (Fix f_a4am)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dTraversable_a56I
          = Main.$fTraversableFix @f_a4am $dTraversable_a4an } in
      \ (eta1_a56N :: a_a4aB -> f_a4aA b_a4aC) ->
        let {
          f1_a56O :: Fix f_a4am (f_a4aA b_a4aC) -> f_a4aA (Fix f_a4am b_a4aC)
          [LclId,
           Unf=Unf{Src=<vanilla>, TopLvl=False,
                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                   Guidance=IF_ARGS [] 30 0}]
          f1_a56O
            = sequenceA
                @(Fix f_a4am)
                $dTraversable_a56I
                @f_a4aA
                @b_a4aC
                $dApplicative_a4aD } in
        let {
          g_a56P :: Fix f_a4am a_a4aB -> Fix f_a4am (f_a4aA b_a4aC)
          [LclId,
           Unf=Unf{Src=<vanilla>, TopLvl=False,
                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                   Guidance=IF_ARGS [] 50 0}]
          g_a56P
            = fmap
                @(Fix f_a4am)
                (Data.Traversable.$p1Traversable @(Fix f_a4am) $dTraversable_a56I)
                @a_a4aB
                @(f_a4aA b_a4aC)
                eta1_a56N } in
        \ (x_a56Q :: Fix f_a4am a_a4aB) -> f1_a56O (g_a56P x_a56Q)
end Rec }

-- RHS size: {terms: 14, types: 29, coercions: 0, joins: 0/0}
$cnull_a2TB
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Foldable f, Foldable g) =>
     Compose f g a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 30 20] 70 0}]
$cnull_a2TB
  = \ (@(f_a2Rh :: * -> *))
      (@(g_a2Ri :: * -> *))
      ($dFoldable_a2Rj :: Foldable f_a2Rh)
      ($dFoldable_a2Rk :: Foldable g_a2Ri)
      (@a_a2TE)
      (ds_d4KO :: Compose f_a2Rh g_a2Ri a_a2TE) ->
      case ds_d4KO of { MkCompose a1_a2aF ->
      all
        @f_a2Rh
        @(g_a2Ri a_a2TE)
        $dFoldable_a2Rj
        (null @g_a2Ri $dFoldable_a2Rk @a_a2TE)
        a1_a2aF
      }

-- RHS size: {terms: 23, types: 39, coercions: 0, joins: 0/0}
$cfoldr_a2S6
  :: forall (f :: * -> *) (g :: * -> *) a b.
     (Foldable f, Foldable g) =>
     (a -> b -> b) -> b -> Compose f g a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 0 0 20] 130 0}]
$cfoldr_a2S6
  = \ (@(f_a2Rh :: * -> *))
      (@(g_a2Ri :: * -> *))
      ($dFoldable_a2Rj :: Foldable f_a2Rh)
      ($dFoldable_a2Rk :: Foldable g_a2Ri)
      (@a_a2S9)
      (@b_a2Sa)
      (f_a2aw :: a_a2S9 -> b_a2Sa -> b_a2Sa)
      (z_a2ax :: b_a2Sa)
      (ds_d4Ks :: Compose f_a2Rh g_a2Ri a_a2S9) ->
      case ds_d4Ks of { MkCompose a1_a2ay ->
      foldr
        @f_a2Rh
        $dFoldable_a2Rj
        @(g_a2Ri a_a2S9)
        @b_a2Sa
        (\ (b1_a2aB :: g_a2Ri a_a2S9) (b2_a2aC :: b_a2Sa) ->
           foldr
             @g_a2Ri $dFoldable_a2Rk @a_a2S9 @b_a2Sa f_a2aw b2_a2aC b1_a2aB)
        z_a2ax
        a1_a2ay
      }

-- RHS size: {terms: 20, types: 36, coercions: 0, joins: 0/0}
$cfoldMap_a2Ry
  :: forall (f :: * -> *) (g :: * -> *) m a.
     (Foldable f, Foldable g, Monoid m) =>
     (a -> m) -> Compose f g a -> m
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 0 0 20] 100 0}]
$cfoldMap_a2Ry
  = \ (@(f_a2Rh :: * -> *))
      (@(g_a2Ri :: * -> *))
      ($dFoldable_a2Rj :: Foldable f_a2Rh)
      ($dFoldable_a2Rk :: Foldable g_a2Ri)
      (@m_a2RB)
      (@a_a2RC)
      ($dMonoid_a2RD :: Monoid m_a2RB)
      (f_a2aD :: a_a2RC -> m_a2RB)
      (ds_d4Kl :: Compose f_a2Rh g_a2Ri a_a2RC) ->
      case ds_d4Kl of { MkCompose a1_a2aE ->
      foldMap
        @f_a2Rh
        $dFoldable_a2Rj
        @m_a2RB
        @(g_a2Ri a_a2RC)
        $dMonoid_a2RD
        (foldMap
           @g_a2Ri $dFoldable_a2Rk @m_a2RB @a_a2RC $dMonoid_a2RD f_a2aD)
        a1_a2aE
      }

Rec {
-- RHS size: {terms: 56, types: 47, coercions: 0, joins: 0/0}
Main.$fFoldableCompose [InlPrag=CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     Foldable (Compose f g)
[LclIdX[DFunId],
 Unf=DFun: \ (@(f_a1vg :: * -> *))
             (@(g_a1vh :: * -> *))
             (v_B1 :: Foldable f_a1vg)
             (v_B2 :: Foldable g_a1vh) ->
       Data.Foldable.C:Foldable TYPE: Compose f_a1vg g_a1vh
                                $cfold_a2Rm @f_a1vg @g_a1vh v_B1 v_B2
                                $cfoldMap_a2Ry @f_a1vg @g_a1vh v_B1 v_B2
                                $cfoldMap'_a2RS @f_a1vg @g_a1vh v_B1 v_B2
                                $cfoldr_a2S6 @f_a1vg @g_a1vh v_B1 v_B2
                                $cfoldr'_a2Sx @f_a1vg @g_a1vh v_B1 v_B2
                                $cfoldl_a2SJ @f_a1vg @g_a1vh v_B1 v_B2
                                $cfoldl'_a2SV @f_a1vg @g_a1vh v_B1 v_B2
                                $cfoldr1_a2T7 @f_a1vg @g_a1vh v_B1 v_B2
                                $cfoldl1_a2Th @f_a1vg @g_a1vh v_B1 v_B2
                                $ctoList_a2Tr @f_a1vg @g_a1vh v_B1 v_B2
                                $cnull_a2TB @f_a1vg @g_a1vh v_B1 v_B2
                                $clength_a2TP @f_a1vg @g_a1vh v_B1 v_B2
                                $celem_a2TZ @f_a1vg @g_a1vh v_B1 v_B2
                                $cmaximum_a2Ub @f_a1vg @g_a1vh v_B1 v_B2
                                $cminimum_a2Un @f_a1vg @g_a1vh v_B1 v_B2
                                $csum_a2Uz @f_a1vg @g_a1vh v_B1 v_B2
                                $cproduct_a2UL @f_a1vg @g_a1vh v_B1 v_B2]
Main.$fFoldableCompose
  = \ (@(f_a2Rh :: * -> *))
      (@(g_a2Ri :: * -> *))
      ($dFoldable_a2Rj :: Foldable f_a2Rh)
      ($dFoldable_a2Rk :: Foldable g_a2Ri) ->
      Data.Foldable.C:Foldable
        @(Compose f_a2Rh g_a2Ri)
        ($cfold_a2Rm @f_a2Rh @g_a2Ri $dFoldable_a2Rj $dFoldable_a2Rk)
        ($cfoldMap_a2Ry @f_a2Rh @g_a2Ri $dFoldable_a2Rj $dFoldable_a2Rk)
        ($cfoldMap'_a2RS @f_a2Rh @g_a2Ri $dFoldable_a2Rj $dFoldable_a2Rk)
        ($cfoldr_a2S6 @f_a2Rh @g_a2Ri $dFoldable_a2Rj $dFoldable_a2Rk)
        ($cfoldr'_a2Sx @f_a2Rh @g_a2Ri $dFoldable_a2Rj $dFoldable_a2Rk)
        ($cfoldl_a2SJ @f_a2Rh @g_a2Ri $dFoldable_a2Rj $dFoldable_a2Rk)
        ($cfoldl'_a2SV @f_a2Rh @g_a2Ri $dFoldable_a2Rj $dFoldable_a2Rk)
        ($cfoldr1_a2T7 @f_a2Rh @g_a2Ri $dFoldable_a2Rj $dFoldable_a2Rk)
        ($cfoldl1_a2Th @f_a2Rh @g_a2Ri $dFoldable_a2Rj $dFoldable_a2Rk)
        ($ctoList_a2Tr @f_a2Rh @g_a2Ri $dFoldable_a2Rj $dFoldable_a2Rk)
        ($cnull_a2TB @f_a2Rh @g_a2Ri $dFoldable_a2Rj $dFoldable_a2Rk)
        ($clength_a2TP @f_a2Rh @g_a2Ri $dFoldable_a2Rj $dFoldable_a2Rk)
        ($celem_a2TZ @f_a2Rh @g_a2Ri $dFoldable_a2Rj $dFoldable_a2Rk)
        ($cmaximum_a2Ub @f_a2Rh @g_a2Ri $dFoldable_a2Rj $dFoldable_a2Rk)
        ($cminimum_a2Un @f_a2Rh @g_a2Ri $dFoldable_a2Rj $dFoldable_a2Rk)
        ($csum_a2Uz @f_a2Rh @g_a2Ri $dFoldable_a2Rj $dFoldable_a2Rk)
        ($cproduct_a2UL @f_a2Rh @g_a2Ri $dFoldable_a2Rj $dFoldable_a2Rk)

-- RHS size: {terms: 20, types: 32, coercions: 25, joins: 0/0}
$csum_a2Uz [Occ=LoopBreaker]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Foldable f, Foldable g, Num a) =>
     Compose f g a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0] 150 60}]
$csum_a2Uz
  = \ (@(f_a2Rh :: * -> *))
      (@(g_a2Ri :: * -> *))
      ($dFoldable_a2Rj :: Foldable f_a2Rh)
      ($dFoldable_a2Rk :: Foldable g_a2Ri)
      (@a_a2UC)
      ($dNum_a2UD :: Num a_a2UC) ->
      ((\ (@(t_a4WR :: * -> *))
          ($dFoldable_a4WS :: Foldable t_a4WR)
          (@a_a4WT)
          ($dNum_a4WU :: Num a_a4WT) ->
          Data.Foldable.foldMap'
            @t_a4WR
            $dFoldable_a4WS
            @(base:Data.Semigroup.Internal.Sum a_a4WT)
            @a_a4WT
            (base:Data.Semigroup.Internal.$fMonoidSum @a_a4WT $dNum_a4WU)
            ((\ (ds_a52f :: a_a4WT) -> ds_a52f)
             `cast` (<a_a4WT>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Sum[0]
                                              <a_a4WT>_R)
                     :: (a_a4WT -> a_a4WT)
                        ~R# (a_a4WT -> base:Data.Semigroup.Internal.Sum a_a4WT))))
       `cast` (forall (t :: <* -> *>_N).
               <Foldable t>_R
               %<'Many>_N ->_R forall (a :: <*>_N).
                               <Num a>_R
                               %<'Many>_N ->_R <t a>_R
                               %<'Many>_N ->_R base:Data.Semigroup.Internal.N:Sum[0] <a>_R
               :: (forall {t :: * -> *} {a}.
                   (Foldable t, Num a) =>
                   t a -> base:Data.Semigroup.Internal.Sum a)
                  ~R# (forall {t :: * -> *} {a}. (Foldable t, Num a) => t a -> a)))
        @(Compose f_a2Rh g_a2Ri)
        (Main.$fFoldableCompose
           @f_a2Rh @g_a2Ri $dFoldable_a2Rj $dFoldable_a2Rk)
        @a_a2UC
        $dNum_a2UD

-- RHS size: {terms: 30, types: 47, coercions: 8, joins: 0/2}
$cminimum_a2Un [Occ=LoopBreaker]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Foldable f, Foldable g, Ord a) =>
     Compose f g a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0] 290 60}]
$cminimum_a2Un
  = \ (@(f_a2Rh :: * -> *))
      (@(g_a2Ri :: * -> *))
      ($dFoldable_a2Rj :: Foldable f_a2Rh)
      ($dFoldable_a2Rk :: Foldable g_a2Ri)
      (@a_a2Uq)
      ($dOrd_a2Ur :: Ord a_a2Uq) ->
      let {
        d_a52o :: a_a2Uq
        [LclId,
         Str=b,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 110 0}]
        d_a52o
          = errorWithoutStackTrace
              @GHC.Types.LiftedRep
              @a_a2Uq
              (GHC.Base.build
                 @Char
                 (\ (@b_a52t) ->
                    GHC.CString.unpackFoldrCString#
                      @b_a52t "minimum: empty structure"#)) } in
      let {
        g_a52v
          :: Compose f_a2Rh g_a2Ri a_a2Uq
             -> base:Data.Functor.Utils.Min a_a2Uq
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 110 0}]
        g_a52v
          = Data.Foldable.foldMap'
              @(Compose f_a2Rh g_a2Ri)
              (Main.$fFoldableCompose
                 @f_a2Rh @g_a2Ri $dFoldable_a2Rj $dFoldable_a2Rk)
              @(base:Data.Functor.Utils.Min a_a2Uq)
              @a_a2Uq
              (base:Data.Functor.Utils.$fMonoidMin @a_a2Uq $dOrd_a2Ur)
              ((\ (ds_a53M :: a_a2Uq) -> GHC.Maybe.Just @a_a2Uq ds_a53M)
               `cast` (<a_a2Uq>_R
                       %<'Many>_N ->_R Sym (base:Data.Functor.Utils.N:Min[0]) <a_a2Uq>_N
                       :: (a_a2Uq -> GHC.Maybe.Maybe a_a2Uq)
                          ~R# (a_a2Uq -> base:Data.Functor.Utils.Min a_a2Uq))) } in
      \ (x_a53N :: Compose f_a2Rh g_a2Ri a_a2Uq) ->
        case (g_a52v x_a53N)
             `cast` (base:Data.Functor.Utils.N:Min[0] <a_a2Uq>_N
                     :: base:Data.Functor.Utils.Min a_a2Uq ~R# GHC.Maybe.Maybe a_a2Uq)
        of {
          GHC.Maybe.Nothing -> d_a52o;
          GHC.Maybe.Just v_a54h -> v_a54h
        }

-- RHS size: {terms: 30, types: 47, coercions: 8, joins: 0/2}
$cmaximum_a2Ub [Occ=LoopBreaker]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Foldable f, Foldable g, Ord a) =>
     Compose f g a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0] 290 60}]
$cmaximum_a2Ub
  = \ (@(f_a2Rh :: * -> *))
      (@(g_a2Ri :: * -> *))
      ($dFoldable_a2Rj :: Foldable f_a2Rh)
      ($dFoldable_a2Rk :: Foldable g_a2Ri)
      (@a_a2Ue)
      ($dOrd_a2Uf :: Ord a_a2Ue) ->
      let {
        d_a54n :: a_a2Ue
        [LclId,
         Str=b,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 110 0}]
        d_a54n
          = errorWithoutStackTrace
              @GHC.Types.LiftedRep
              @a_a2Ue
              (GHC.Base.build
                 @Char
                 (\ (@b_a54o) ->
                    GHC.CString.unpackFoldrCString#
                      @b_a54o "maximum: empty structure"#)) } in
      let {
        g_a54p
          :: Compose f_a2Rh g_a2Ri a_a2Ue
             -> base:Data.Functor.Utils.Max a_a2Ue
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 110 0}]
        g_a54p
          = Data.Foldable.foldMap'
              @(Compose f_a2Rh g_a2Ri)
              (Main.$fFoldableCompose
                 @f_a2Rh @g_a2Ri $dFoldable_a2Rj $dFoldable_a2Rk)
              @(base:Data.Functor.Utils.Max a_a2Ue)
              @a_a2Ue
              (base:Data.Functor.Utils.$fMonoidMax @a_a2Ue $dOrd_a2Uf)
              ((\ (ds_a54r :: a_a2Ue) -> GHC.Maybe.Just @a_a2Ue ds_a54r)
               `cast` (<a_a2Ue>_R
                       %<'Many>_N ->_R Sym (base:Data.Functor.Utils.N:Max[0]) <a_a2Ue>_N
                       :: (a_a2Ue -> GHC.Maybe.Maybe a_a2Ue)
                          ~R# (a_a2Ue -> base:Data.Functor.Utils.Max a_a2Ue))) } in
      \ (x_a54s :: Compose f_a2Rh g_a2Ri a_a2Ue) ->
        case (g_a54p x_a54s)
             `cast` (base:Data.Functor.Utils.N:Max[0] <a_a2Ue>_N
                     :: base:Data.Functor.Utils.Max a_a2Ue ~R# GHC.Maybe.Maybe a_a2Ue)
        of {
          GHC.Maybe.Nothing -> d_a54n;
          GHC.Maybe.Just v_a54x -> v_a54x
        }

-- RHS size: {terms: 21, types: 31, coercions: 26, joins: 0/0}
$celem_a2TZ [Occ=LoopBreaker]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Foldable f, Foldable g, Eq a) =>
     a -> Compose f g a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0] 160 60}]
$celem_a2TZ
  = \ (@(f_a2Rh :: * -> *))
      (@(g_a2Ri :: * -> *))
      ($dFoldable_a2Rj :: Foldable f_a2Rh)
      ($dFoldable_a2Rk :: Foldable g_a2Ri)
      (@a_a2U2)
      ($dEq_a2U3 :: Eq a_a2U2) ->
      ((\ (@(t_a54z :: * -> *))
          ($dFoldable_a54A :: Foldable t_a54z)
          (@a_a54B)
          ($dEq_a54C :: Eq a_a54B)
          (eta_a54D :: a_a54B) ->
          foldMap
            @t_a54z
            $dFoldable_a54A
            @base:Data.Semigroup.Internal.Any
            @a_a54B
            base:Data.Semigroup.Internal.$fMonoidAny
            ((== @a_a54B $dEq_a54C eta_a54D)
             `cast` (<a_a54B>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Any[0])
                     :: (a_a54B -> Bool)
                        ~R# (a_a54B -> base:Data.Semigroup.Internal.Any))))
       `cast` (forall (t :: <* -> *>_N).
               <Foldable t>_R
               %<'Many>_N ->_R forall (a :: <*>_N).
                               <Eq a>_R
                               %<'Many>_N ->_R <a>_R
                               %<'Many>_N ->_R <t a>_R
                               %<'Many>_N ->_R base:Data.Semigroup.Internal.N:Any[0]
               :: (forall {t :: * -> *} {a}.
                   (Foldable t, Eq a) =>
                   a -> t a -> base:Data.Semigroup.Internal.Any)
                  ~R# (forall {t :: * -> *} {a}.
                       (Foldable t, Eq a) =>
                       a -> t a -> Bool)))
        @(Compose f_a2Rh g_a2Ri)
        (Main.$fFoldableCompose
           @f_a2Rh @g_a2Ri $dFoldable_a2Rj $dFoldable_a2Rk)
        @a_a2U2
        $dEq_a2U3

-- RHS size: {terms: 20, types: 22, coercions: 0, joins: 0/0}
$clength_a2TP [Occ=LoopBreaker]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Foldable f, Foldable g) =>
     Compose f g a -> Int
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 121 0}]
$clength_a2TP
  = \ (@(f_a2Rh :: * -> *))
      (@(g_a2Ri :: * -> *))
      ($dFoldable_a2Rj :: Foldable f_a2Rh)
      ($dFoldable_a2Rk :: Foldable g_a2Ri)
      (@a_a2TS) ->
      Data.Foldable.foldl'
        @(Compose f_a2Rh g_a2Ri)
        (Main.$fFoldableCompose
           @f_a2Rh @g_a2Ri $dFoldable_a2Rj $dFoldable_a2Rk)
        @Int
        @a_a2TS
        (\ (c_a54K :: Int) _ [Occ=Dead] ->
           case c_a54K of { GHC.Types.I# x_a54N ->
           GHC.Types.I# (GHC.Prim.+# x_a54N 1#)
           })
        (GHC.Types.I# 0#)

-- RHS size: {terms: 19, types: 36, coercions: 0, joins: 0/1}
$ctoList_a2Tr [Occ=LoopBreaker]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Foldable f, Foldable g) =>
     Compose f g a -> [a]
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 120 60}]
$ctoList_a2Tr
  = \ (@(f_a2Rh :: * -> *))
      (@(g_a2Ri :: * -> *))
      ($dFoldable_a2Rj :: Foldable f_a2Rh)
      ($dFoldable_a2Rk :: Foldable g_a2Ri)
      (@a_a2Tu) ->
      let {
        $dFoldable_a54Q :: Foldable (Compose f_a2Rh g_a2Ri)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 30 0}]
        $dFoldable_a54Q
          = Main.$fFoldableCompose
              @f_a2Rh @g_a2Ri $dFoldable_a2Rj $dFoldable_a2Rk } in
      \ (t1_a54S :: Compose f_a2Rh g_a2Ri a_a2Tu) ->
        GHC.Base.build
          @a_a2Tu
          (\ (@b_a54T)
             (c_a54U [OS=OneShot] :: a_a2Tu -> b_a54T -> b_a54T)
             (n_a54V [OS=OneShot] :: b_a54T) ->
             foldr
               @(Compose f_a2Rh g_a2Ri)
               $dFoldable_a54Q
               @a_a2Tu
               @b_a54T
               c_a54U
               n_a54V
               t1_a54S)

-- RHS size: {terms: 35, types: 50, coercions: 0, joins: 0/1}
$cfoldl1_a2Th [Occ=LoopBreaker]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Foldable f, Foldable g) =>
     (a -> a -> a) -> Compose f g a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 320 60}]
$cfoldl1_a2Th
  = \ (@(f_a2Rh :: * -> *))
      (@(g_a2Ri :: * -> *))
      ($dFoldable_a2Rj :: Foldable f_a2Rh)
      ($dFoldable_a2Rk :: Foldable g_a2Ri)
      (@a_a2Tk) ->
      let {
        $dFoldable_a54X :: Foldable (Compose f_a2Rh g_a2Ri)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 30 0}]
        $dFoldable_a54X
          = Main.$fFoldableCompose
              @f_a2Rh @g_a2Ri $dFoldable_a2Rj $dFoldable_a2Rk } in
      \ (f_a54Z :: a_a2Tk -> a_a2Tk -> a_a2Tk)
        (xs_a550 :: Compose f_a2Rh g_a2Ri a_a2Tk) ->
        case foldl
               @(Compose f_a2Rh g_a2Ri)
               $dFoldable_a54X
               @(GHC.Maybe.Maybe a_a2Tk)
               @a_a2Tk
               (\ (m_a551 :: GHC.Maybe.Maybe a_a2Tk) (y_a552 :: a_a2Tk) ->
                  GHC.Maybe.Just
                    @a_a2Tk
                    (case m_a551 of {
                       GHC.Maybe.Nothing -> y_a552;
                       GHC.Maybe.Just x_a555 -> f_a54Z x_a555 y_a552
                     }))
               (GHC.Maybe.Nothing @a_a2Tk)
               xs_a550
        of {
          GHC.Maybe.Nothing ->
            errorWithoutStackTrace
              @GHC.Types.LiftedRep
              @a_a2Tk
              (GHC.Base.build
                 @Char
                 (\ (@b_a558) ->
                    GHC.CString.unpackFoldrCString#
                      @b_a558 "foldl1: empty structure"#));
          GHC.Maybe.Just v_a559 -> v_a559
        }

-- RHS size: {terms: 35, types: 50, coercions: 0, joins: 0/1}
$cfoldr1_a2T7 [Occ=LoopBreaker]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Foldable f, Foldable g) =>
     (a -> a -> a) -> Compose f g a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 320 60}]
$cfoldr1_a2T7
  = \ (@(f_a2Rh :: * -> *))
      (@(g_a2Ri :: * -> *))
      ($dFoldable_a2Rj :: Foldable f_a2Rh)
      ($dFoldable_a2Rk :: Foldable g_a2Ri)
      (@a_a2Ta) ->
      let {
        $dFoldable_a55d :: Foldable (Compose f_a2Rh g_a2Ri)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 30 0}]
        $dFoldable_a55d
          = Main.$fFoldableCompose
              @f_a2Rh @g_a2Ri $dFoldable_a2Rj $dFoldable_a2Rk } in
      \ (f_a55f :: a_a2Ta -> a_a2Ta -> a_a2Ta)
        (xs_a55g :: Compose f_a2Rh g_a2Ri a_a2Ta) ->
        case foldr
               @(Compose f_a2Rh g_a2Ri)
               $dFoldable_a55d
               @a_a2Ta
               @(GHC.Maybe.Maybe a_a2Ta)
               (\ (x_a55h :: a_a2Ta) (m_a55i :: GHC.Maybe.Maybe a_a2Ta) ->
                  GHC.Maybe.Just
                    @a_a2Ta
                    (case m_a55i of {
                       GHC.Maybe.Nothing -> x_a55h;
                       GHC.Maybe.Just y_a55l -> f_a55f x_a55h y_a55l
                     }))
               (GHC.Maybe.Nothing @a_a2Ta)
               xs_a55g
        of {
          GHC.Maybe.Nothing ->
            errorWithoutStackTrace
              @GHC.Types.LiftedRep
              @a_a2Ta
              (GHC.Base.build
                 @Char
                 (\ (@b_a55o) ->
                    GHC.CString.unpackFoldrCString#
                      @b_a55o "foldr1: empty structure"#));
          GHC.Maybe.Just v_a55p -> v_a55p
        }

-- RHS size: {terms: 28, types: 42, coercions: 0, joins: 0/1}
$cfoldl'_a2SV [Occ=LoopBreaker]
  :: forall (f :: * -> *) (g :: * -> *) b a.
     (Foldable f, Foldable g) =>
     (b -> a -> b) -> b -> Compose f g a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 220 60}]
$cfoldl'_a2SV
  = \ (@(f_a2Rh :: * -> *))
      (@(g_a2Ri :: * -> *))
      ($dFoldable_a2Rj :: Foldable f_a2Rh)
      ($dFoldable_a2Rk :: Foldable g_a2Ri)
      (@b_a2SY)
      (@a_a2SZ) ->
      let {
        $dFoldable_a55t :: Foldable (Compose f_a2Rh g_a2Ri)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 30 0}]
        $dFoldable_a55t
          = Main.$fFoldableCompose
              @f_a2Rh @g_a2Ri $dFoldable_a2Rj $dFoldable_a2Rk } in
      \ (f_a55w :: b_a2SY -> a_a2SZ -> b_a2SY)
        (z0_a55x :: b_a2SY)
        (xs_a55y :: Compose f_a2Rh g_a2Ri a_a2SZ) ->
        foldr
          @(Compose f_a2Rh g_a2Ri)
          $dFoldable_a55t
          @a_a2SZ
          @(b_a2SY -> b_a2SY)
          (\ (ds_a55z :: a_a2SZ)
             (ds1_a55A :: b_a2SY -> b_a2SY)
             (v_a55B [OS=OneShot] :: b_a2SY) ->
             case v_a55B of z_a55C { __DEFAULT ->
             ds1_a55A (f_a55w z_a55C ds_a55z)
             })
          (id @b_a2SY)
          xs_a55y
          z0_a55x

-- RHS size: {terms: 24, types: 42, coercions: 10, joins: 0/1}
$cfoldl_a2SJ [Occ=LoopBreaker]
  :: forall (f :: * -> *) (g :: * -> *) b a.
     (Foldable f, Foldable g) =>
     (b -> a -> b) -> b -> Compose f g a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 200 60}]
$cfoldl_a2SJ
  = \ (@(f_a2Rh :: * -> *))
      (@(g_a2Ri :: * -> *))
      ($dFoldable_a2Rj :: Foldable f_a2Rh)
      ($dFoldable_a2Rk :: Foldable g_a2Ri)
      (@b_a2SM)
      (@a_a2SN) ->
      let {
        $dFoldable_a55F :: Foldable (Compose f_a2Rh g_a2Ri)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 30 0}]
        $dFoldable_a55F
          = Main.$fFoldableCompose
              @f_a2Rh @g_a2Ri $dFoldable_a2Rj $dFoldable_a2Rk } in
      \ (eta_a55I :: b_a2SM -> a_a2SN -> b_a2SM)
        (eta1_a55J :: b_a2SM)
        (eta2_a55K :: Compose f_a2Rh g_a2Ri a_a2SN) ->
        ((foldMap
            @(Compose f_a2Rh g_a2Ri)
            $dFoldable_a55F
            @(base:Data.Semigroup.Internal.Dual
                (base:Data.Semigroup.Internal.Endo b_a2SM))
            @a_a2SN
            (base:Data.Semigroup.Internal.$fMonoidDual
               @(base:Data.Semigroup.Internal.Endo b_a2SM)
               (base:Data.Semigroup.Internal.$fMonoidEndo @b_a2SM))
            ((\ (x_a55N :: a_a2SN) (y_a55O :: b_a2SM) ->
                eta_a55I y_a55O x_a55N)
             `cast` (<a_a2SN>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Dual[0]
                                              (base:Data.Semigroup.Internal.N:Endo[0] <b_a2SM>_R))
                     :: (a_a2SN -> b_a2SM -> b_a2SM)
                        ~R# (a_a2SN
                             -> base:Data.Semigroup.Internal.Dual
                                  (base:Data.Semigroup.Internal.Endo b_a2SM))))
            eta2_a55K)
         `cast` (base:Data.Semigroup.Internal.N:Dual[0]
                     (base:Data.Semigroup.Internal.N:Endo[0] <b_a2SM>_R)
                 :: base:Data.Semigroup.Internal.Dual
                      (base:Data.Semigroup.Internal.Endo b_a2SM)
                    ~R# (b_a2SM -> b_a2SM)))
          eta1_a55J

-- RHS size: {terms: 28, types: 42, coercions: 0, joins: 0/1}
$cfoldr'_a2Sx [Occ=LoopBreaker]
  :: forall (f :: * -> *) (g :: * -> *) a b.
     (Foldable f, Foldable g) =>
     (a -> b -> b) -> b -> Compose f g a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 220 60}]
$cfoldr'_a2Sx
  = \ (@(f_a2Rh :: * -> *))
      (@(g_a2Ri :: * -> *))
      ($dFoldable_a2Rj :: Foldable f_a2Rh)
      ($dFoldable_a2Rk :: Foldable g_a2Ri)
      (@a_a2SA)
      (@b_a2SB) ->
      let {
        $dFoldable_a55U :: Foldable (Compose f_a2Rh g_a2Ri)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 30 0}]
        $dFoldable_a55U
          = Main.$fFoldableCompose
              @f_a2Rh @g_a2Ri $dFoldable_a2Rj $dFoldable_a2Rk } in
      \ (f_a55X :: a_a2SA -> b_a2SB -> b_a2SB)
        (z0_a55Y :: b_a2SB)
        (xs_a55Z :: Compose f_a2Rh g_a2Ri a_a2SA) ->
        foldl
          @(Compose f_a2Rh g_a2Ri)
          $dFoldable_a55U
          @(b_a2SB -> b_a2SB)
          @a_a2SA
          (\ (ds_a560 :: b_a2SB -> b_a2SB)
             (ds1_a561 :: a_a2SA)
             (v_a562 [OS=OneShot] :: b_a2SB) ->
             case v_a562 of z_a563 { __DEFAULT ->
             ds_a560 (f_a55X ds1_a561 z_a563)
             })
          (id @b_a2SB)
          xs_a55Z
          z0_a55Y

-- RHS size: {terms: 26, types: 36, coercions: 0, joins: 0/2}
$cfoldMap'_a2RS [Occ=LoopBreaker]
  :: forall (f :: * -> *) (g :: * -> *) m a.
     (Foldable f, Foldable g, Monoid m) =>
     (a -> m) -> Compose f g a -> m
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 60] 220 60}]
$cfoldMap'_a2RS
  = \ (@(f_a2Rh :: * -> *))
      (@(g_a2Ri :: * -> *))
      ($dFoldable_a2Rj :: Foldable f_a2Rh)
      ($dFoldable_a2Rk :: Foldable g_a2Ri)
      (@m_a2RV)
      (@a_a2RW)
      ($dMonoid_a2RX :: Monoid m_a2RV) ->
      let {
        $dFoldable_a565 :: Foldable (Compose f_a2Rh g_a2Ri)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 30 0}]
        $dFoldable_a565
          = Main.$fFoldableCompose
              @f_a2Rh @g_a2Ri $dFoldable_a2Rj $dFoldable_a2Rk } in
      \ (eta_a569 :: a_a2RW -> m_a2RV) ->
        let {
          $dSemigroup_a56a :: Semigroup m_a2RV
          [LclId,
           Unf=Unf{Src=<vanilla>, TopLvl=False,
                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                   Guidance=IF_ARGS [] 20 0}]
          $dSemigroup_a56a = GHC.Base.$p1Monoid @m_a2RV $dMonoid_a2RX } in
        Data.Foldable.foldl'
          @(Compose f_a2Rh g_a2Ri)
          $dFoldable_a565
          @m_a2RV
          @a_a2RW
          (\ (acc_a56b :: m_a2RV) (a1_a56c :: a_a2RW) ->
             <> @m_a2RV $dSemigroup_a56a acc_a56b (eta_a569 a1_a56c))
          (mempty @m_a2RV $dMonoid_a2RX)

-- RHS size: {terms: 20, types: 32, coercions: 25, joins: 0/0}
$cproduct_a2UL [Occ=LoopBreaker]
  :: forall (f :: * -> *) (g :: * -> *) a.
     (Foldable f, Foldable g, Num a) =>
     Compose f g a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0] 150 60}]
$cproduct_a2UL
  = \ (@(f_a2Rh :: * -> *))
      (@(g_a2Ri :: * -> *))
      ($dFoldable_a2Rj :: Foldable f_a2Rh)
      ($dFoldable_a2Rk :: Foldable g_a2Ri)
      (@a_a2UO)
      ($dNum_a2UP :: Num a_a2UO) ->
      ((\ (@(t_a56d :: * -> *))
          ($dFoldable_a56e :: Foldable t_a56d)
          (@a_a56f)
          ($dNum_a56g :: Num a_a56f) ->
          Data.Foldable.foldMap'
            @t_a56d
            $dFoldable_a56e
            @(base:Data.Semigroup.Internal.Product a_a56f)
            @a_a56f
            (base:Data.Semigroup.Internal.$fMonoidProduct @a_a56f $dNum_a56g)
            ((\ (ds_a56i :: a_a56f) -> ds_a56i)
             `cast` (<a_a56f>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Product[0]
                                              <a_a56f>_R)
                     :: (a_a56f -> a_a56f)
                        ~R# (a_a56f -> base:Data.Semigroup.Internal.Product a_a56f))))
       `cast` (forall (t :: <* -> *>_N).
               <Foldable t>_R
               %<'Many>_N ->_R forall (a :: <*>_N).
                               <Num a>_R
                               %<'Many>_N ->_R <t a>_R
                               %<'Many>_N ->_R base:Data.Semigroup.Internal.N:Product[0] <a>_R
               :: (forall {t :: * -> *} {a}.
                   (Foldable t, Num a) =>
                   t a -> base:Data.Semigroup.Internal.Product a)
                  ~R# (forall {t :: * -> *} {a}. (Foldable t, Num a) => t a -> a)))
        @(Compose f_a2Rh g_a2Ri)
        (Main.$fFoldableCompose
           @f_a2Rh @g_a2Ri $dFoldable_a2Rj $dFoldable_a2Rk)
        @a_a2UO
        $dNum_a2UP

-- RHS size: {terms: 12, types: 21, coercions: 0, joins: 0/0}
$cfold_a2Rm [Occ=LoopBreaker]
  :: forall (f :: * -> *) (g :: * -> *) m.
     (Foldable f, Foldable g, Monoid m) =>
     Compose f g m -> m
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0] 70 0}]
$cfold_a2Rm
  = \ (@(f_a2Rh :: * -> *))
      (@(g_a2Ri :: * -> *))
      ($dFoldable_a2Rj :: Foldable f_a2Rh)
      ($dFoldable_a2Rk :: Foldable g_a2Ri)
      (@m_a2Rp)
      ($dMonoid_a2Rq :: Monoid m_a2Rp) ->
      foldMap
        @(Compose f_a2Rh g_a2Ri)
        (Main.$fFoldableCompose
           @f_a2Rh @g_a2Ri $dFoldable_a2Rj $dFoldable_a2Rk)
        @m_a2Rp
        @m_a2Rp
        $dMonoid_a2Rq
        (id @m_a2Rp)
end Rec }

-- RHS size: {terms: 9, types: 12, coercions: 0, joins: 0/0}
$cp2Traversable_a49k
  :: forall {f :: * -> *} {g :: * -> *}.
     (Traversable f, Traversable g) =>
     Foldable (Compose f g)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30] 70 0}]
$cp2Traversable_a49k
  = \ (@(f_a499 :: * -> *))
      (@(g_a49a :: * -> *))
      ($dTraversable_a49b :: Traversable f_a499)
      ($dTraversable_a49c :: Traversable g_a49a) ->
      Main.$fFoldableCompose
        @f_a499
        @g_a49a
        (Data.Traversable.$p2Traversable @f_a499 $dTraversable_a49b)
        (Data.Traversable.$p2Traversable @g_a49a $dTraversable_a49c)

-- RHS size: {terms: 20, types: 41, coercions: 0, joins: 0/0}
$c<$_a2QS
  :: forall (f :: * -> *) (g :: * -> *) a b.
     (Functor f, Functor g) =>
     a -> Compose f g b -> Compose f g a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 0 20] 110 10}]
$c<$_a2QS
  = \ (@(f_a2Qq :: * -> *))
      (@(g_a2Qr :: * -> *))
      ($dFunctor_a2Qs :: Functor f_a2Qq)
      ($dFunctor_a2Qt :: Functor g_a2Qr)
      (@a_a2QV)
      (@b_a2QW)
      (z_a2at :: a_a2QV)
      (ds_d4Ka :: Compose f_a2Qq g_a2Qr b_a2QW) ->
      case ds_d4Ka of { MkCompose a1_a2au ->
      Main.MkCompose
        @(*)
        @(*)
        @f_a2Qq
        @g_a2Qr
        @a_a2QV
        (fmap
           @f_a2Qq
           $dFunctor_a2Qs
           @(g_a2Qr b_a2QW)
           @(g_a2Qr a_a2QV)
           (\ (b1_a2av :: g_a2Qr b_a2QW) ->
              <$ @g_a2Qr $dFunctor_a2Qt @a_a2QV @b_a2QW z_a2at b1_a2av)
           a1_a2au)
      }

-- RHS size: {terms: 20, types: 42, coercions: 0, joins: 0/0}
$cfmap_a2Qv
  :: forall (f :: * -> *) (g :: * -> *) a b.
     (Functor f, Functor g) =>
     (a -> b) -> Compose f g a -> Compose f g b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 0 20] 110 10}]
$cfmap_a2Qv
  = \ (@(f_a2Qq :: * -> *))
      (@(g_a2Qr :: * -> *))
      ($dFunctor_a2Qs :: Functor f_a2Qq)
      ($dFunctor_a2Qt :: Functor g_a2Qr)
      (@a_a2Qy)
      (@b_a2Qz)
      (f_a2aq :: a_a2Qy -> b_a2Qz)
      (ds_d4K5 :: Compose f_a2Qq g_a2Qr a_a2Qy) ->
      case ds_d4K5 of { MkCompose a1_a2ar ->
      Main.MkCompose
        @(*)
        @(*)
        @f_a2Qq
        @g_a2Qr
        @b_a2Qz
        (fmap
           @f_a2Qq
           $dFunctor_a2Qs
           @(g_a2Qr a_a2Qy)
           @(g_a2Qr b_a2Qz)
           (\ (b1_a2as :: g_a2Qr a_a2Qy) ->
              fmap @g_a2Qr $dFunctor_a2Qt @a_a2Qy @b_a2Qz f_a2aq b1_a2as)
           a1_a2ar)
      }

-- RHS size: {terms: 11, types: 17, coercions: 0, joins: 0/0}
Main.$fFunctorCompose [InlPrag=CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Functor f, Functor g) =>
     Functor (Compose f g)
[LclIdX[DFunId],
 Unf=DFun: \ (@(f_a1v8 :: * -> *))
             (@(g_a1v9 :: * -> *))
             (v_B1 :: Functor f_a1v8)
             (v_B2 :: Functor g_a1v9) ->
       GHC.Base.C:Functor TYPE: Compose f_a1v8 g_a1v9
                          $cfmap_a2Qv @f_a1v8 @g_a1v9 v_B1 v_B2
                          $c<$_a2QS @f_a1v8 @g_a1v9 v_B1 v_B2]
Main.$fFunctorCompose
  = \ (@(f_a2Qq :: * -> *))
      (@(g_a2Qr :: * -> *))
      ($dFunctor_a2Qs :: Functor f_a2Qq)
      ($dFunctor_a2Qt :: Functor g_a2Qr) ->
      GHC.Base.C:Functor
        @(Compose f_a2Qq g_a2Qr)
        ($cfmap_a2Qv @f_a2Qq @g_a2Qr $dFunctor_a2Qs $dFunctor_a2Qt)
        ($c<$_a2QS @f_a2Qq @g_a2Qr $dFunctor_a2Qs $dFunctor_a2Qt)

-- RHS size: {terms: 9, types: 12, coercions: 0, joins: 0/0}
$cp1Traversable_a49g
  :: forall {f :: * -> *} {g :: * -> *}.
     (Traversable f, Traversable g) =>
     Functor (Compose f g)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30] 70 0}]
$cp1Traversable_a49g
  = \ (@(f_a499 :: * -> *))
      (@(g_a49a :: * -> *))
      ($dTraversable_a49b :: Traversable f_a499)
      ($dTraversable_a49c :: Traversable g_a49a) ->
      Main.$fFunctorCompose
        @f_a499
        @g_a49a
        (Data.Traversable.$p1Traversable @f_a499 $dTraversable_a49b)
        (Data.Traversable.$p1Traversable @g_a49a $dTraversable_a49c)

Rec {
-- RHS size: {terms: 23, types: 25, coercions: 0, joins: 0/0}
Main.$fTraversableCompose [InlPrag=CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Traversable f, Traversable g) =>
     Traversable (Compose f g)
[LclIdX[DFunId],
 Unf=DFun: \ (@(f_aUs :: * -> *))
             (@(g_aUt :: * -> *))
             (v_B1 :: Traversable f_aUs)
             (v_B2 :: Traversable g_aUt) ->
       Data.Traversable.C:Traversable TYPE: Compose f_aUs g_aUt
                                      $cp1Traversable_a49g @f_aUs @g_aUt v_B1 v_B2
                                      $cp2Traversable_a49k @f_aUs @g_aUt v_B1 v_B2
                                      $ctraverse_a49m @f_aUs @g_aUt v_B1 v_B2
                                      $csequenceA_a49C @f_aUs @g_aUt v_B1 v_B2
                                      $cmapM_a49Q @f_aUs @g_aUt v_B1 v_B2
                                      $csequence_a4a6 @f_aUs @g_aUt v_B1 v_B2]
Main.$fTraversableCompose
  = \ (@(f_a499 :: * -> *))
      (@(g_a49a :: * -> *))
      ($dTraversable_a49b :: Traversable f_a499)
      ($dTraversable_a49c :: Traversable g_a49a) ->
      Data.Traversable.C:Traversable
        @(Compose f_a499 g_a49a)
        ($cp1Traversable_a49g
           @f_a499 @g_a49a $dTraversable_a49b $dTraversable_a49c)
        ($cp2Traversable_a49k
           @f_a499 @g_a49a $dTraversable_a49b $dTraversable_a49c)
        ($ctraverse_a49m
           @f_a499 @g_a49a $dTraversable_a49b $dTraversable_a49c)
        ($csequenceA_a49C
           @f_a499 @g_a49a $dTraversable_a49b $dTraversable_a49c)
        ($cmapM_a49Q @f_a499 @g_a49a $dTraversable_a49b $dTraversable_a49c)
        ($csequence_a4a6
           @f_a499 @g_a49a $dTraversable_a49b $dTraversable_a49c)

-- RHS size: {terms: 14, types: 25, coercions: 0, joins: 0/0}
$cmapM_a49Q [Occ=LoopBreaker]
  :: forall (f :: * -> *) (g :: * -> *) (m :: * -> *) a b.
     (Traversable f, Traversable g, Monad m) =>
     (a -> m b) -> Compose f g a -> m (Compose f g b)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 30] 80 0}]
$cmapM_a49Q
  = \ (@(f_a499 :: * -> *))
      (@(g_a49a :: * -> *))
      ($dTraversable_a49b :: Traversable f_a499)
      ($dTraversable_a49c :: Traversable g_a49a)
      (@(m_a49T :: * -> *))
      (@a_a49U)
      (@b_a49V)
      ($dMonad_a49W :: Monad m_a49T) ->
      traverse
        @(Compose f_a499 g_a49a)
        (Main.$fTraversableCompose
           @f_a499 @g_a49a $dTraversable_a49b $dTraversable_a49c)
        @m_a49T
        @a_a49U
        @b_a49V
        (GHC.Base.$p1Monad @m_a49T $dMonad_a49W)

-- RHS size: {terms: 13, types: 26, coercions: 0, joins: 0/0}
$csequenceA_a49C [Occ=LoopBreaker]
  :: forall (f :: * -> *) (g :: * -> *) (f :: * -> *) a.
     (Traversable f, Traversable g, Applicative f) =>
     Compose f g (f a) -> f (Compose f g a)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0] 70 0}]
$csequenceA_a49C
  = \ (@(f_a499 :: * -> *))
      (@(g_a49a :: * -> *))
      ($dTraversable_a49b :: Traversable f_a499)
      ($dTraversable_a49c :: Traversable g_a49a)
      (@(f_a49F :: * -> *))
      (@a_a49G)
      ($dApplicative_a49H :: Applicative f_a49F) ->
      traverse
        @(Compose f_a499 g_a49a)
        (Main.$fTraversableCompose
           @f_a499 @g_a49a $dTraversable_a49b $dTraversable_a49c)
        @f_a49F
        @(f_a49F a_a49G)
        @a_a49G
        $dApplicative_a49H
        (id @(f_a49F a_a49G))

-- RHS size: {terms: 13, types: 23, coercions: 0, joins: 0/0}
$csequence_a4a6 [Occ=LoopBreaker]
  :: forall (f :: * -> *) (g :: * -> *) (m :: * -> *) a.
     (Traversable f, Traversable g, Monad m) =>
     Compose f g (m a) -> m (Compose f g a)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 30] 80 0}]
$csequence_a4a6
  = \ (@(f_a499 :: * -> *))
      (@(g_a49a :: * -> *))
      ($dTraversable_a49b :: Traversable f_a499)
      ($dTraversable_a49c :: Traversable g_a49a)
      (@(m_a4a9 :: * -> *))
      (@a_a4aa)
      ($dMonad_a4ab :: Monad m_a4a9) ->
      sequenceA
        @(Compose f_a499 g_a49a)
        (Main.$fTraversableCompose
           @f_a499 @g_a49a $dTraversable_a49b $dTraversable_a49c)
        @m_a4a9
        @a_a4aa
        (GHC.Base.$p1Monad @m_a4a9 $dMonad_a4ab)

-- RHS size: {terms: 26, types: 78, coercions: 0, joins: 0/3}
$ctraverse_a49m [Occ=LoopBreaker]
  :: forall (f :: * -> *) (g :: * -> *) (f :: * -> *) a b.
     (Traversable f, Traversable g, Applicative f) =>
     (a -> f b) -> Compose f g a -> f (Compose f g b)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0] 200 60}]
$ctraverse_a49m
  = \ (@(f_a499 :: * -> *))
      (@(g_a49a :: * -> *))
      ($dTraversable_a49b :: Traversable f_a499)
      ($dTraversable_a49c :: Traversable g_a49a)
      (@(f_a49p :: * -> *))
      (@a_a49q)
      (@b_a49r)
      ($dApplicative_a49s :: Applicative f_a49p) ->
      let {
        $dTraversable_a56I :: Traversable (Compose f_a499 g_a49a)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 30 0}]
        $dTraversable_a56I
          = Main.$fTraversableCompose
              @f_a499 @g_a49a $dTraversable_a49b $dTraversable_a49c } in
      \ (eta1_a56N :: a_a49q -> f_a49p b_a49r) ->
        let {
          f1_a56O
            :: Compose f_a499 g_a49a (f_a49p b_a49r)
               -> f_a49p (Compose f_a499 g_a49a b_a49r)
          [LclId,
           Unf=Unf{Src=<vanilla>, TopLvl=False,
                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                   Guidance=IF_ARGS [] 30 0}]
          f1_a56O
            = sequenceA
                @(Compose f_a499 g_a49a)
                $dTraversable_a56I
                @f_a49p
                @b_a49r
                $dApplicative_a49s } in
        let {
          g_a56P
            :: Compose f_a499 g_a49a a_a49q
               -> Compose f_a499 g_a49a (f_a49p b_a49r)
          [LclId,
           Unf=Unf{Src=<vanilla>, TopLvl=False,
                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                   Guidance=IF_ARGS [] 50 0}]
          g_a56P
            = fmap
                @(Compose f_a499 g_a49a)
                (Data.Traversable.$p1Traversable
                   @(Compose f_a499 g_a49a) $dTraversable_a56I)
                @a_a49q
                @(f_a49p b_a49r)
                eta1_a56N } in
        \ (x_a56Q :: Compose f_a499 g_a49a a_a49q) ->
          f1_a56O (g_a56P x_a56Q)
end Rec }

-- RHS size: {terms: 26, types: 34, coercions: 0, joins: 0/0}
$cshowsPrec_a2PX
  :: forall k (f :: k -> *) k (g :: k -> k) (a :: k).
     Show (f (g a)) =>
     Int -> Compose f g a -> ShowS
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 0 20] 250 0}]
$cshowsPrec_a2PX
  = \ (@k_a2PQ)
      (@(f_a2PR :: k_a2PQ -> *))
      (@k_a2PS)
      (@(g_a2PT :: k_a2PS -> k_a2PQ))
      (@(a_a2PU :: k_a2PS))
      ($dShow_a2PV :: Show (f_a2PR (g_a2PT a_a2PU)))
      (a_a2ao :: Int)
      (ds_d4JU :: Compose f_a2PR g_a2PT a_a2PU) ->
      case ds_d4JU of { MkCompose b1_a2ap ->
      showParen
        (>= @Int GHC.Classes.$fOrdInt a_a2ao (GHC.Types.I# 11#))
        (. @String
           @String
           @String
           (showString (GHC.CString.unpackCString# "MkCompose "#))
           (showsPrec
              @(f_a2PR (g_a2PT a_a2PU)) $dShow_a2PV (GHC.Types.I# 11#) b1_a2ap))
      }

Rec {
-- RHS size: {terms: 13, types: 32, coercions: 0, joins: 0/0}
Main.$fShowCompose [InlPrag=CONLIKE]
  :: forall k (f :: k -> *) k (g :: k -> k) (a :: k).
     Show (f (g a)) =>
     Show (Compose f g a)
[LclIdX[DFunId],
 Unf=DFun: \ (@k_a1uX)
             (@(f_a1uY :: k_a1uX -> *))
             (@k_a1uZ)
             (@(g_a1v0 :: k_a1uZ -> k_a1uX))
             (@(a_a1v1 :: k_a1uZ))
             (v_B1 :: Show (f_a1uY (g_a1v0 a_a1v1))) ->
       GHC.Show.C:Show TYPE: Compose f_a1uY g_a1v0 a_a1v1
                       $cshowsPrec_a2PX @k_a1uX @f_a1uY @k_a1uZ @g_a1v0 @a_a1v1 v_B1
                       $cshow_a2Qa @k_a1uX @f_a1uY @k_a1uZ @g_a1v0 @a_a1v1 v_B1
                       $cshowList_a2Qh @k_a1uX @f_a1uY @k_a1uZ @g_a1v0 @a_a1v1 v_B1]
Main.$fShowCompose
  = \ (@k_a2PQ)
      (@(f_a2PR :: k_a2PQ -> *))
      (@k_a2PS)
      (@(g_a2PT :: k_a2PS -> k_a2PQ))
      (@(a_a2PU :: k_a2PS))
      ($dShow_a2PV :: Show (f_a2PR (g_a2PT a_a2PU))) ->
      GHC.Show.C:Show
        @(Compose f_a2PR g_a2PT a_a2PU)
        ($cshowsPrec_a2PX
           @k_a2PQ @f_a2PR @k_a2PS @g_a2PT @a_a2PU $dShow_a2PV)
        ($cshow_a2Qa @k_a2PQ @f_a2PR @k_a2PS @g_a2PT @a_a2PU $dShow_a2PV)
        ($cshowList_a2Qh
           @k_a2PQ @f_a2PR @k_a2PS @g_a2PT @a_a2PU $dShow_a2PV)

-- RHS size: {terms: 18, types: 43, coercions: 0, joins: 0/1}
$cshowList_a2Qh [Occ=LoopBreaker]
  :: forall k (f :: k -> *) k (g :: k -> k) (a :: k).
     Show (f (g a)) =>
     [Compose f g a] -> ShowS
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 130 60}]
$cshowList_a2Qh
  = \ (@k_a2PQ)
      (@(f_a2PR :: k_a2PQ -> *))
      (@k_a2PS)
      (@(g_a2PT :: k_a2PS -> k_a2PQ))
      (@(a_a2PU :: k_a2PS))
      ($dShow_a2PV :: Show (f_a2PR (g_a2PT a_a2PU))) ->
      let {
        $dShow_a56S :: Show (Compose f_a2PR g_a2PT a_a2PU)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dShow_a56S
          = Main.$fShowCompose
              @k_a2PQ @f_a2PR @k_a2PS @g_a2PT @a_a2PU $dShow_a2PV } in
      \ (ls_a56T :: [Compose f_a2PR g_a2PT a_a2PU]) (s_a56U :: String) ->
        GHC.Show.showList__
          @(Compose f_a2PR g_a2PT a_a2PU)
          (showsPrec
             @(Compose f_a2PR g_a2PT a_a2PU) $dShow_a56S (GHC.Types.I# 0#))
          ls_a56T
          s_a56U

-- RHS size: {terms: 16, types: 36, coercions: 0, joins: 0/1}
$cshow_a2Qa [Occ=LoopBreaker]
  :: forall k (f :: k -> *) k (g :: k -> k) (a :: k).
     Show (f (g a)) =>
     Compose f g a -> String
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 100 60}]
$cshow_a2Qa
  = \ (@k_a2PQ)
      (@(f_a2PR :: k_a2PQ -> *))
      (@k_a2PS)
      (@(g_a2PT :: k_a2PS -> k_a2PQ))
      (@(a_a2PU :: k_a2PS))
      ($dShow_a2PV :: Show (f_a2PR (g_a2PT a_a2PU))) ->
      let {
        $dShow_a56X :: Show (Compose f_a2PR g_a2PT a_a2PU)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dShow_a56X
          = Main.$fShowCompose
              @k_a2PQ @f_a2PR @k_a2PS @g_a2PT @a_a2PU $dShow_a2PV } in
      \ (x_a56Y :: Compose f_a2PR g_a2PT a_a2PU) ->
        showsPrec
          @(Compose f_a2PR g_a2PT a_a2PU)
          $dShow_a56X
          (GHC.Types.I# 0#)
          x_a56Y
          (GHC.Types.[] @Char)
end Rec }

-- RHS size: {terms: 18, types: 44, coercions: 0, joins: 0/0}
$c==_a2Py
  :: forall k (f :: k -> *) k (g :: k -> k) (a :: k).
     Eq (f (g a)) =>
     Compose f g a -> Compose f g a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 20 20] 60 0}]
$c==_a2Py
  = \ (@k_a2Pr)
      (@(f_a2Ps :: k_a2Pr -> *))
      (@k_a2Pt)
      (@(g_a2Pu :: k_a2Pt -> k_a2Pr))
      (@(a_a2Pv :: k_a2Pt))
      ($dEq_a2Pw :: Eq (f_a2Ps (g_a2Pu a_a2Pv)))
      (ds_d4JM :: Compose f_a2Ps g_a2Pu a_a2Pv)
      (ds_d4JN :: Compose f_a2Ps g_a2Pu a_a2Pv) ->
      case ds_d4JM of { MkCompose a1_a2am ->
      case ds_d4JN of { MkCompose b1_a2an ->
      == @(f_a2Ps (g_a2Pu a_a2Pv)) $dEq_a2Pw a1_a2am b1_a2an
      }
      }

Rec {
-- RHS size: {terms: 11, types: 27, coercions: 0, joins: 0/0}
Main.$fEqCompose [InlPrag=CONLIKE]
  :: forall k (f :: k -> *) k (g :: k -> k) (a :: k).
     Eq (f (g a)) =>
     Eq (Compose f g a)
[LclIdX[DFunId],
 Unf=DFun: \ (@k_a1uN)
             (@(f_a1uO :: k_a1uN -> *))
             (@k_a1uP)
             (@(g_a1uQ :: k_a1uP -> k_a1uN))
             (@(a_a1uR :: k_a1uP))
             (v_B1 :: Eq (f_a1uO (g_a1uQ a_a1uR))) ->
       GHC.Classes.C:Eq TYPE: Compose f_a1uO g_a1uQ a_a1uR
                        $c==_a2Py @k_a1uN @f_a1uO @k_a1uP @g_a1uQ @a_a1uR v_B1
                        $c/=_a2PH @k_a1uN @f_a1uO @k_a1uP @g_a1uQ @a_a1uR v_B1]
Main.$fEqCompose
  = \ (@k_a2Pr)
      (@(f_a2Ps :: k_a2Pr -> *))
      (@k_a2Pt)
      (@(g_a2Pu :: k_a2Pt -> k_a2Pr))
      (@(a_a2Pv :: k_a2Pt))
      ($dEq_a2Pw :: Eq (f_a2Ps (g_a2Pu a_a2Pv))) ->
      GHC.Classes.C:Eq
        @(Compose f_a2Ps g_a2Pu a_a2Pv)
        ($c==_a2Py @k_a2Pr @f_a2Ps @k_a2Pt @g_a2Pu @a_a2Pv $dEq_a2Pw)
        ($c/=_a2PH @k_a2Pr @f_a2Ps @k_a2Pt @g_a2Pu @a_a2Pv $dEq_a2Pw)

-- RHS size: {terms: 20, types: 42, coercions: 0, joins: 0/1}
$c/=_a2PH [Occ=LoopBreaker]
  :: forall k (f :: k -> *) k (g :: k -> k) (a :: k).
     Eq (f (g a)) =>
     Compose f g a -> Compose f g a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 110 60}]
$c/=_a2PH
  = \ (@k_a2Pr)
      (@(f_a2Ps :: k_a2Pr -> *))
      (@k_a2Pt)
      (@(g_a2Pu :: k_a2Pt -> k_a2Pr))
      (@(a_a2Pv :: k_a2Pt))
      ($dEq_a2Pw :: Eq (f_a2Ps (g_a2Pu a_a2Pv))) ->
      let {
        $dEq_a570 :: Eq (Compose f_a2Ps g_a2Pu a_a2Pv)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dEq_a570
          = Main.$fEqCompose
              @k_a2Pr @f_a2Ps @k_a2Pt @g_a2Pu @a_a2Pv $dEq_a2Pw } in
      \ (x_a571 :: Compose f_a2Ps g_a2Pu a_a2Pv)
        (y_a572 :: Compose f_a2Ps g_a2Pu a_a2Pv) ->
        case == @(Compose f_a2Ps g_a2Pu a_a2Pv) $dEq_a570 x_a571 y_a572
        of {
          False -> GHC.Types.True;
          True -> GHC.Types.False
        }
end Rec }

-- RHS size: {terms: 13, types: 22, coercions: 0, joins: 0/0}
$cnull_a2O5
  :: forall (f :: * -> *) a a. Foldable f => Sum f a a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30] 50 10}]
$cnull_a2O5
  = \ (@(f_a2LR :: * -> *))
      (@a_a2LS)
      ($dFoldable_a2LT :: Foldable f_a2LR)
      (@a_a2O8)
      (ds_d4Jv :: Sum f_a2LR a_a2LS a_a2O8) ->
      case ds_d4Jv of {
        FLeft _ [Occ=Dead] -> GHC.Types.True;
        FRight a1_a2al -> null @f_a2LR $dFoldable_a2LT @a_a2O8 a1_a2al
      }

-- RHS size: {terms: 18, types: 28, coercions: 0, joins: 0/0}
$cfoldr_a2MD
  :: forall (f :: * -> *) a a b.
     Foldable f =>
     (a -> b -> b) -> b -> Sum f a a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 0 0 30] 70 0}]
$cfoldr_a2MD
  = \ (@(f_a2LR :: * -> *))
      (@a_a2LS)
      ($dFoldable_a2LT :: Foldable f_a2LR)
      (@a_a2MG)
      (@b_a2MH)
      (f_a2a8 :: a_a2MG -> b_a2MH -> b_a2MH)
      (z_a2a9 :: b_a2MH)
      (ds_d4Jg :: Sum f_a2LR a_a2LS a_a2MG) ->
      case ds_d4Jg of {
        FLeft _ [Occ=Dead] -> z_a2a9;
        FRight a1_a2ad ->
          foldr @f_a2LR $dFoldable_a2LT @a_a2MG @b_a2MH f_a2a8 z_a2a9 a1_a2ad
      }

-- RHS size: {terms: 19, types: 29, coercions: 0, joins: 0/0}
$cfoldMap_a2M7
  :: forall (f :: * -> *) a m a.
     (Foldable f, Monoid m) =>
     (a -> m) -> Sum f a a -> m
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 0 50] 90 0}]
$cfoldMap_a2M7
  = \ (@(f_a2LR :: * -> *))
      (@a_a2LS)
      ($dFoldable_a2LT :: Foldable f_a2LR)
      (@m_a2Ma)
      (@a_a2Mb)
      ($dMonoid_a2Mc :: Monoid m_a2Ma)
      (f_a2ag :: a_a2Mb -> m_a2Ma)
      (ds_d4Jb :: Sum f_a2LR a_a2LS a_a2Mb) ->
      case ds_d4Jb of {
        FLeft _ [Occ=Dead] -> mempty @m_a2Ma $dMonoid_a2Mc;
        FRight a1_a2aj ->
          foldMap
            @f_a2LR
            $dFoldable_a2LT
            @m_a2Ma
            @a_a2Mb
            $dMonoid_a2Mc
            f_a2ag
            a1_a2aj
      }

Rec {
-- RHS size: {terms: 38, types: 43, coercions: 0, joins: 0/0}
Main.$fFoldableSum [InlPrag=CONLIKE]
  :: forall (f :: * -> *) a. Foldable f => Foldable (Sum f a)
[LclIdX[DFunId],
 Unf=DFun: \ (@(f_a1uG :: * -> *))
             (@a_a1uH)
             (v_B1 :: Foldable f_a1uG) ->
       Data.Foldable.C:Foldable TYPE: Sum f_a1uG a_a1uH
                                $cfold_a2LV @f_a1uG @a_a1uH v_B1
                                $cfoldMap_a2M7 @f_a1uG @a_a1uH v_B1
                                $cfoldMap'_a2Mp @f_a1uG @a_a1uH v_B1
                                $cfoldr_a2MD @f_a1uG @a_a1uH v_B1
                                $cfoldr'_a2N1 @f_a1uG @a_a1uH v_B1
                                $cfoldl_a2Nd @f_a1uG @a_a1uH v_B1
                                $cfoldl'_a2Np @f_a1uG @a_a1uH v_B1
                                $cfoldr1_a2NB @f_a1uG @a_a1uH v_B1
                                $cfoldl1_a2NL @f_a1uG @a_a1uH v_B1
                                $ctoList_a2NV @f_a1uG @a_a1uH v_B1
                                $cnull_a2O5 @f_a1uG @a_a1uH v_B1
                                $clength_a2Oh @f_a1uG @a_a1uH v_B1
                                $celem_a2Or @f_a1uG @a_a1uH v_B1
                                $cmaximum_a2OD @f_a1uG @a_a1uH v_B1
                                $cminimum_a2OP @f_a1uG @a_a1uH v_B1
                                $csum_a2P1 @f_a1uG @a_a1uH v_B1
                                $cproduct_a2Pd @f_a1uG @a_a1uH v_B1]
Main.$fFoldableSum
  = \ (@(f_a2LR :: * -> *))
      (@a_a2LS)
      ($dFoldable_a2LT :: Foldable f_a2LR) ->
      Data.Foldable.C:Foldable
        @(Sum f_a2LR a_a2LS)
        ($cfold_a2LV @f_a2LR @a_a2LS $dFoldable_a2LT)
        ($cfoldMap_a2M7 @f_a2LR @a_a2LS $dFoldable_a2LT)
        ($cfoldMap'_a2Mp @f_a2LR @a_a2LS $dFoldable_a2LT)
        ($cfoldr_a2MD @f_a2LR @a_a2LS $dFoldable_a2LT)
        ($cfoldr'_a2N1 @f_a2LR @a_a2LS $dFoldable_a2LT)
        ($cfoldl_a2Nd @f_a2LR @a_a2LS $dFoldable_a2LT)
        ($cfoldl'_a2Np @f_a2LR @a_a2LS $dFoldable_a2LT)
        ($cfoldr1_a2NB @f_a2LR @a_a2LS $dFoldable_a2LT)
        ($cfoldl1_a2NL @f_a2LR @a_a2LS $dFoldable_a2LT)
        ($ctoList_a2NV @f_a2LR @a_a2LS $dFoldable_a2LT)
        ($cnull_a2O5 @f_a2LR @a_a2LS $dFoldable_a2LT)
        ($clength_a2Oh @f_a2LR @a_a2LS $dFoldable_a2LT)
        ($celem_a2Or @f_a2LR @a_a2LS $dFoldable_a2LT)
        ($cmaximum_a2OD @f_a2LR @a_a2LS $dFoldable_a2LT)
        ($cminimum_a2OP @f_a2LR @a_a2LS $dFoldable_a2LT)
        ($csum_a2P1 @f_a2LR @a_a2LS $dFoldable_a2LT)
        ($cproduct_a2Pd @f_a2LR @a_a2LS $dFoldable_a2LT)

-- RHS size: {terms: 18, types: 28, coercions: 25, joins: 0/0}
$csum_a2P1 [Occ=LoopBreaker]
  :: forall (f :: * -> *) a a. (Foldable f, Num a) => Sum f a a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 140 60}]
$csum_a2P1
  = \ (@(f_a2LR :: * -> *))
      (@a_a2LS)
      ($dFoldable_a2LT :: Foldable f_a2LR)
      (@a_a2P4)
      ($dNum_a2P5 :: Num a_a2P4) ->
      ((\ (@(t_a4WR :: * -> *))
          ($dFoldable_a4WS :: Foldable t_a4WR)
          (@a_a4WT)
          ($dNum_a4WU :: Num a_a4WT) ->
          Data.Foldable.foldMap'
            @t_a4WR
            $dFoldable_a4WS
            @(base:Data.Semigroup.Internal.Sum a_a4WT)
            @a_a4WT
            (base:Data.Semigroup.Internal.$fMonoidSum @a_a4WT $dNum_a4WU)
            ((\ (ds_a52f :: a_a4WT) -> ds_a52f)
             `cast` (<a_a4WT>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Sum[0]
                                              <a_a4WT>_R)
                     :: (a_a4WT -> a_a4WT)
                        ~R# (a_a4WT -> base:Data.Semigroup.Internal.Sum a_a4WT))))
       `cast` (forall (t :: <* -> *>_N).
               <Foldable t>_R
               %<'Many>_N ->_R forall (a :: <*>_N).
                               <Num a>_R
                               %<'Many>_N ->_R <t a>_R
                               %<'Many>_N ->_R base:Data.Semigroup.Internal.N:Sum[0] <a>_R
               :: (forall {t :: * -> *} {a}.
                   (Foldable t, Num a) =>
                   t a -> base:Data.Semigroup.Internal.Sum a)
                  ~R# (forall {t :: * -> *} {a}. (Foldable t, Num a) => t a -> a)))
        @(Sum f_a2LR a_a2LS)
        (Main.$fFoldableSum @f_a2LR @a_a2LS $dFoldable_a2LT)
        @a_a2P4
        $dNum_a2P5

-- RHS size: {terms: 28, types: 41, coercions: 8, joins: 0/2}
$cminimum_a2OP [Occ=LoopBreaker]
  :: forall (f :: * -> *) a a. (Foldable f, Ord a) => Sum f a a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 280 60}]
$cminimum_a2OP
  = \ (@(f_a2LR :: * -> *))
      (@a_a2LS)
      ($dFoldable_a2LT :: Foldable f_a2LR)
      (@a_a2OS)
      ($dOrd_a2OT :: Ord a_a2OS) ->
      let {
        d_a52o :: a_a2OS
        [LclId,
         Str=b,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 110 0}]
        d_a52o
          = errorWithoutStackTrace
              @GHC.Types.LiftedRep
              @a_a2OS
              (GHC.Base.build
                 @Char
                 (\ (@b_a52t) ->
                    GHC.CString.unpackFoldrCString#
                      @b_a52t "minimum: empty structure"#)) } in
      let {
        g_a52v
          :: Sum f_a2LR a_a2LS a_a2OS -> base:Data.Functor.Utils.Min a_a2OS
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 100 0}]
        g_a52v
          = Data.Foldable.foldMap'
              @(Sum f_a2LR a_a2LS)
              (Main.$fFoldableSum @f_a2LR @a_a2LS $dFoldable_a2LT)
              @(base:Data.Functor.Utils.Min a_a2OS)
              @a_a2OS
              (base:Data.Functor.Utils.$fMonoidMin @a_a2OS $dOrd_a2OT)
              ((\ (ds_a53M :: a_a2OS) -> GHC.Maybe.Just @a_a2OS ds_a53M)
               `cast` (<a_a2OS>_R
                       %<'Many>_N ->_R Sym (base:Data.Functor.Utils.N:Min[0]) <a_a2OS>_N
                       :: (a_a2OS -> GHC.Maybe.Maybe a_a2OS)
                          ~R# (a_a2OS -> base:Data.Functor.Utils.Min a_a2OS))) } in
      \ (x_a53N :: Sum f_a2LR a_a2LS a_a2OS) ->
        case (g_a52v x_a53N)
             `cast` (base:Data.Functor.Utils.N:Min[0] <a_a2OS>_N
                     :: base:Data.Functor.Utils.Min a_a2OS ~R# GHC.Maybe.Maybe a_a2OS)
        of {
          GHC.Maybe.Nothing -> d_a52o;
          GHC.Maybe.Just v_a54h -> v_a54h
        }

-- RHS size: {terms: 28, types: 41, coercions: 8, joins: 0/2}
$cmaximum_a2OD [Occ=LoopBreaker]
  :: forall (f :: * -> *) a a. (Foldable f, Ord a) => Sum f a a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 280 60}]
$cmaximum_a2OD
  = \ (@(f_a2LR :: * -> *))
      (@a_a2LS)
      ($dFoldable_a2LT :: Foldable f_a2LR)
      (@a_a2OG)
      ($dOrd_a2OH :: Ord a_a2OG) ->
      let {
        d_a54n :: a_a2OG
        [LclId,
         Str=b,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 110 0}]
        d_a54n
          = errorWithoutStackTrace
              @GHC.Types.LiftedRep
              @a_a2OG
              (GHC.Base.build
                 @Char
                 (\ (@b_a54o) ->
                    GHC.CString.unpackFoldrCString#
                      @b_a54o "maximum: empty structure"#)) } in
      let {
        g_a54p
          :: Sum f_a2LR a_a2LS a_a2OG -> base:Data.Functor.Utils.Max a_a2OG
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 100 0}]
        g_a54p
          = Data.Foldable.foldMap'
              @(Sum f_a2LR a_a2LS)
              (Main.$fFoldableSum @f_a2LR @a_a2LS $dFoldable_a2LT)
              @(base:Data.Functor.Utils.Max a_a2OG)
              @a_a2OG
              (base:Data.Functor.Utils.$fMonoidMax @a_a2OG $dOrd_a2OH)
              ((\ (ds_a54r :: a_a2OG) -> GHC.Maybe.Just @a_a2OG ds_a54r)
               `cast` (<a_a2OG>_R
                       %<'Many>_N ->_R Sym (base:Data.Functor.Utils.N:Max[0]) <a_a2OG>_N
                       :: (a_a2OG -> GHC.Maybe.Maybe a_a2OG)
                          ~R# (a_a2OG -> base:Data.Functor.Utils.Max a_a2OG))) } in
      \ (x_a54s :: Sum f_a2LR a_a2LS a_a2OG) ->
        case (g_a54p x_a54s)
             `cast` (base:Data.Functor.Utils.N:Max[0] <a_a2OG>_N
                     :: base:Data.Functor.Utils.Max a_a2OG ~R# GHC.Maybe.Maybe a_a2OG)
        of {
          GHC.Maybe.Nothing -> d_a54n;
          GHC.Maybe.Just v_a54x -> v_a54x
        }

-- RHS size: {terms: 19, types: 27, coercions: 26, joins: 0/0}
$celem_a2Or [Occ=LoopBreaker]
  :: forall (f :: * -> *) a a.
     (Foldable f, Eq a) =>
     a -> Sum f a a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 150 60}]
$celem_a2Or
  = \ (@(f_a2LR :: * -> *))
      (@a_a2LS)
      ($dFoldable_a2LT :: Foldable f_a2LR)
      (@a_a2Ou)
      ($dEq_a2Ov :: Eq a_a2Ou) ->
      ((\ (@(t_a54z :: * -> *))
          ($dFoldable_a54A :: Foldable t_a54z)
          (@a_a54B)
          ($dEq_a54C :: Eq a_a54B)
          (eta_a54D :: a_a54B) ->
          foldMap
            @t_a54z
            $dFoldable_a54A
            @base:Data.Semigroup.Internal.Any
            @a_a54B
            base:Data.Semigroup.Internal.$fMonoidAny
            ((== @a_a54B $dEq_a54C eta_a54D)
             `cast` (<a_a54B>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Any[0])
                     :: (a_a54B -> Bool)
                        ~R# (a_a54B -> base:Data.Semigroup.Internal.Any))))
       `cast` (forall (t :: <* -> *>_N).
               <Foldable t>_R
               %<'Many>_N ->_R forall (a :: <*>_N).
                               <Eq a>_R
                               %<'Many>_N ->_R <a>_R
                               %<'Many>_N ->_R <t a>_R
                               %<'Many>_N ->_R base:Data.Semigroup.Internal.N:Any[0]
               :: (forall {t :: * -> *} {a}.
                   (Foldable t, Eq a) =>
                   a -> t a -> base:Data.Semigroup.Internal.Any)
                  ~R# (forall {t :: * -> *} {a}.
                       (Foldable t, Eq a) =>
                       a -> t a -> Bool)))
        @(Sum f_a2LR a_a2LS)
        (Main.$fFoldableSum @f_a2LR @a_a2LS $dFoldable_a2LT)
        @a_a2Ou
        $dEq_a2Ov

-- RHS size: {terms: 18, types: 18, coercions: 0, joins: 0/0}
$clength_a2Oh [Occ=LoopBreaker]
  :: forall (f :: * -> *) a a. Foldable f => Sum f a a -> Int
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 111 0}]
$clength_a2Oh
  = \ (@(f_a2LR :: * -> *))
      (@a_a2LS)
      ($dFoldable_a2LT :: Foldable f_a2LR)
      (@a_a2Ok) ->
      Data.Foldable.foldl'
        @(Sum f_a2LR a_a2LS)
        (Main.$fFoldableSum @f_a2LR @a_a2LS $dFoldable_a2LT)
        @Int
        @a_a2Ok
        (\ (c_a54K :: Int) _ [Occ=Dead] ->
           case c_a54K of { GHC.Types.I# x_a54N ->
           GHC.Types.I# (GHC.Prim.+# x_a54N 1#)
           })
        (GHC.Types.I# 0#)

-- RHS size: {terms: 17, types: 30, coercions: 0, joins: 0/1}
$ctoList_a2NV [Occ=LoopBreaker]
  :: forall (f :: * -> *) a a. Foldable f => Sum f a a -> [a]
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 110 60}]
$ctoList_a2NV
  = \ (@(f_a2LR :: * -> *))
      (@a_a2LS)
      ($dFoldable_a2LT :: Foldable f_a2LR)
      (@a_a2NY) ->
      let {
        $dFoldable_a54Q :: Foldable (Sum f_a2LR a_a2LS)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dFoldable_a54Q
          = Main.$fFoldableSum @f_a2LR @a_a2LS $dFoldable_a2LT } in
      \ (t1_a54S :: Sum f_a2LR a_a2LS a_a2NY) ->
        GHC.Base.build
          @a_a2NY
          (\ (@b_a54T)
             (c_a54U [OS=OneShot] :: a_a2NY -> b_a54T -> b_a54T)
             (n_a54V [OS=OneShot] :: b_a54T) ->
             foldr
               @(Sum f_a2LR a_a2LS)
               $dFoldable_a54Q
               @a_a2NY
               @b_a54T
               c_a54U
               n_a54V
               t1_a54S)

-- RHS size: {terms: 33, types: 44, coercions: 0, joins: 0/1}
$cfoldl1_a2NL [Occ=LoopBreaker]
  :: forall (f :: * -> *) a a.
     Foldable f =>
     (a -> a -> a) -> Sum f a a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 310 60}]
$cfoldl1_a2NL
  = \ (@(f_a2LR :: * -> *))
      (@a_a2LS)
      ($dFoldable_a2LT :: Foldable f_a2LR)
      (@a_a2NO) ->
      let {
        $dFoldable_a54X :: Foldable (Sum f_a2LR a_a2LS)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dFoldable_a54X
          = Main.$fFoldableSum @f_a2LR @a_a2LS $dFoldable_a2LT } in
      \ (f_a54Z :: a_a2NO -> a_a2NO -> a_a2NO)
        (xs_a550 :: Sum f_a2LR a_a2LS a_a2NO) ->
        case foldl
               @(Sum f_a2LR a_a2LS)
               $dFoldable_a54X
               @(GHC.Maybe.Maybe a_a2NO)
               @a_a2NO
               (\ (m_a551 :: GHC.Maybe.Maybe a_a2NO) (y_a552 :: a_a2NO) ->
                  GHC.Maybe.Just
                    @a_a2NO
                    (case m_a551 of {
                       GHC.Maybe.Nothing -> y_a552;
                       GHC.Maybe.Just x_a555 -> f_a54Z x_a555 y_a552
                     }))
               (GHC.Maybe.Nothing @a_a2NO)
               xs_a550
        of {
          GHC.Maybe.Nothing ->
            errorWithoutStackTrace
              @GHC.Types.LiftedRep
              @a_a2NO
              (GHC.Base.build
                 @Char
                 (\ (@b_a558) ->
                    GHC.CString.unpackFoldrCString#
                      @b_a558 "foldl1: empty structure"#));
          GHC.Maybe.Just v_a559 -> v_a559
        }

-- RHS size: {terms: 33, types: 44, coercions: 0, joins: 0/1}
$cfoldr1_a2NB [Occ=LoopBreaker]
  :: forall (f :: * -> *) a a.
     Foldable f =>
     (a -> a -> a) -> Sum f a a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 310 60}]
$cfoldr1_a2NB
  = \ (@(f_a2LR :: * -> *))
      (@a_a2LS)
      ($dFoldable_a2LT :: Foldable f_a2LR)
      (@a_a2NE) ->
      let {
        $dFoldable_a55d :: Foldable (Sum f_a2LR a_a2LS)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dFoldable_a55d
          = Main.$fFoldableSum @f_a2LR @a_a2LS $dFoldable_a2LT } in
      \ (f_a55f :: a_a2NE -> a_a2NE -> a_a2NE)
        (xs_a55g :: Sum f_a2LR a_a2LS a_a2NE) ->
        case foldr
               @(Sum f_a2LR a_a2LS)
               $dFoldable_a55d
               @a_a2NE
               @(GHC.Maybe.Maybe a_a2NE)
               (\ (x_a55h :: a_a2NE) (m_a55i :: GHC.Maybe.Maybe a_a2NE) ->
                  GHC.Maybe.Just
                    @a_a2NE
                    (case m_a55i of {
                       GHC.Maybe.Nothing -> x_a55h;
                       GHC.Maybe.Just y_a55l -> f_a55f x_a55h y_a55l
                     }))
               (GHC.Maybe.Nothing @a_a2NE)
               xs_a55g
        of {
          GHC.Maybe.Nothing ->
            errorWithoutStackTrace
              @GHC.Types.LiftedRep
              @a_a2NE
              (GHC.Base.build
                 @Char
                 (\ (@b_a55o) ->
                    GHC.CString.unpackFoldrCString#
                      @b_a55o "foldr1: empty structure"#));
          GHC.Maybe.Just v_a55p -> v_a55p
        }

-- RHS size: {terms: 26, types: 36, coercions: 0, joins: 0/1}
$cfoldl'_a2Np [Occ=LoopBreaker]
  :: forall (f :: * -> *) a b a.
     Foldable f =>
     (b -> a -> b) -> b -> Sum f a a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 210 60}]
$cfoldl'_a2Np
  = \ (@(f_a2LR :: * -> *))
      (@a_a2LS)
      ($dFoldable_a2LT :: Foldable f_a2LR)
      (@b_a2Ns)
      (@a_a2Nt) ->
      let {
        $dFoldable_a55t :: Foldable (Sum f_a2LR a_a2LS)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dFoldable_a55t
          = Main.$fFoldableSum @f_a2LR @a_a2LS $dFoldable_a2LT } in
      \ (f_a55w :: b_a2Ns -> a_a2Nt -> b_a2Ns)
        (z0_a55x :: b_a2Ns)
        (xs_a55y :: Sum f_a2LR a_a2LS a_a2Nt) ->
        foldr
          @(Sum f_a2LR a_a2LS)
          $dFoldable_a55t
          @a_a2Nt
          @(b_a2Ns -> b_a2Ns)
          (\ (ds_a55z :: a_a2Nt)
             (ds1_a55A :: b_a2Ns -> b_a2Ns)
             (v_a55B [OS=OneShot] :: b_a2Ns) ->
             case v_a55B of z_a55C { __DEFAULT ->
             ds1_a55A (f_a55w z_a55C ds_a55z)
             })
          (id @b_a2Ns)
          xs_a55y
          z0_a55x

-- RHS size: {terms: 22, types: 36, coercions: 10, joins: 0/1}
$cfoldl_a2Nd [Occ=LoopBreaker]
  :: forall (f :: * -> *) a b a.
     Foldable f =>
     (b -> a -> b) -> b -> Sum f a a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 190 60}]
$cfoldl_a2Nd
  = \ (@(f_a2LR :: * -> *))
      (@a_a2LS)
      ($dFoldable_a2LT :: Foldable f_a2LR)
      (@b_a2Ng)
      (@a_a2Nh) ->
      let {
        $dFoldable_a55F :: Foldable (Sum f_a2LR a_a2LS)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dFoldable_a55F
          = Main.$fFoldableSum @f_a2LR @a_a2LS $dFoldable_a2LT } in
      \ (eta_a55I :: b_a2Ng -> a_a2Nh -> b_a2Ng)
        (eta1_a55J :: b_a2Ng)
        (eta2_a55K :: Sum f_a2LR a_a2LS a_a2Nh) ->
        ((foldMap
            @(Sum f_a2LR a_a2LS)
            $dFoldable_a55F
            @(base:Data.Semigroup.Internal.Dual
                (base:Data.Semigroup.Internal.Endo b_a2Ng))
            @a_a2Nh
            (base:Data.Semigroup.Internal.$fMonoidDual
               @(base:Data.Semigroup.Internal.Endo b_a2Ng)
               (base:Data.Semigroup.Internal.$fMonoidEndo @b_a2Ng))
            ((\ (x_a55N :: a_a2Nh) (y_a55O :: b_a2Ng) ->
                eta_a55I y_a55O x_a55N)
             `cast` (<a_a2Nh>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Dual[0]
                                              (base:Data.Semigroup.Internal.N:Endo[0] <b_a2Ng>_R))
                     :: (a_a2Nh -> b_a2Ng -> b_a2Ng)
                        ~R# (a_a2Nh
                             -> base:Data.Semigroup.Internal.Dual
                                  (base:Data.Semigroup.Internal.Endo b_a2Ng))))
            eta2_a55K)
         `cast` (base:Data.Semigroup.Internal.N:Dual[0]
                     (base:Data.Semigroup.Internal.N:Endo[0] <b_a2Ng>_R)
                 :: base:Data.Semigroup.Internal.Dual
                      (base:Data.Semigroup.Internal.Endo b_a2Ng)
                    ~R# (b_a2Ng -> b_a2Ng)))
          eta1_a55J

-- RHS size: {terms: 26, types: 36, coercions: 0, joins: 0/1}
$cfoldr'_a2N1 [Occ=LoopBreaker]
  :: forall (f :: * -> *) a a b.
     Foldable f =>
     (a -> b -> b) -> b -> Sum f a a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 210 60}]
$cfoldr'_a2N1
  = \ (@(f_a2LR :: * -> *))
      (@a_a2LS)
      ($dFoldable_a2LT :: Foldable f_a2LR)
      (@a_a2N4)
      (@b_a2N5) ->
      let {
        $dFoldable_a55U :: Foldable (Sum f_a2LR a_a2LS)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dFoldable_a55U
          = Main.$fFoldableSum @f_a2LR @a_a2LS $dFoldable_a2LT } in
      \ (f_a55X :: a_a2N4 -> b_a2N5 -> b_a2N5)
        (z0_a55Y :: b_a2N5)
        (xs_a55Z :: Sum f_a2LR a_a2LS a_a2N4) ->
        foldl
          @(Sum f_a2LR a_a2LS)
          $dFoldable_a55U
          @(b_a2N5 -> b_a2N5)
          @a_a2N4
          (\ (ds_a560 :: b_a2N5 -> b_a2N5)
             (ds1_a561 :: a_a2N4)
             (v_a562 [OS=OneShot] :: b_a2N5) ->
             case v_a562 of z_a563 { __DEFAULT ->
             ds_a560 (f_a55X ds1_a561 z_a563)
             })
          (id @b_a2N5)
          xs_a55Z
          z0_a55Y

-- RHS size: {terms: 24, types: 31, coercions: 0, joins: 0/2}
$cfoldMap'_a2Mp [Occ=LoopBreaker]
  :: forall (f :: * -> *) a m a.
     (Foldable f, Monoid m) =>
     (a -> m) -> Sum f a a -> m
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 60] 210 60}]
$cfoldMap'_a2Mp
  = \ (@(f_a2LR :: * -> *))
      (@a_a2LS)
      ($dFoldable_a2LT :: Foldable f_a2LR)
      (@m_a2Ms)
      (@a_a2Mt)
      ($dMonoid_a2Mu :: Monoid m_a2Ms) ->
      let {
        $dFoldable_a565 :: Foldable (Sum f_a2LR a_a2LS)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dFoldable_a565
          = Main.$fFoldableSum @f_a2LR @a_a2LS $dFoldable_a2LT } in
      \ (eta_a569 :: a_a2Mt -> m_a2Ms) ->
        let {
          $dSemigroup_a56a :: Semigroup m_a2Ms
          [LclId,
           Unf=Unf{Src=<vanilla>, TopLvl=False,
                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                   Guidance=IF_ARGS [] 20 0}]
          $dSemigroup_a56a = GHC.Base.$p1Monoid @m_a2Ms $dMonoid_a2Mu } in
        Data.Foldable.foldl'
          @(Sum f_a2LR a_a2LS)
          $dFoldable_a565
          @m_a2Ms
          @a_a2Mt
          (\ (acc_a56b :: m_a2Ms) (a1_a56c :: a_a2Mt) ->
             <> @m_a2Ms $dSemigroup_a56a acc_a56b (eta_a569 a1_a56c))
          (mempty @m_a2Ms $dMonoid_a2Mu)

-- RHS size: {terms: 18, types: 28, coercions: 25, joins: 0/0}
$cproduct_a2Pd [Occ=LoopBreaker]
  :: forall (f :: * -> *) a a. (Foldable f, Num a) => Sum f a a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 140 60}]
$cproduct_a2Pd
  = \ (@(f_a2LR :: * -> *))
      (@a_a2LS)
      ($dFoldable_a2LT :: Foldable f_a2LR)
      (@a_a2Pg)
      ($dNum_a2Ph :: Num a_a2Pg) ->
      ((\ (@(t_a56d :: * -> *))
          ($dFoldable_a56e :: Foldable t_a56d)
          (@a_a56f)
          ($dNum_a56g :: Num a_a56f) ->
          Data.Foldable.foldMap'
            @t_a56d
            $dFoldable_a56e
            @(base:Data.Semigroup.Internal.Product a_a56f)
            @a_a56f
            (base:Data.Semigroup.Internal.$fMonoidProduct @a_a56f $dNum_a56g)
            ((\ (ds_a56i :: a_a56f) -> ds_a56i)
             `cast` (<a_a56f>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Product[0]
                                              <a_a56f>_R)
                     :: (a_a56f -> a_a56f)
                        ~R# (a_a56f -> base:Data.Semigroup.Internal.Product a_a56f))))
       `cast` (forall (t :: <* -> *>_N).
               <Foldable t>_R
               %<'Many>_N ->_R forall (a :: <*>_N).
                               <Num a>_R
                               %<'Many>_N ->_R <t a>_R
                               %<'Many>_N ->_R base:Data.Semigroup.Internal.N:Product[0] <a>_R
               :: (forall {t :: * -> *} {a}.
                   (Foldable t, Num a) =>
                   t a -> base:Data.Semigroup.Internal.Product a)
                  ~R# (forall {t :: * -> *} {a}. (Foldable t, Num a) => t a -> a)))
        @(Sum f_a2LR a_a2LS)
        (Main.$fFoldableSum @f_a2LR @a_a2LS $dFoldable_a2LT)
        @a_a2Pg
        $dNum_a2Ph

-- RHS size: {terms: 10, types: 17, coercions: 0, joins: 0/0}
$cfold_a2LV [Occ=LoopBreaker]
  :: forall (f :: * -> *) a m.
     (Foldable f, Monoid m) =>
     Sum f a m -> m
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 60 0}]
$cfold_a2LV
  = \ (@(f_a2LR :: * -> *))
      (@a_a2LS)
      ($dFoldable_a2LT :: Foldable f_a2LR)
      (@m_a2LY)
      ($dMonoid_a2LZ :: Monoid m_a2LY) ->
      foldMap
        @(Sum f_a2LR a_a2LS)
        (Main.$fFoldableSum @f_a2LR @a_a2LS $dFoldable_a2LT)
        @m_a2LY
        @m_a2LY
        $dMonoid_a2LZ
        (id @m_a2LY)
end Rec }

-- RHS size: {terms: 6, types: 8, coercions: 0, joins: 0/0}
$cp2Traversable_a487
  :: forall {f :: * -> *} {fixed}.
     Traversable f =>
     Foldable (Sum f fixed)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30] 40 0}]
$cp2Traversable_a487
  = \ (@(f_a47X :: * -> *))
      (@fixed_a47Y)
      ($dTraversable_a47Z :: Traversable f_a47X) ->
      Main.$fFoldableSum
        @f_a47X
        @fixed_a47Y
        (Data.Traversable.$p2Traversable @f_a47X $dTraversable_a47Z)

-- RHS size: {terms: 18, types: 33, coercions: 0, joins: 0/0}
$c<$_a2Lr
  :: forall (f :: * -> *) a a b.
     Functor f =>
     a -> Sum f a b -> Sum f a a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 0 40] 80 20}]
$c<$_a2Lr
  = \ (@(f_a2KZ :: * -> *))
      (@a_a2L0)
      ($dFunctor_a2L1 :: Functor f_a2KZ)
      (@a_a2Lu)
      (@b_a2Lv)
      (z_a2a4 :: a_a2Lu)
      (ds_d4J2 :: Sum f_a2KZ a_a2L0 b_a2Lv) ->
      case ds_d4J2 of {
        FLeft a1_a2a5 -> Main.FLeft @(*) @f_a2KZ @a_a2L0 @a_a2Lu a1_a2a5;
        FRight a1_a2a7 ->
          Main.FRight
            @(*)
            @f_a2KZ
            @a_a2L0
            @a_a2Lu
            (<$ @f_a2KZ $dFunctor_a2L1 @a_a2Lu @b_a2Lv z_a2a4 a1_a2a7)
      }

-- RHS size: {terms: 18, types: 34, coercions: 0, joins: 0/0}
$cfmap_a2L3
  :: forall (f :: * -> *) a a b.
     Functor f =>
     (a -> b) -> Sum f a a -> Sum f a b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 0 40] 80 20}]
$cfmap_a2L3
  = \ (@(f_a2KZ :: * -> *))
      (@a_a2L0)
      ($dFunctor_a2L1 :: Functor f_a2KZ)
      (@a_a2L6)
      (@b_a2L7)
      (f_a2a0 :: a_a2L6 -> b_a2L7)
      (ds_d4IX :: Sum f_a2KZ a_a2L0 a_a2L6) ->
      case ds_d4IX of {
        FLeft a1_a2a1 -> Main.FLeft @(*) @f_a2KZ @a_a2L0 @b_a2L7 a1_a2a1;
        FRight a1_a2a3 ->
          Main.FRight
            @(*)
            @f_a2KZ
            @a_a2L0
            @b_a2L7
            (fmap @f_a2KZ $dFunctor_a2L1 @a_a2L6 @b_a2L7 f_a2a0 a1_a2a3)
      }

-- RHS size: {terms: 8, types: 13, coercions: 0, joins: 0/0}
Main.$fFunctorSum [InlPrag=CONLIKE]
  :: forall (f :: * -> *) a. Functor f => Functor (Sum f a)
[LclIdX[DFunId],
 Unf=DFun: \ (@(f_a1uz :: * -> *))
             (@a_a1uA)
             (v_B1 :: Functor f_a1uz) ->
       GHC.Base.C:Functor TYPE: Sum f_a1uz a_a1uA
                          $cfmap_a2L3 @f_a1uz @a_a1uA v_B1
                          $c<$_a2Lr @f_a1uz @a_a1uA v_B1]
Main.$fFunctorSum
  = \ (@(f_a2KZ :: * -> *))
      (@a_a2L0)
      ($dFunctor_a2L1 :: Functor f_a2KZ) ->
      GHC.Base.C:Functor
        @(Sum f_a2KZ a_a2L0)
        ($cfmap_a2L3 @f_a2KZ @a_a2L0 $dFunctor_a2L1)
        ($c<$_a2Lr @f_a2KZ @a_a2L0 $dFunctor_a2L1)

-- RHS size: {terms: 6, types: 8, coercions: 0, joins: 0/0}
$cp1Traversable_a483
  :: forall {f :: * -> *} {fixed}.
     Traversable f =>
     Functor (Sum f fixed)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30] 40 0}]
$cp1Traversable_a483
  = \ (@(f_a47X :: * -> *))
      (@fixed_a47Y)
      ($dTraversable_a47Z :: Traversable f_a47X) ->
      Main.$fFunctorSum
        @f_a47X
        @fixed_a47Y
        (Data.Traversable.$p1Traversable @f_a47X $dTraversable_a47Z)

Rec {
-- RHS size: {terms: 16, types: 21, coercions: 0, joins: 0/0}
Main.$fTraversableSum [InlPrag=CONLIKE]
  :: forall (f :: * -> *) fixed.
     Traversable f =>
     Traversable (Sum f fixed)
[LclIdX[DFunId],
 Unf=DFun: \ (@(f_aUq :: * -> *))
             (@fixed_aUr)
             (v_B1 :: Traversable f_aUq) ->
       Data.Traversable.C:Traversable TYPE: Sum f_aUq fixed_aUr
                                      $cp1Traversable_a483 @f_aUq @fixed_aUr v_B1
                                      $cp2Traversable_a487 @f_aUq @fixed_aUr v_B1
                                      $ctraverse_a489 @f_aUq @fixed_aUr v_B1
                                      $csequenceA_a48p @f_aUq @fixed_aUr v_B1
                                      $cmapM_a48D @f_aUq @fixed_aUr v_B1
                                      $csequence_a48T @f_aUq @fixed_aUr v_B1]
Main.$fTraversableSum
  = \ (@(f_a47X :: * -> *))
      (@fixed_a47Y)
      ($dTraversable_a47Z :: Traversable f_a47X) ->
      Data.Traversable.C:Traversable
        @(Sum f_a47X fixed_a47Y)
        ($cp1Traversable_a483 @f_a47X @fixed_a47Y $dTraversable_a47Z)
        ($cp2Traversable_a487 @f_a47X @fixed_a47Y $dTraversable_a47Z)
        ($ctraverse_a489 @f_a47X @fixed_a47Y $dTraversable_a47Z)
        ($csequenceA_a48p @f_a47X @fixed_a47Y $dTraversable_a47Z)
        ($cmapM_a48D @f_a47X @fixed_a47Y $dTraversable_a47Z)
        ($csequence_a48T @f_a47X @fixed_a47Y $dTraversable_a47Z)

-- RHS size: {terms: 12, types: 21, coercions: 0, joins: 0/0}
$cmapM_a48D [Occ=LoopBreaker]
  :: forall (f :: * -> *) fixed (m :: * -> *) a b.
     (Traversable f, Monad m) =>
     (a -> m b) -> Sum f fixed a -> m (Sum f fixed b)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 30] 70 0}]
$cmapM_a48D
  = \ (@(f_a47X :: * -> *))
      (@fixed_a47Y)
      ($dTraversable_a47Z :: Traversable f_a47X)
      (@(m_a48G :: * -> *))
      (@a_a48H)
      (@b_a48I)
      ($dMonad_a48J :: Monad m_a48G) ->
      traverse
        @(Sum f_a47X fixed_a47Y)
        (Main.$fTraversableSum @f_a47X @fixed_a47Y $dTraversable_a47Z)
        @m_a48G
        @a_a48H
        @b_a48I
        (GHC.Base.$p1Monad @m_a48G $dMonad_a48J)

-- RHS size: {terms: 11, types: 22, coercions: 0, joins: 0/0}
$csequenceA_a48p [Occ=LoopBreaker]
  :: forall (f :: * -> *) fixed (f :: * -> *) a.
     (Traversable f, Applicative f) =>
     Sum f fixed (f a) -> f (Sum f fixed a)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 60 0}]
$csequenceA_a48p
  = \ (@(f_a47X :: * -> *))
      (@fixed_a47Y)
      ($dTraversable_a47Z :: Traversable f_a47X)
      (@(f_a48s :: * -> *))
      (@a_a48t)
      ($dApplicative_a48u :: Applicative f_a48s) ->
      traverse
        @(Sum f_a47X fixed_a47Y)
        (Main.$fTraversableSum @f_a47X @fixed_a47Y $dTraversable_a47Z)
        @f_a48s
        @(f_a48s a_a48t)
        @a_a48t
        $dApplicative_a48u
        (id @(f_a48s a_a48t))

-- RHS size: {terms: 11, types: 19, coercions: 0, joins: 0/0}
$csequence_a48T [Occ=LoopBreaker]
  :: forall (f :: * -> *) fixed (m :: * -> *) a.
     (Traversable f, Monad m) =>
     Sum f fixed (m a) -> m (Sum f fixed a)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 30] 70 0}]
$csequence_a48T
  = \ (@(f_a47X :: * -> *))
      (@fixed_a47Y)
      ($dTraversable_a47Z :: Traversable f_a47X)
      (@(m_a48W :: * -> *))
      (@a_a48X)
      ($dMonad_a48Y :: Monad m_a48W) ->
      sequenceA
        @(Sum f_a47X fixed_a47Y)
        (Main.$fTraversableSum @f_a47X @fixed_a47Y $dTraversable_a47Z)
        @m_a48W
        @a_a48X
        (GHC.Base.$p1Monad @m_a48W $dMonad_a48Y)

-- RHS size: {terms: 24, types: 66, coercions: 0, joins: 0/3}
$ctraverse_a489 [Occ=LoopBreaker]
  :: forall (f :: * -> *) fixed (f :: * -> *) a b.
     (Traversable f, Applicative f) =>
     (a -> f b) -> Sum f fixed a -> f (Sum f fixed b)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 190 60}]
$ctraverse_a489
  = \ (@(f_a47X :: * -> *))
      (@fixed_a47Y)
      ($dTraversable_a47Z :: Traversable f_a47X)
      (@(f_a48c :: * -> *))
      (@a_a48d)
      (@b_a48e)
      ($dApplicative_a48f :: Applicative f_a48c) ->
      let {
        $dTraversable_a56I :: Traversable (Sum f_a47X fixed_a47Y)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dTraversable_a56I
          = Main.$fTraversableSum @f_a47X @fixed_a47Y $dTraversable_a47Z } in
      \ (eta1_a56N :: a_a48d -> f_a48c b_a48e) ->
        let {
          f1_a56O
            :: Sum f_a47X fixed_a47Y (f_a48c b_a48e)
               -> f_a48c (Sum f_a47X fixed_a47Y b_a48e)
          [LclId,
           Unf=Unf{Src=<vanilla>, TopLvl=False,
                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                   Guidance=IF_ARGS [] 30 0}]
          f1_a56O
            = sequenceA
                @(Sum f_a47X fixed_a47Y)
                $dTraversable_a56I
                @f_a48c
                @b_a48e
                $dApplicative_a48f } in
        let {
          g_a56P
            :: Sum f_a47X fixed_a47Y a_a48d
               -> Sum f_a47X fixed_a47Y (f_a48c b_a48e)
          [LclId,
           Unf=Unf{Src=<vanilla>, TopLvl=False,
                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                   Guidance=IF_ARGS [] 50 0}]
          g_a56P
            = fmap
                @(Sum f_a47X fixed_a47Y)
                (Data.Traversable.$p1Traversable
                   @(Sum f_a47X fixed_a47Y) $dTraversable_a56I)
                @a_a48d
                @(f_a48c b_a48e)
                eta1_a56N } in
        \ (x_a56Q :: Sum f_a47X fixed_a47Y a_a48d) ->
          f1_a56O (g_a56P x_a56Q)
end Rec }

-- RHS size: {terms: 42, types: 38, coercions: 0, joins: 0/0}
$cshowsPrec_a2Ko
  :: forall k (f :: k -> *) (a :: k) (b :: k).
     (Show (f a), Show (f b)) =>
     Int -> Sum f a b -> ShowS
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 0 260] 480 0}]
$cshowsPrec_a2Ko
  = \ (@k_a2Kh)
      (@(f_a2Ki :: k_a2Kh -> *))
      (@(a_a2Kj :: k_a2Kh))
      (@(b_a2Kk :: k_a2Kh))
      ($dShow_a2Kl :: Show (f_a2Ki a_a2Kj))
      ($dShow_a2Km :: Show (f_a2Ki b_a2Kk))
      (a_a29W :: Int)
      (ds_d4IM :: Sum f_a2Ki a_a2Kj b_a2Kk) ->
      case ds_d4IM of {
        FLeft b1_a29X ->
          showParen
            (>= @Int GHC.Classes.$fOrdInt a_a29W (GHC.Types.I# 11#))
            (. @String
               @String
               @String
               (showString (GHC.CString.unpackCString# "FLeft "#))
               (showsPrec
                  @(f_a2Ki a_a2Kj) $dShow_a2Kl (GHC.Types.I# 11#) b1_a29X));
        FRight b1_a29Z ->
          showParen
            (>= @Int GHC.Classes.$fOrdInt a_a29W (GHC.Types.I# 11#))
            (. @String
               @String
               @String
               (showString (GHC.CString.unpackCString# "FRight "#))
               (showsPrec
                  @(f_a2Ki b_a2Kk) $dShow_a2Km (GHC.Types.I# 11#) b1_a29Z))
      }

Rec {
-- RHS size: {terms: 16, types: 28, coercions: 0, joins: 0/0}
Main.$fShowSum [InlPrag=CONLIKE]
  :: forall k (f :: k -> *) (a :: k) (b :: k).
     (Show (f a), Show (f b)) =>
     Show (Sum f a b)
[LclIdX[DFunId],
 Unf=DFun: \ (@k_a1uq)
             (@(f_a1ur :: k_a1uq -> *))
             (@(a_a1us :: k_a1uq))
             (@(b_a1ut :: k_a1uq))
             (v_B1 :: Show (f_a1ur a_a1us))
             (v_B2 :: Show (f_a1ur b_a1ut)) ->
       GHC.Show.C:Show TYPE: Sum f_a1ur a_a1us b_a1ut
                       $cshowsPrec_a2Ko @k_a1uq @f_a1ur @a_a1us @b_a1ut v_B1 v_B2
                       $cshow_a2KJ @k_a1uq @f_a1ur @a_a1us @b_a1ut v_B1 v_B2
                       $cshowList_a2KQ @k_a1uq @f_a1ur @a_a1us @b_a1ut v_B1 v_B2]
Main.$fShowSum
  = \ (@k_a2Kh)
      (@(f_a2Ki :: k_a2Kh -> *))
      (@(a_a2Kj :: k_a2Kh))
      (@(b_a2Kk :: k_a2Kh))
      ($dShow_a2Kl :: Show (f_a2Ki a_a2Kj))
      ($dShow_a2Km :: Show (f_a2Ki b_a2Kk)) ->
      GHC.Show.C:Show
        @(Sum f_a2Ki a_a2Kj b_a2Kk)
        ($cshowsPrec_a2Ko
           @k_a2Kh @f_a2Ki @a_a2Kj @b_a2Kk $dShow_a2Kl $dShow_a2Km)
        ($cshow_a2KJ
           @k_a2Kh @f_a2Ki @a_a2Kj @b_a2Kk $dShow_a2Kl $dShow_a2Km)
        ($cshowList_a2KQ
           @k_a2Kh @f_a2Ki @a_a2Kj @b_a2Kk $dShow_a2Kl $dShow_a2Km)

-- RHS size: {terms: 19, types: 38, coercions: 0, joins: 0/1}
$cshowList_a2KQ [Occ=LoopBreaker]
  :: forall k (f :: k -> *) (a :: k) (b :: k).
     (Show (f a), Show (f b)) =>
     [Sum f a b] -> ShowS
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 140 60}]
$cshowList_a2KQ
  = \ (@k_a2Kh)
      (@(f_a2Ki :: k_a2Kh -> *))
      (@(a_a2Kj :: k_a2Kh))
      (@(b_a2Kk :: k_a2Kh))
      ($dShow_a2Kl :: Show (f_a2Ki a_a2Kj))
      ($dShow_a2Km :: Show (f_a2Ki b_a2Kk)) ->
      let {
        $dShow_a56S :: Show (Sum f_a2Ki a_a2Kj b_a2Kk)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 30 0}]
        $dShow_a56S
          = Main.$fShowSum
              @k_a2Kh @f_a2Ki @a_a2Kj @b_a2Kk $dShow_a2Kl $dShow_a2Km } in
      \ (ls_a56T :: [Sum f_a2Ki a_a2Kj b_a2Kk]) (s_a56U :: String) ->
        GHC.Show.showList__
          @(Sum f_a2Ki a_a2Kj b_a2Kk)
          (showsPrec
             @(Sum f_a2Ki a_a2Kj b_a2Kk) $dShow_a56S (GHC.Types.I# 0#))
          ls_a56T
          s_a56U

-- RHS size: {terms: 17, types: 32, coercions: 0, joins: 0/1}
$cshow_a2KJ [Occ=LoopBreaker]
  :: forall k (f :: k -> *) (a :: k) (b :: k).
     (Show (f a), Show (f b)) =>
     Sum f a b -> String
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 110 60}]
$cshow_a2KJ
  = \ (@k_a2Kh)
      (@(f_a2Ki :: k_a2Kh -> *))
      (@(a_a2Kj :: k_a2Kh))
      (@(b_a2Kk :: k_a2Kh))
      ($dShow_a2Kl :: Show (f_a2Ki a_a2Kj))
      ($dShow_a2Km :: Show (f_a2Ki b_a2Kk)) ->
      let {
        $dShow_a56X :: Show (Sum f_a2Ki a_a2Kj b_a2Kk)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 30 0}]
        $dShow_a56X
          = Main.$fShowSum
              @k_a2Kh @f_a2Ki @a_a2Kj @b_a2Kk $dShow_a2Kl $dShow_a2Km } in
      \ (x_a56Y :: Sum f_a2Ki a_a2Kj b_a2Kk) ->
        showsPrec
          @(Sum f_a2Ki a_a2Kj b_a2Kk)
          $dShow_a56X
          (GHC.Types.I# 0#)
          x_a56Y
          (GHC.Types.[] @Char)
end Rec }

-- RHS size: {terms: 52, types: 68, coercions: 0, joins: 0/0}
$c==_a2JH
  :: forall k (f :: k -> *) (a :: k) (b :: k).
     (Eq (f a), Eq (f b)) =>
     Sum f a b -> Sum f a b -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 180 140] 353 10}]
$c==_a2JH
  = \ (@k_a2JA)
      (@(f_a2JB :: k_a2JA -> *))
      (@(a_a2JC :: k_a2JA))
      (@(b_a2JD :: k_a2JA))
      ($dEq_a2JE :: Eq (f_a2JB a_a2JC))
      ($dEq_a2JF :: Eq (f_a2JB b_a2JD))
      (a_a29O :: Sum f_a2JB a_a2JC b_a2JD)
      (b_a29P :: Sum f_a2JB a_a2JC b_a2JD) ->
      case case GHC.Prim.dataToTag# @(Sum f_a2JB a_a2JC b_a2JD) a_a29O
           of a#_a29Q
           { __DEFAULT ->
           case GHC.Prim.dataToTag# @(Sum f_a2JB a_a2JC b_a2JD) b_a29P
           of b#_a29R
           { __DEFAULT ->
           GHC.Prim./=# a#_a29Q b#_a29R
           }
           }
      of ds_d4Ir
      { __DEFAULT ->
      case ds_d4Ir of {
        __DEFAULT ->
          case a_a29O of {
            FLeft a1_a29S ->
              case b_a29P of {
                __DEFAULT ->
                  case Control.Exception.Base.patError
                         @GHC.Types.LiftedRep @() "Gy08.hs:43:55-56|case"#
                  of {
                  };
                FLeft b1_a29T -> == @(f_a2JB a_a2JC) $dEq_a2JE a1_a29S b1_a29T
              };
            FRight a1_a29U ->
              case b_a29P of {
                __DEFAULT ->
                  case Control.Exception.Base.patError
                         @GHC.Types.LiftedRep @() "Gy08.hs:43:55-56|case"#
                  of {
                  };
                FRight b1_a29V -> == @(f_a2JB b_a2JD) $dEq_a2JF a1_a29U b1_a29V
              }
          };
        1# -> GHC.Types.False
      }
      }

Rec {
-- RHS size: {terms: 13, types: 24, coercions: 0, joins: 0/0}
Main.$fEqSum [InlPrag=CONLIKE]
  :: forall k (f :: k -> *) (a :: k) (b :: k).
     (Eq (f a), Eq (f b)) =>
     Eq (Sum f a b)
[LclIdX[DFunId],
 Unf=DFun: \ (@k_a1uh)
             (@(f_a1ui :: k_a1uh -> *))
             (@(a_a1uj :: k_a1uh))
             (@(b_a1uk :: k_a1uh))
             (v_B1 :: Eq (f_a1ui a_a1uj))
             (v_B2 :: Eq (f_a1ui b_a1uk)) ->
       GHC.Classes.C:Eq TYPE: Sum f_a1ui a_a1uj b_a1uk
                        $c==_a2JH @k_a1uh @f_a1ui @a_a1uj @b_a1uk v_B1 v_B2
                        $c/=_a2K8 @k_a1uh @f_a1ui @a_a1uj @b_a1uk v_B1 v_B2]
Main.$fEqSum
  = \ (@k_a2JA)
      (@(f_a2JB :: k_a2JA -> *))
      (@(a_a2JC :: k_a2JA))
      (@(b_a2JD :: k_a2JA))
      ($dEq_a2JE :: Eq (f_a2JB a_a2JC))
      ($dEq_a2JF :: Eq (f_a2JB b_a2JD)) ->
      GHC.Classes.C:Eq
        @(Sum f_a2JB a_a2JC b_a2JD)
        ($c==_a2JH @k_a2JA @f_a2JB @a_a2JC @b_a2JD $dEq_a2JE $dEq_a2JF)
        ($c/=_a2K8 @k_a2JA @f_a2JB @a_a2JC @b_a2JD $dEq_a2JE $dEq_a2JF)

-- RHS size: {terms: 21, types: 37, coercions: 0, joins: 0/1}
$c/=_a2K8 [Occ=LoopBreaker]
  :: forall k (f :: k -> *) (a :: k) (b :: k).
     (Eq (f a), Eq (f b)) =>
     Sum f a b -> Sum f a b -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 120 60}]
$c/=_a2K8
  = \ (@k_a2JA)
      (@(f_a2JB :: k_a2JA -> *))
      (@(a_a2JC :: k_a2JA))
      (@(b_a2JD :: k_a2JA))
      ($dEq_a2JE :: Eq (f_a2JB a_a2JC))
      ($dEq_a2JF :: Eq (f_a2JB b_a2JD)) ->
      let {
        $dEq_a570 :: Eq (Sum f_a2JB a_a2JC b_a2JD)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 30 0}]
        $dEq_a570
          = Main.$fEqSum
              @k_a2JA @f_a2JB @a_a2JC @b_a2JD $dEq_a2JE $dEq_a2JF } in
      \ (x_a571 :: Sum f_a2JB a_a2JC b_a2JD)
        (y_a572 :: Sum f_a2JB a_a2JC b_a2JD) ->
        case == @(Sum f_a2JB a_a2JC b_a2JD) $dEq_a570 x_a571 y_a572 of {
          False -> GHC.Types.True;
          True -> GHC.Types.False
        }
end Rec }

-- RHS size: {terms: 11, types: 22, coercions: 0, joins: 0/0}
$cnull_a2If
  :: forall (f :: * -> *) a a. Foldable f => Prod f a a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 20] 40 0}]
$cnull_a2If
  = \ (@(f_a2G5 :: * -> *))
      (@a_a2G6)
      ($dFoldable_a2G7 :: Foldable f_a2G5)
      (@a_a2Ii)
      (ds_d4I8 :: Prod f_a2G5 a_a2G6 a_a2Ii) ->
      case ds_d4I8 of { FProd _ [Occ=Dead] a2_a29N ->
      null @f_a2G5 $dFoldable_a2G7 @a_a2Ii a2_a29N
      }

-- RHS size: {terms: 16, types: 28, coercions: 0, joins: 0/0}
$cfoldr_a2GO
  :: forall (f :: * -> *) a a b.
     Foldable f =>
     (a -> b -> b) -> b -> Prod f a a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 0 0 20] 60 0}]
$cfoldr_a2GO
  = \ (@(f_a2G5 :: * -> *))
      (@a_a2G6)
      ($dFoldable_a2G7 :: Foldable f_a2G5)
      (@a_a2GR)
      (@b_a2GS)
      (f_a29D :: a_a2GR -> b_a2GS -> b_a2GS)
      (z_a29E :: b_a2GS)
      (ds_d4HT :: Prod f_a2G5 a_a2G6 a_a2GR) ->
      case ds_d4HT of { FProd _ [Occ=Dead] a2_a29G ->
      foldr @f_a2G5 $dFoldable_a2G7 @a_a2GR @b_a2GS f_a29D z_a29E a2_a29G
      }

-- RHS size: {terms: 16, types: 28, coercions: 0, joins: 0/0}
$cfoldMap_a2Gl
  :: forall (f :: * -> *) a m a.
     (Foldable f, Monoid m) =>
     (a -> m) -> Prod f a a -> m
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 0 0 20] 60 0}]
$cfoldMap_a2Gl
  = \ (@(f_a2G5 :: * -> *))
      (@a_a2G6)
      ($dFoldable_a2G7 :: Foldable f_a2G5)
      (@m_a2Go)
      (@a_a2Gp)
      ($dMonoid_a2Gq :: Monoid m_a2Go)
      (f_a29J :: a_a2Gp -> m_a2Go)
      (ds_d4HO :: Prod f_a2G5 a_a2G6 a_a2Gp) ->
      case ds_d4HO of { FProd _ [Occ=Dead] a2_a29L ->
      foldMap
        @f_a2G5
        $dFoldable_a2G7
        @m_a2Go
        @a_a2Gp
        $dMonoid_a2Gq
        f_a29J
        a2_a29L
      }

Rec {
-- RHS size: {terms: 38, types: 43, coercions: 0, joins: 0/0}
Main.$fFoldableProd [InlPrag=CONLIKE]
  :: forall (f :: * -> *) a. Foldable f => Foldable (Prod f a)
[LclIdX[DFunId],
 Unf=DFun: \ (@(f_a1ua :: * -> *))
             (@a_a1ub)
             (v_B1 :: Foldable f_a1ua) ->
       Data.Foldable.C:Foldable TYPE: Prod f_a1ua a_a1ub
                                $cfold_a2G9 @f_a1ua @a_a1ub v_B1
                                $cfoldMap_a2Gl @f_a1ua @a_a1ub v_B1
                                $cfoldMap'_a2GA @f_a1ua @a_a1ub v_B1
                                $cfoldr_a2GO @f_a1ua @a_a1ub v_B1
                                $cfoldr'_a2Hb @f_a1ua @a_a1ub v_B1
                                $cfoldl_a2Hn @f_a1ua @a_a1ub v_B1
                                $cfoldl'_a2Hz @f_a1ua @a_a1ub v_B1
                                $cfoldr1_a2HL @f_a1ua @a_a1ub v_B1
                                $cfoldl1_a2HV @f_a1ua @a_a1ub v_B1
                                $ctoList_a2I5 @f_a1ua @a_a1ub v_B1
                                $cnull_a2If @f_a1ua @a_a1ub v_B1
                                $clength_a2Iq @f_a1ua @a_a1ub v_B1
                                $celem_a2IA @f_a1ua @a_a1ub v_B1
                                $cmaximum_a2IM @f_a1ua @a_a1ub v_B1
                                $cminimum_a2IY @f_a1ua @a_a1ub v_B1
                                $csum_a2Ja @f_a1ua @a_a1ub v_B1
                                $cproduct_a2Jm @f_a1ua @a_a1ub v_B1]
Main.$fFoldableProd
  = \ (@(f_a2G5 :: * -> *))
      (@a_a2G6)
      ($dFoldable_a2G7 :: Foldable f_a2G5) ->
      Data.Foldable.C:Foldable
        @(Prod f_a2G5 a_a2G6)
        ($cfold_a2G9 @f_a2G5 @a_a2G6 $dFoldable_a2G7)
        ($cfoldMap_a2Gl @f_a2G5 @a_a2G6 $dFoldable_a2G7)
        ($cfoldMap'_a2GA @f_a2G5 @a_a2G6 $dFoldable_a2G7)
        ($cfoldr_a2GO @f_a2G5 @a_a2G6 $dFoldable_a2G7)
        ($cfoldr'_a2Hb @f_a2G5 @a_a2G6 $dFoldable_a2G7)
        ($cfoldl_a2Hn @f_a2G5 @a_a2G6 $dFoldable_a2G7)
        ($cfoldl'_a2Hz @f_a2G5 @a_a2G6 $dFoldable_a2G7)
        ($cfoldr1_a2HL @f_a2G5 @a_a2G6 $dFoldable_a2G7)
        ($cfoldl1_a2HV @f_a2G5 @a_a2G6 $dFoldable_a2G7)
        ($ctoList_a2I5 @f_a2G5 @a_a2G6 $dFoldable_a2G7)
        ($cnull_a2If @f_a2G5 @a_a2G6 $dFoldable_a2G7)
        ($clength_a2Iq @f_a2G5 @a_a2G6 $dFoldable_a2G7)
        ($celem_a2IA @f_a2G5 @a_a2G6 $dFoldable_a2G7)
        ($cmaximum_a2IM @f_a2G5 @a_a2G6 $dFoldable_a2G7)
        ($cminimum_a2IY @f_a2G5 @a_a2G6 $dFoldable_a2G7)
        ($csum_a2Ja @f_a2G5 @a_a2G6 $dFoldable_a2G7)
        ($cproduct_a2Jm @f_a2G5 @a_a2G6 $dFoldable_a2G7)

-- RHS size: {terms: 18, types: 28, coercions: 25, joins: 0/0}
$csum_a2Ja [Occ=LoopBreaker]
  :: forall (f :: * -> *) a a. (Foldable f, Num a) => Prod f a a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 140 60}]
$csum_a2Ja
  = \ (@(f_a2G5 :: * -> *))
      (@a_a2G6)
      ($dFoldable_a2G7 :: Foldable f_a2G5)
      (@a_a2Jd)
      ($dNum_a2Je :: Num a_a2Jd) ->
      ((\ (@(t_a4WR :: * -> *))
          ($dFoldable_a4WS :: Foldable t_a4WR)
          (@a_a4WT)
          ($dNum_a4WU :: Num a_a4WT) ->
          Data.Foldable.foldMap'
            @t_a4WR
            $dFoldable_a4WS
            @(base:Data.Semigroup.Internal.Sum a_a4WT)
            @a_a4WT
            (base:Data.Semigroup.Internal.$fMonoidSum @a_a4WT $dNum_a4WU)
            ((\ (ds_a52f :: a_a4WT) -> ds_a52f)
             `cast` (<a_a4WT>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Sum[0]
                                              <a_a4WT>_R)
                     :: (a_a4WT -> a_a4WT)
                        ~R# (a_a4WT -> base:Data.Semigroup.Internal.Sum a_a4WT))))
       `cast` (forall (t :: <* -> *>_N).
               <Foldable t>_R
               %<'Many>_N ->_R forall (a :: <*>_N).
                               <Num a>_R
                               %<'Many>_N ->_R <t a>_R
                               %<'Many>_N ->_R base:Data.Semigroup.Internal.N:Sum[0] <a>_R
               :: (forall {t :: * -> *} {a}.
                   (Foldable t, Num a) =>
                   t a -> base:Data.Semigroup.Internal.Sum a)
                  ~R# (forall {t :: * -> *} {a}. (Foldable t, Num a) => t a -> a)))
        @(Prod f_a2G5 a_a2G6)
        (Main.$fFoldableProd @f_a2G5 @a_a2G6 $dFoldable_a2G7)
        @a_a2Jd
        $dNum_a2Je

-- RHS size: {terms: 28, types: 41, coercions: 8, joins: 0/2}
$cminimum_a2IY [Occ=LoopBreaker]
  :: forall (f :: * -> *) a a. (Foldable f, Ord a) => Prod f a a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 280 60}]
$cminimum_a2IY
  = \ (@(f_a2G5 :: * -> *))
      (@a_a2G6)
      ($dFoldable_a2G7 :: Foldable f_a2G5)
      (@a_a2J1)
      ($dOrd_a2J2 :: Ord a_a2J1) ->
      let {
        d_a52o :: a_a2J1
        [LclId,
         Str=b,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 110 0}]
        d_a52o
          = errorWithoutStackTrace
              @GHC.Types.LiftedRep
              @a_a2J1
              (GHC.Base.build
                 @Char
                 (\ (@b_a52t) ->
                    GHC.CString.unpackFoldrCString#
                      @b_a52t "minimum: empty structure"#)) } in
      let {
        g_a52v
          :: Prod f_a2G5 a_a2G6 a_a2J1 -> base:Data.Functor.Utils.Min a_a2J1
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 100 0}]
        g_a52v
          = Data.Foldable.foldMap'
              @(Prod f_a2G5 a_a2G6)
              (Main.$fFoldableProd @f_a2G5 @a_a2G6 $dFoldable_a2G7)
              @(base:Data.Functor.Utils.Min a_a2J1)
              @a_a2J1
              (base:Data.Functor.Utils.$fMonoidMin @a_a2J1 $dOrd_a2J2)
              ((\ (ds_a53M :: a_a2J1) -> GHC.Maybe.Just @a_a2J1 ds_a53M)
               `cast` (<a_a2J1>_R
                       %<'Many>_N ->_R Sym (base:Data.Functor.Utils.N:Min[0]) <a_a2J1>_N
                       :: (a_a2J1 -> GHC.Maybe.Maybe a_a2J1)
                          ~R# (a_a2J1 -> base:Data.Functor.Utils.Min a_a2J1))) } in
      \ (x_a53N :: Prod f_a2G5 a_a2G6 a_a2J1) ->
        case (g_a52v x_a53N)
             `cast` (base:Data.Functor.Utils.N:Min[0] <a_a2J1>_N
                     :: base:Data.Functor.Utils.Min a_a2J1 ~R# GHC.Maybe.Maybe a_a2J1)
        of {
          GHC.Maybe.Nothing -> d_a52o;
          GHC.Maybe.Just v_a54h -> v_a54h
        }

-- RHS size: {terms: 28, types: 41, coercions: 8, joins: 0/2}
$cmaximum_a2IM [Occ=LoopBreaker]
  :: forall (f :: * -> *) a a. (Foldable f, Ord a) => Prod f a a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 280 60}]
$cmaximum_a2IM
  = \ (@(f_a2G5 :: * -> *))
      (@a_a2G6)
      ($dFoldable_a2G7 :: Foldable f_a2G5)
      (@a_a2IP)
      ($dOrd_a2IQ :: Ord a_a2IP) ->
      let {
        d_a54n :: a_a2IP
        [LclId,
         Str=b,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 110 0}]
        d_a54n
          = errorWithoutStackTrace
              @GHC.Types.LiftedRep
              @a_a2IP
              (GHC.Base.build
                 @Char
                 (\ (@b_a54o) ->
                    GHC.CString.unpackFoldrCString#
                      @b_a54o "maximum: empty structure"#)) } in
      let {
        g_a54p
          :: Prod f_a2G5 a_a2G6 a_a2IP -> base:Data.Functor.Utils.Max a_a2IP
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 100 0}]
        g_a54p
          = Data.Foldable.foldMap'
              @(Prod f_a2G5 a_a2G6)
              (Main.$fFoldableProd @f_a2G5 @a_a2G6 $dFoldable_a2G7)
              @(base:Data.Functor.Utils.Max a_a2IP)
              @a_a2IP
              (base:Data.Functor.Utils.$fMonoidMax @a_a2IP $dOrd_a2IQ)
              ((\ (ds_a54r :: a_a2IP) -> GHC.Maybe.Just @a_a2IP ds_a54r)
               `cast` (<a_a2IP>_R
                       %<'Many>_N ->_R Sym (base:Data.Functor.Utils.N:Max[0]) <a_a2IP>_N
                       :: (a_a2IP -> GHC.Maybe.Maybe a_a2IP)
                          ~R# (a_a2IP -> base:Data.Functor.Utils.Max a_a2IP))) } in
      \ (x_a54s :: Prod f_a2G5 a_a2G6 a_a2IP) ->
        case (g_a54p x_a54s)
             `cast` (base:Data.Functor.Utils.N:Max[0] <a_a2IP>_N
                     :: base:Data.Functor.Utils.Max a_a2IP ~R# GHC.Maybe.Maybe a_a2IP)
        of {
          GHC.Maybe.Nothing -> d_a54n;
          GHC.Maybe.Just v_a54x -> v_a54x
        }

-- RHS size: {terms: 19, types: 27, coercions: 26, joins: 0/0}
$celem_a2IA [Occ=LoopBreaker]
  :: forall (f :: * -> *) a a.
     (Foldable f, Eq a) =>
     a -> Prod f a a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 150 60}]
$celem_a2IA
  = \ (@(f_a2G5 :: * -> *))
      (@a_a2G6)
      ($dFoldable_a2G7 :: Foldable f_a2G5)
      (@a_a2ID)
      ($dEq_a2IE :: Eq a_a2ID) ->
      ((\ (@(t_a54z :: * -> *))
          ($dFoldable_a54A :: Foldable t_a54z)
          (@a_a54B)
          ($dEq_a54C :: Eq a_a54B)
          (eta_a54D :: a_a54B) ->
          foldMap
            @t_a54z
            $dFoldable_a54A
            @base:Data.Semigroup.Internal.Any
            @a_a54B
            base:Data.Semigroup.Internal.$fMonoidAny
            ((== @a_a54B $dEq_a54C eta_a54D)
             `cast` (<a_a54B>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Any[0])
                     :: (a_a54B -> Bool)
                        ~R# (a_a54B -> base:Data.Semigroup.Internal.Any))))
       `cast` (forall (t :: <* -> *>_N).
               <Foldable t>_R
               %<'Many>_N ->_R forall (a :: <*>_N).
                               <Eq a>_R
                               %<'Many>_N ->_R <a>_R
                               %<'Many>_N ->_R <t a>_R
                               %<'Many>_N ->_R base:Data.Semigroup.Internal.N:Any[0]
               :: (forall {t :: * -> *} {a}.
                   (Foldable t, Eq a) =>
                   a -> t a -> base:Data.Semigroup.Internal.Any)
                  ~R# (forall {t :: * -> *} {a}.
                       (Foldable t, Eq a) =>
                       a -> t a -> Bool)))
        @(Prod f_a2G5 a_a2G6)
        (Main.$fFoldableProd @f_a2G5 @a_a2G6 $dFoldable_a2G7)
        @a_a2ID
        $dEq_a2IE

-- RHS size: {terms: 18, types: 18, coercions: 0, joins: 0/0}
$clength_a2Iq [Occ=LoopBreaker]
  :: forall (f :: * -> *) a a. Foldable f => Prod f a a -> Int
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 111 0}]
$clength_a2Iq
  = \ (@(f_a2G5 :: * -> *))
      (@a_a2G6)
      ($dFoldable_a2G7 :: Foldable f_a2G5)
      (@a_a2It) ->
      Data.Foldable.foldl'
        @(Prod f_a2G5 a_a2G6)
        (Main.$fFoldableProd @f_a2G5 @a_a2G6 $dFoldable_a2G7)
        @Int
        @a_a2It
        (\ (c_a54K :: Int) _ [Occ=Dead] ->
           case c_a54K of { GHC.Types.I# x_a54N ->
           GHC.Types.I# (GHC.Prim.+# x_a54N 1#)
           })
        (GHC.Types.I# 0#)

-- RHS size: {terms: 17, types: 30, coercions: 0, joins: 0/1}
$ctoList_a2I5 [Occ=LoopBreaker]
  :: forall (f :: * -> *) a a. Foldable f => Prod f a a -> [a]
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 110 60}]
$ctoList_a2I5
  = \ (@(f_a2G5 :: * -> *))
      (@a_a2G6)
      ($dFoldable_a2G7 :: Foldable f_a2G5)
      (@a_a2I8) ->
      let {
        $dFoldable_a54Q :: Foldable (Prod f_a2G5 a_a2G6)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dFoldable_a54Q
          = Main.$fFoldableProd @f_a2G5 @a_a2G6 $dFoldable_a2G7 } in
      \ (t1_a54S :: Prod f_a2G5 a_a2G6 a_a2I8) ->
        GHC.Base.build
          @a_a2I8
          (\ (@b_a54T)
             (c_a54U [OS=OneShot] :: a_a2I8 -> b_a54T -> b_a54T)
             (n_a54V [OS=OneShot] :: b_a54T) ->
             foldr
               @(Prod f_a2G5 a_a2G6)
               $dFoldable_a54Q
               @a_a2I8
               @b_a54T
               c_a54U
               n_a54V
               t1_a54S)

-- RHS size: {terms: 33, types: 44, coercions: 0, joins: 0/1}
$cfoldl1_a2HV [Occ=LoopBreaker]
  :: forall (f :: * -> *) a a.
     Foldable f =>
     (a -> a -> a) -> Prod f a a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 310 60}]
$cfoldl1_a2HV
  = \ (@(f_a2G5 :: * -> *))
      (@a_a2G6)
      ($dFoldable_a2G7 :: Foldable f_a2G5)
      (@a_a2HY) ->
      let {
        $dFoldable_a54X :: Foldable (Prod f_a2G5 a_a2G6)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dFoldable_a54X
          = Main.$fFoldableProd @f_a2G5 @a_a2G6 $dFoldable_a2G7 } in
      \ (f_a54Z :: a_a2HY -> a_a2HY -> a_a2HY)
        (xs_a550 :: Prod f_a2G5 a_a2G6 a_a2HY) ->
        case foldl
               @(Prod f_a2G5 a_a2G6)
               $dFoldable_a54X
               @(GHC.Maybe.Maybe a_a2HY)
               @a_a2HY
               (\ (m_a551 :: GHC.Maybe.Maybe a_a2HY) (y_a552 :: a_a2HY) ->
                  GHC.Maybe.Just
                    @a_a2HY
                    (case m_a551 of {
                       GHC.Maybe.Nothing -> y_a552;
                       GHC.Maybe.Just x_a555 -> f_a54Z x_a555 y_a552
                     }))
               (GHC.Maybe.Nothing @a_a2HY)
               xs_a550
        of {
          GHC.Maybe.Nothing ->
            errorWithoutStackTrace
              @GHC.Types.LiftedRep
              @a_a2HY
              (GHC.Base.build
                 @Char
                 (\ (@b_a558) ->
                    GHC.CString.unpackFoldrCString#
                      @b_a558 "foldl1: empty structure"#));
          GHC.Maybe.Just v_a559 -> v_a559
        }

-- RHS size: {terms: 33, types: 44, coercions: 0, joins: 0/1}
$cfoldr1_a2HL [Occ=LoopBreaker]
  :: forall (f :: * -> *) a a.
     Foldable f =>
     (a -> a -> a) -> Prod f a a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 310 60}]
$cfoldr1_a2HL
  = \ (@(f_a2G5 :: * -> *))
      (@a_a2G6)
      ($dFoldable_a2G7 :: Foldable f_a2G5)
      (@a_a2HO) ->
      let {
        $dFoldable_a55d :: Foldable (Prod f_a2G5 a_a2G6)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dFoldable_a55d
          = Main.$fFoldableProd @f_a2G5 @a_a2G6 $dFoldable_a2G7 } in
      \ (f_a55f :: a_a2HO -> a_a2HO -> a_a2HO)
        (xs_a55g :: Prod f_a2G5 a_a2G6 a_a2HO) ->
        case foldr
               @(Prod f_a2G5 a_a2G6)
               $dFoldable_a55d
               @a_a2HO
               @(GHC.Maybe.Maybe a_a2HO)
               (\ (x_a55h :: a_a2HO) (m_a55i :: GHC.Maybe.Maybe a_a2HO) ->
                  GHC.Maybe.Just
                    @a_a2HO
                    (case m_a55i of {
                       GHC.Maybe.Nothing -> x_a55h;
                       GHC.Maybe.Just y_a55l -> f_a55f x_a55h y_a55l
                     }))
               (GHC.Maybe.Nothing @a_a2HO)
               xs_a55g
        of {
          GHC.Maybe.Nothing ->
            errorWithoutStackTrace
              @GHC.Types.LiftedRep
              @a_a2HO
              (GHC.Base.build
                 @Char
                 (\ (@b_a55o) ->
                    GHC.CString.unpackFoldrCString#
                      @b_a55o "foldr1: empty structure"#));
          GHC.Maybe.Just v_a55p -> v_a55p
        }

-- RHS size: {terms: 26, types: 36, coercions: 0, joins: 0/1}
$cfoldl'_a2Hz [Occ=LoopBreaker]
  :: forall (f :: * -> *) a b a.
     Foldable f =>
     (b -> a -> b) -> b -> Prod f a a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 210 60}]
$cfoldl'_a2Hz
  = \ (@(f_a2G5 :: * -> *))
      (@a_a2G6)
      ($dFoldable_a2G7 :: Foldable f_a2G5)
      (@b_a2HC)
      (@a_a2HD) ->
      let {
        $dFoldable_a55t :: Foldable (Prod f_a2G5 a_a2G6)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dFoldable_a55t
          = Main.$fFoldableProd @f_a2G5 @a_a2G6 $dFoldable_a2G7 } in
      \ (f_a55w :: b_a2HC -> a_a2HD -> b_a2HC)
        (z0_a55x :: b_a2HC)
        (xs_a55y :: Prod f_a2G5 a_a2G6 a_a2HD) ->
        foldr
          @(Prod f_a2G5 a_a2G6)
          $dFoldable_a55t
          @a_a2HD
          @(b_a2HC -> b_a2HC)
          (\ (ds_a55z :: a_a2HD)
             (ds1_a55A :: b_a2HC -> b_a2HC)
             (v_a55B [OS=OneShot] :: b_a2HC) ->
             case v_a55B of z_a55C { __DEFAULT ->
             ds1_a55A (f_a55w z_a55C ds_a55z)
             })
          (id @b_a2HC)
          xs_a55y
          z0_a55x

-- RHS size: {terms: 22, types: 36, coercions: 10, joins: 0/1}
$cfoldl_a2Hn [Occ=LoopBreaker]
  :: forall (f :: * -> *) a b a.
     Foldable f =>
     (b -> a -> b) -> b -> Prod f a a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 190 60}]
$cfoldl_a2Hn
  = \ (@(f_a2G5 :: * -> *))
      (@a_a2G6)
      ($dFoldable_a2G7 :: Foldable f_a2G5)
      (@b_a2Hq)
      (@a_a2Hr) ->
      let {
        $dFoldable_a55F :: Foldable (Prod f_a2G5 a_a2G6)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dFoldable_a55F
          = Main.$fFoldableProd @f_a2G5 @a_a2G6 $dFoldable_a2G7 } in
      \ (eta_a55I :: b_a2Hq -> a_a2Hr -> b_a2Hq)
        (eta1_a55J :: b_a2Hq)
        (eta2_a55K :: Prod f_a2G5 a_a2G6 a_a2Hr) ->
        ((foldMap
            @(Prod f_a2G5 a_a2G6)
            $dFoldable_a55F
            @(base:Data.Semigroup.Internal.Dual
                (base:Data.Semigroup.Internal.Endo b_a2Hq))
            @a_a2Hr
            (base:Data.Semigroup.Internal.$fMonoidDual
               @(base:Data.Semigroup.Internal.Endo b_a2Hq)
               (base:Data.Semigroup.Internal.$fMonoidEndo @b_a2Hq))
            ((\ (x_a55N :: a_a2Hr) (y_a55O :: b_a2Hq) ->
                eta_a55I y_a55O x_a55N)
             `cast` (<a_a2Hr>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Dual[0]
                                              (base:Data.Semigroup.Internal.N:Endo[0] <b_a2Hq>_R))
                     :: (a_a2Hr -> b_a2Hq -> b_a2Hq)
                        ~R# (a_a2Hr
                             -> base:Data.Semigroup.Internal.Dual
                                  (base:Data.Semigroup.Internal.Endo b_a2Hq))))
            eta2_a55K)
         `cast` (base:Data.Semigroup.Internal.N:Dual[0]
                     (base:Data.Semigroup.Internal.N:Endo[0] <b_a2Hq>_R)
                 :: base:Data.Semigroup.Internal.Dual
                      (base:Data.Semigroup.Internal.Endo b_a2Hq)
                    ~R# (b_a2Hq -> b_a2Hq)))
          eta1_a55J

-- RHS size: {terms: 26, types: 36, coercions: 0, joins: 0/1}
$cfoldr'_a2Hb [Occ=LoopBreaker]
  :: forall (f :: * -> *) a a b.
     Foldable f =>
     (a -> b -> b) -> b -> Prod f a a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 210 60}]
$cfoldr'_a2Hb
  = \ (@(f_a2G5 :: * -> *))
      (@a_a2G6)
      ($dFoldable_a2G7 :: Foldable f_a2G5)
      (@a_a2He)
      (@b_a2Hf) ->
      let {
        $dFoldable_a55U :: Foldable (Prod f_a2G5 a_a2G6)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dFoldable_a55U
          = Main.$fFoldableProd @f_a2G5 @a_a2G6 $dFoldable_a2G7 } in
      \ (f_a55X :: a_a2He -> b_a2Hf -> b_a2Hf)
        (z0_a55Y :: b_a2Hf)
        (xs_a55Z :: Prod f_a2G5 a_a2G6 a_a2He) ->
        foldl
          @(Prod f_a2G5 a_a2G6)
          $dFoldable_a55U
          @(b_a2Hf -> b_a2Hf)
          @a_a2He
          (\ (ds_a560 :: b_a2Hf -> b_a2Hf)
             (ds1_a561 :: a_a2He)
             (v_a562 [OS=OneShot] :: b_a2Hf) ->
             case v_a562 of z_a563 { __DEFAULT ->
             ds_a560 (f_a55X ds1_a561 z_a563)
             })
          (id @b_a2Hf)
          xs_a55Z
          z0_a55Y

-- RHS size: {terms: 24, types: 31, coercions: 0, joins: 0/2}
$cfoldMap'_a2GA [Occ=LoopBreaker]
  :: forall (f :: * -> *) a m a.
     (Foldable f, Monoid m) =>
     (a -> m) -> Prod f a a -> m
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 60] 210 60}]
$cfoldMap'_a2GA
  = \ (@(f_a2G5 :: * -> *))
      (@a_a2G6)
      ($dFoldable_a2G7 :: Foldable f_a2G5)
      (@m_a2GD)
      (@a_a2GE)
      ($dMonoid_a2GF :: Monoid m_a2GD) ->
      let {
        $dFoldable_a565 :: Foldable (Prod f_a2G5 a_a2G6)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dFoldable_a565
          = Main.$fFoldableProd @f_a2G5 @a_a2G6 $dFoldable_a2G7 } in
      \ (eta_a569 :: a_a2GE -> m_a2GD) ->
        let {
          $dSemigroup_a56a :: Semigroup m_a2GD
          [LclId,
           Unf=Unf{Src=<vanilla>, TopLvl=False,
                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                   Guidance=IF_ARGS [] 20 0}]
          $dSemigroup_a56a = GHC.Base.$p1Monoid @m_a2GD $dMonoid_a2GF } in
        Data.Foldable.foldl'
          @(Prod f_a2G5 a_a2G6)
          $dFoldable_a565
          @m_a2GD
          @a_a2GE
          (\ (acc_a56b :: m_a2GD) (a1_a56c :: a_a2GE) ->
             <> @m_a2GD $dSemigroup_a56a acc_a56b (eta_a569 a1_a56c))
          (mempty @m_a2GD $dMonoid_a2GF)

-- RHS size: {terms: 18, types: 28, coercions: 25, joins: 0/0}
$cproduct_a2Jm [Occ=LoopBreaker]
  :: forall (f :: * -> *) a a. (Foldable f, Num a) => Prod f a a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 140 60}]
$cproduct_a2Jm
  = \ (@(f_a2G5 :: * -> *))
      (@a_a2G6)
      ($dFoldable_a2G7 :: Foldable f_a2G5)
      (@a_a2Jp)
      ($dNum_a2Jq :: Num a_a2Jp) ->
      ((\ (@(t_a56d :: * -> *))
          ($dFoldable_a56e :: Foldable t_a56d)
          (@a_a56f)
          ($dNum_a56g :: Num a_a56f) ->
          Data.Foldable.foldMap'
            @t_a56d
            $dFoldable_a56e
            @(base:Data.Semigroup.Internal.Product a_a56f)
            @a_a56f
            (base:Data.Semigroup.Internal.$fMonoidProduct @a_a56f $dNum_a56g)
            ((\ (ds_a56i :: a_a56f) -> ds_a56i)
             `cast` (<a_a56f>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Product[0]
                                              <a_a56f>_R)
                     :: (a_a56f -> a_a56f)
                        ~R# (a_a56f -> base:Data.Semigroup.Internal.Product a_a56f))))
       `cast` (forall (t :: <* -> *>_N).
               <Foldable t>_R
               %<'Many>_N ->_R forall (a :: <*>_N).
                               <Num a>_R
                               %<'Many>_N ->_R <t a>_R
                               %<'Many>_N ->_R base:Data.Semigroup.Internal.N:Product[0] <a>_R
               :: (forall {t :: * -> *} {a}.
                   (Foldable t, Num a) =>
                   t a -> base:Data.Semigroup.Internal.Product a)
                  ~R# (forall {t :: * -> *} {a}. (Foldable t, Num a) => t a -> a)))
        @(Prod f_a2G5 a_a2G6)
        (Main.$fFoldableProd @f_a2G5 @a_a2G6 $dFoldable_a2G7)
        @a_a2Jp
        $dNum_a2Jq

-- RHS size: {terms: 10, types: 17, coercions: 0, joins: 0/0}
$cfold_a2G9 [Occ=LoopBreaker]
  :: forall (f :: * -> *) a m.
     (Foldable f, Monoid m) =>
     Prod f a m -> m
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 60 0}]
$cfold_a2G9
  = \ (@(f_a2G5 :: * -> *))
      (@a_a2G6)
      ($dFoldable_a2G7 :: Foldable f_a2G5)
      (@m_a2Gc)
      ($dMonoid_a2Gd :: Monoid m_a2Gc) ->
      foldMap
        @(Prod f_a2G5 a_a2G6)
        (Main.$fFoldableProd @f_a2G5 @a_a2G6 $dFoldable_a2G7)
        @m_a2Gc
        @m_a2Gc
        $dMonoid_a2Gd
        (id @m_a2Gc)
end Rec }

-- RHS size: {terms: 6, types: 8, coercions: 0, joins: 0/0}
$cp2Traversable_a46V
  :: forall {f :: * -> *} {fixed}.
     Traversable f =>
     Foldable (Prod f fixed)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30] 40 0}]
$cp2Traversable_a46V
  = \ (@(f_a46L :: * -> *))
      (@fixed_a46M)
      ($dTraversable_a46N :: Traversable f_a46L) ->
      Main.$fFoldableProd
        @f_a46L
        @fixed_a46M
        (Data.Traversable.$p2Traversable @f_a46L $dTraversable_a46N)

-- RHS size: {terms: 16, types: 29, coercions: 0, joins: 0/0}
$c<$_a2FK
  :: forall (f :: * -> *) a a b.
     Functor f =>
     a -> Prod f a b -> Prod f a a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 0 20] 60 10}]
$c<$_a2FK
  = \ (@(f_a2Fn :: * -> *))
      (@a_a2Fo)
      ($dFunctor_a2Fp :: Functor f_a2Fn)
      (@a_a2FN)
      (@b_a2FO)
      (z_a29A :: a_a2FN)
      (ds_d4HF :: Prod f_a2Fn a_a2Fo b_a2FO) ->
      case ds_d4HF of { FProd a1_a29B a2_a29C ->
      Main.FProd
        @(*)
        @f_a2Fn
        @a_a2Fo
        @a_a2FN
        a1_a29B
        (<$ @f_a2Fn $dFunctor_a2Fp @a_a2FN @b_a2FO z_a29A a2_a29C)
      }

-- RHS size: {terms: 16, types: 30, coercions: 0, joins: 0/0}
$cfmap_a2Fr
  :: forall (f :: * -> *) a a b.
     Functor f =>
     (a -> b) -> Prod f a a -> Prod f a b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 0 20] 60 10}]
$cfmap_a2Fr
  = \ (@(f_a2Fn :: * -> *))
      (@a_a2Fo)
      ($dFunctor_a2Fp :: Functor f_a2Fn)
      (@a_a2Fu)
      (@b_a2Fv)
      (f_a29x :: a_a2Fu -> b_a2Fv)
      (ds_d4HA :: Prod f_a2Fn a_a2Fo a_a2Fu) ->
      case ds_d4HA of { FProd a1_a29y a2_a29z ->
      Main.FProd
        @(*)
        @f_a2Fn
        @a_a2Fo
        @b_a2Fv
        a1_a29y
        (fmap @f_a2Fn $dFunctor_a2Fp @a_a2Fu @b_a2Fv f_a29x a2_a29z)
      }

-- RHS size: {terms: 8, types: 13, coercions: 0, joins: 0/0}
Main.$fFunctorProd [InlPrag=CONLIKE]
  :: forall (f :: * -> *) a. Functor f => Functor (Prod f a)
[LclIdX[DFunId],
 Unf=DFun: \ (@(f_a1u3 :: * -> *))
             (@a_a1u4)
             (v_B1 :: Functor f_a1u3) ->
       GHC.Base.C:Functor TYPE: Prod f_a1u3 a_a1u4
                          $cfmap_a2Fr @f_a1u3 @a_a1u4 v_B1
                          $c<$_a2FK @f_a1u3 @a_a1u4 v_B1]
Main.$fFunctorProd
  = \ (@(f_a2Fn :: * -> *))
      (@a_a2Fo)
      ($dFunctor_a2Fp :: Functor f_a2Fn) ->
      GHC.Base.C:Functor
        @(Prod f_a2Fn a_a2Fo)
        ($cfmap_a2Fr @f_a2Fn @a_a2Fo $dFunctor_a2Fp)
        ($c<$_a2FK @f_a2Fn @a_a2Fo $dFunctor_a2Fp)

-- RHS size: {terms: 6, types: 8, coercions: 0, joins: 0/0}
$cp1Traversable_a46R
  :: forall {f :: * -> *} {fixed}.
     Traversable f =>
     Functor (Prod f fixed)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30] 40 0}]
$cp1Traversable_a46R
  = \ (@(f_a46L :: * -> *))
      (@fixed_a46M)
      ($dTraversable_a46N :: Traversable f_a46L) ->
      Main.$fFunctorProd
        @f_a46L
        @fixed_a46M
        (Data.Traversable.$p1Traversable @f_a46L $dTraversable_a46N)

Rec {
-- RHS size: {terms: 16, types: 21, coercions: 0, joins: 0/0}
Main.$fTraversableProd [InlPrag=CONLIKE]
  :: forall (f :: * -> *) fixed.
     Traversable f =>
     Traversable (Prod f fixed)
[LclIdX[DFunId],
 Unf=DFun: \ (@(f_aUo :: * -> *))
             (@fixed_aUp)
             (v_B1 :: Traversable f_aUo) ->
       Data.Traversable.C:Traversable TYPE: Prod f_aUo fixed_aUp
                                      $cp1Traversable_a46R @f_aUo @fixed_aUp v_B1
                                      $cp2Traversable_a46V @f_aUo @fixed_aUp v_B1
                                      $ctraverse_a46X @f_aUo @fixed_aUp v_B1
                                      $csequenceA_a47d @f_aUo @fixed_aUp v_B1
                                      $cmapM_a47r @f_aUo @fixed_aUp v_B1
                                      $csequence_a47H @f_aUo @fixed_aUp v_B1]
Main.$fTraversableProd
  = \ (@(f_a46L :: * -> *))
      (@fixed_a46M)
      ($dTraversable_a46N :: Traversable f_a46L) ->
      Data.Traversable.C:Traversable
        @(Prod f_a46L fixed_a46M)
        ($cp1Traversable_a46R @f_a46L @fixed_a46M $dTraversable_a46N)
        ($cp2Traversable_a46V @f_a46L @fixed_a46M $dTraversable_a46N)
        ($ctraverse_a46X @f_a46L @fixed_a46M $dTraversable_a46N)
        ($csequenceA_a47d @f_a46L @fixed_a46M $dTraversable_a46N)
        ($cmapM_a47r @f_a46L @fixed_a46M $dTraversable_a46N)
        ($csequence_a47H @f_a46L @fixed_a46M $dTraversable_a46N)

-- RHS size: {terms: 12, types: 21, coercions: 0, joins: 0/0}
$cmapM_a47r [Occ=LoopBreaker]
  :: forall (f :: * -> *) fixed (m :: * -> *) a b.
     (Traversable f, Monad m) =>
     (a -> m b) -> Prod f fixed a -> m (Prod f fixed b)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 30] 70 0}]
$cmapM_a47r
  = \ (@(f_a46L :: * -> *))
      (@fixed_a46M)
      ($dTraversable_a46N :: Traversable f_a46L)
      (@(m_a47u :: * -> *))
      (@a_a47v)
      (@b_a47w)
      ($dMonad_a47x :: Monad m_a47u) ->
      traverse
        @(Prod f_a46L fixed_a46M)
        (Main.$fTraversableProd @f_a46L @fixed_a46M $dTraversable_a46N)
        @m_a47u
        @a_a47v
        @b_a47w
        (GHC.Base.$p1Monad @m_a47u $dMonad_a47x)

-- RHS size: {terms: 11, types: 22, coercions: 0, joins: 0/0}
$csequenceA_a47d [Occ=LoopBreaker]
  :: forall (f :: * -> *) fixed (f :: * -> *) a.
     (Traversable f, Applicative f) =>
     Prod f fixed (f a) -> f (Prod f fixed a)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 60 0}]
$csequenceA_a47d
  = \ (@(f_a46L :: * -> *))
      (@fixed_a46M)
      ($dTraversable_a46N :: Traversable f_a46L)
      (@(f_a47g :: * -> *))
      (@a_a47h)
      ($dApplicative_a47i :: Applicative f_a47g) ->
      traverse
        @(Prod f_a46L fixed_a46M)
        (Main.$fTraversableProd @f_a46L @fixed_a46M $dTraversable_a46N)
        @f_a47g
        @(f_a47g a_a47h)
        @a_a47h
        $dApplicative_a47i
        (id @(f_a47g a_a47h))

-- RHS size: {terms: 11, types: 19, coercions: 0, joins: 0/0}
$csequence_a47H [Occ=LoopBreaker]
  :: forall (f :: * -> *) fixed (m :: * -> *) a.
     (Traversable f, Monad m) =>
     Prod f fixed (m a) -> m (Prod f fixed a)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 30] 70 0}]
$csequence_a47H
  = \ (@(f_a46L :: * -> *))
      (@fixed_a46M)
      ($dTraversable_a46N :: Traversable f_a46L)
      (@(m_a47K :: * -> *))
      (@a_a47L)
      ($dMonad_a47M :: Monad m_a47K) ->
      sequenceA
        @(Prod f_a46L fixed_a46M)
        (Main.$fTraversableProd @f_a46L @fixed_a46M $dTraversable_a46N)
        @m_a47K
        @a_a47L
        (GHC.Base.$p1Monad @m_a47K $dMonad_a47M)

-- RHS size: {terms: 24, types: 66, coercions: 0, joins: 0/3}
$ctraverse_a46X [Occ=LoopBreaker]
  :: forall (f :: * -> *) fixed (f :: * -> *) a b.
     (Traversable f, Applicative f) =>
     (a -> f b) -> Prod f fixed a -> f (Prod f fixed b)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 190 60}]
$ctraverse_a46X
  = \ (@(f_a46L :: * -> *))
      (@fixed_a46M)
      ($dTraversable_a46N :: Traversable f_a46L)
      (@(f_a470 :: * -> *))
      (@a_a471)
      (@b_a472)
      ($dApplicative_a473 :: Applicative f_a470) ->
      let {
        $dTraversable_a56I :: Traversable (Prod f_a46L fixed_a46M)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dTraversable_a56I
          = Main.$fTraversableProd
              @f_a46L @fixed_a46M $dTraversable_a46N } in
      \ (eta1_a56N :: a_a471 -> f_a470 b_a472) ->
        let {
          f1_a56O
            :: Prod f_a46L fixed_a46M (f_a470 b_a472)
               -> f_a470 (Prod f_a46L fixed_a46M b_a472)
          [LclId,
           Unf=Unf{Src=<vanilla>, TopLvl=False,
                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                   Guidance=IF_ARGS [] 30 0}]
          f1_a56O
            = sequenceA
                @(Prod f_a46L fixed_a46M)
                $dTraversable_a56I
                @f_a470
                @b_a472
                $dApplicative_a473 } in
        let {
          g_a56P
            :: Prod f_a46L fixed_a46M a_a471
               -> Prod f_a46L fixed_a46M (f_a470 b_a472)
          [LclId,
           Unf=Unf{Src=<vanilla>, TopLvl=False,
                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                   Guidance=IF_ARGS [] 50 0}]
          g_a56P
            = fmap
                @(Prod f_a46L fixed_a46M)
                (Data.Traversable.$p1Traversable
                   @(Prod f_a46L fixed_a46M) $dTraversable_a56I)
                @a_a471
                @(f_a470 b_a472)
                eta1_a56N } in
        \ (x_a56Q :: Prod f_a46L fixed_a46M a_a471) ->
          f1_a56O (g_a56P x_a56Q)
end Rec }

-- RHS size: {terms: 34, types: 40, coercions: 0, joins: 0/0}
$cshowsPrec_a2EM
  :: forall k (f :: k -> *) (a :: k) (b :: k).
     (Show (f a), Show (f b)) =>
     Int -> Prod f a b -> ShowS
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 0 20] 350 0}]
$cshowsPrec_a2EM
  = \ (@k_a2EF)
      (@(f_a2EG :: k_a2EF -> *))
      (@(a_a2EH :: k_a2EF))
      (@(b_a2EI :: k_a2EF))
      ($dShow_a2EJ :: Show (f_a2EG a_a2EH))
      ($dShow_a2EK :: Show (f_a2EG b_a2EI))
      (a_a29u :: Int)
      (ds_d4Hp :: Prod f_a2EG a_a2EH b_a2EI) ->
      case ds_d4Hp of { FProd b1_a29v b2_a29w ->
      showParen
        (>= @Int GHC.Classes.$fOrdInt a_a29u (GHC.Types.I# 11#))
        (. @String
           @String
           @String
           (showString (GHC.CString.unpackCString# "FProd "#))
           (. @String
              @String
              @String
              (showsPrec @(f_a2EG a_a2EH) $dShow_a2EJ (GHC.Types.I# 11#) b1_a29v)
              (. @String
                 @String
                 @String
                 GHC.Show.showSpace
                 (showsPrec
                    @(f_a2EG b_a2EI) $dShow_a2EK (GHC.Types.I# 11#) b2_a29w))))
      }

Rec {
-- RHS size: {terms: 16, types: 28, coercions: 0, joins: 0/0}
Main.$fShowProd [InlPrag=CONLIKE]
  :: forall k (f :: k -> *) (a :: k) (b :: k).
     (Show (f a), Show (f b)) =>
     Show (Prod f a b)
[LclIdX[DFunId],
 Unf=DFun: \ (@k_a1tU)
             (@(f_a1tV :: k_a1tU -> *))
             (@(a_a1tW :: k_a1tU))
             (@(b_a1tX :: k_a1tU))
             (v_B1 :: Show (f_a1tV a_a1tW))
             (v_B2 :: Show (f_a1tV b_a1tX)) ->
       GHC.Show.C:Show TYPE: Prod f_a1tV a_a1tW b_a1tX
                       $cshowsPrec_a2EM @k_a1tU @f_a1tV @a_a1tW @b_a1tX v_B1 v_B2
                       $cshow_a2F7 @k_a1tU @f_a1tV @a_a1tW @b_a1tX v_B1 v_B2
                       $cshowList_a2Fe @k_a1tU @f_a1tV @a_a1tW @b_a1tX v_B1 v_B2]
Main.$fShowProd
  = \ (@k_a2EF)
      (@(f_a2EG :: k_a2EF -> *))
      (@(a_a2EH :: k_a2EF))
      (@(b_a2EI :: k_a2EF))
      ($dShow_a2EJ :: Show (f_a2EG a_a2EH))
      ($dShow_a2EK :: Show (f_a2EG b_a2EI)) ->
      GHC.Show.C:Show
        @(Prod f_a2EG a_a2EH b_a2EI)
        ($cshowsPrec_a2EM
           @k_a2EF @f_a2EG @a_a2EH @b_a2EI $dShow_a2EJ $dShow_a2EK)
        ($cshow_a2F7
           @k_a2EF @f_a2EG @a_a2EH @b_a2EI $dShow_a2EJ $dShow_a2EK)
        ($cshowList_a2Fe
           @k_a2EF @f_a2EG @a_a2EH @b_a2EI $dShow_a2EJ $dShow_a2EK)

-- RHS size: {terms: 19, types: 38, coercions: 0, joins: 0/1}
$cshowList_a2Fe [Occ=LoopBreaker]
  :: forall k (f :: k -> *) (a :: k) (b :: k).
     (Show (f a), Show (f b)) =>
     [Prod f a b] -> ShowS
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 140 60}]
$cshowList_a2Fe
  = \ (@k_a2EF)
      (@(f_a2EG :: k_a2EF -> *))
      (@(a_a2EH :: k_a2EF))
      (@(b_a2EI :: k_a2EF))
      ($dShow_a2EJ :: Show (f_a2EG a_a2EH))
      ($dShow_a2EK :: Show (f_a2EG b_a2EI)) ->
      let {
        $dShow_a56S :: Show (Prod f_a2EG a_a2EH b_a2EI)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 30 0}]
        $dShow_a56S
          = Main.$fShowProd
              @k_a2EF @f_a2EG @a_a2EH @b_a2EI $dShow_a2EJ $dShow_a2EK } in
      \ (ls_a56T :: [Prod f_a2EG a_a2EH b_a2EI]) (s_a56U :: String) ->
        GHC.Show.showList__
          @(Prod f_a2EG a_a2EH b_a2EI)
          (showsPrec
             @(Prod f_a2EG a_a2EH b_a2EI) $dShow_a56S (GHC.Types.I# 0#))
          ls_a56T
          s_a56U

-- RHS size: {terms: 17, types: 32, coercions: 0, joins: 0/1}
$cshow_a2F7 [Occ=LoopBreaker]
  :: forall k (f :: k -> *) (a :: k) (b :: k).
     (Show (f a), Show (f b)) =>
     Prod f a b -> String
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 110 60}]
$cshow_a2F7
  = \ (@k_a2EF)
      (@(f_a2EG :: k_a2EF -> *))
      (@(a_a2EH :: k_a2EF))
      (@(b_a2EI :: k_a2EF))
      ($dShow_a2EJ :: Show (f_a2EG a_a2EH))
      ($dShow_a2EK :: Show (f_a2EG b_a2EI)) ->
      let {
        $dShow_a56X :: Show (Prod f_a2EG a_a2EH b_a2EI)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 30 0}]
        $dShow_a56X
          = Main.$fShowProd
              @k_a2EF @f_a2EG @a_a2EH @b_a2EI $dShow_a2EJ $dShow_a2EK } in
      \ (x_a56Y :: Prod f_a2EG a_a2EH b_a2EI) ->
        showsPrec
          @(Prod f_a2EG a_a2EH b_a2EI)
          $dShow_a56X
          (GHC.Types.I# 0#)
          x_a56Y
          (GHC.Types.[] @Char)
end Rec }

-- RHS size: {terms: 23, types: 43, coercions: 0, joins: 0/0}
$c==_a2El
  :: forall k (f :: k -> *) (a :: k) (b :: k).
     (Eq (f a), Eq (f b)) =>
     Prod f a b -> Prod f a b -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 20 20] 130 0}]
$c==_a2El
  = \ (@k_a2Ee)
      (@(f_a2Ef :: k_a2Ee -> *))
      (@(a_a2Eg :: k_a2Ee))
      (@(b_a2Eh :: k_a2Ee))
      ($dEq_a2Ei :: Eq (f_a2Ef a_a2Eg))
      ($dEq_a2Ej :: Eq (f_a2Ef b_a2Eh))
      (ds_d4He :: Prod f_a2Ef a_a2Eg b_a2Eh)
      (ds_d4Hf :: Prod f_a2Ef a_a2Eg b_a2Eh) ->
      case ds_d4He of { FProd a1_a29q a2_a29r ->
      case ds_d4Hf of { FProd b1_a29s b2_a29t ->
      &&
        (== @(f_a2Ef a_a2Eg) $dEq_a2Ei a1_a29q b1_a29s)
        (== @(f_a2Ef b_a2Eh) $dEq_a2Ej a2_a29r b2_a29t)
      }
      }

Rec {
-- RHS size: {terms: 13, types: 24, coercions: 0, joins: 0/0}
Main.$fEqProd [InlPrag=CONLIKE]
  :: forall k (f :: k -> *) (a :: k) (b :: k).
     (Eq (f a), Eq (f b)) =>
     Eq (Prod f a b)
[LclIdX[DFunId],
 Unf=DFun: \ (@k_a1tJ)
             (@(f_a1tK :: k_a1tJ -> *))
             (@(a_a1tL :: k_a1tJ))
             (@(b_a1tM :: k_a1tJ))
             (v_B1 :: Eq (f_a1tK a_a1tL))
             (v_B2 :: Eq (f_a1tK b_a1tM)) ->
       GHC.Classes.C:Eq TYPE: Prod f_a1tK a_a1tL b_a1tM
                        $c==_a2El @k_a1tJ @f_a1tK @a_a1tL @b_a1tM v_B1 v_B2
                        $c/=_a2Ew @k_a1tJ @f_a1tK @a_a1tL @b_a1tM v_B1 v_B2]
Main.$fEqProd
  = \ (@k_a2Ee)
      (@(f_a2Ef :: k_a2Ee -> *))
      (@(a_a2Eg :: k_a2Ee))
      (@(b_a2Eh :: k_a2Ee))
      ($dEq_a2Ei :: Eq (f_a2Ef a_a2Eg))
      ($dEq_a2Ej :: Eq (f_a2Ef b_a2Eh)) ->
      GHC.Classes.C:Eq
        @(Prod f_a2Ef a_a2Eg b_a2Eh)
        ($c==_a2El @k_a2Ee @f_a2Ef @a_a2Eg @b_a2Eh $dEq_a2Ei $dEq_a2Ej)
        ($c/=_a2Ew @k_a2Ee @f_a2Ef @a_a2Eg @b_a2Eh $dEq_a2Ei $dEq_a2Ej)

-- RHS size: {terms: 21, types: 37, coercions: 0, joins: 0/1}
$c/=_a2Ew [Occ=LoopBreaker]
  :: forall k (f :: k -> *) (a :: k) (b :: k).
     (Eq (f a), Eq (f b)) =>
     Prod f a b -> Prod f a b -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 120 60}]
$c/=_a2Ew
  = \ (@k_a2Ee)
      (@(f_a2Ef :: k_a2Ee -> *))
      (@(a_a2Eg :: k_a2Ee))
      (@(b_a2Eh :: k_a2Ee))
      ($dEq_a2Ei :: Eq (f_a2Ef a_a2Eg))
      ($dEq_a2Ej :: Eq (f_a2Ef b_a2Eh)) ->
      let {
        $dEq_a570 :: Eq (Prod f_a2Ef a_a2Eg b_a2Eh)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 30 0}]
        $dEq_a570
          = Main.$fEqProd
              @k_a2Ee @f_a2Ef @a_a2Eg @b_a2Eh $dEq_a2Ei $dEq_a2Ej } in
      \ (x_a571 :: Prod f_a2Ef a_a2Eg b_a2Eh)
        (y_a572 :: Prod f_a2Ef a_a2Eg b_a2Eh) ->
        case == @(Prod f_a2Ef a_a2Eg b_a2Eh) $dEq_a570 x_a571 y_a572 of {
          False -> GHC.Types.True;
          True -> GHC.Types.False
        }
end Rec }

Rec {
-- RHS size: {terms: 37, types: 23, coercions: 0, joins: 0/0}
Main.$fFoldableFList [InlPrag=CONLIKE]
  :: forall (f :: * -> *). Foldable f => Foldable (FList f)
[LclIdX[DFunId],
 Unf=DFun: \ (@(f_a1tB :: * -> *)) (v_B1 :: Foldable f_a1tB) ->
       Data.Foldable.C:Foldable TYPE: FList f_a1tB
                                $cfold_a2zd @f_a1tB v_B1
                                $cfoldMap_a2zs @f_a1tB v_B1
                                $cfoldMap'_a2A1 @f_a1tB v_B1
                                $cfoldr_a2Ah @f_a1tB v_B1
                                $cfoldr'_a2B2 @f_a1tB v_B1
                                $cfoldl_a2Bj @f_a1tB v_B1
                                $cfoldl'_a2BA @f_a1tB v_B1
                                $cfoldr1_a2BQ @f_a1tB v_B1
                                $cfoldl1_a2C3 @f_a1tB v_B1
                                $ctoList_a2Cg @f_a1tB v_B1
                                $cnull_a2Cr @f_a1tB v_B1
                                $clength_a2CO @f_a1tB v_B1
                                $celem_a2D1 @f_a1tB v_B1
                                $cmaximum_a2Dg @f_a1tB v_B1
                                $cminimum_a2Dv @f_a1tB v_B1
                                $csum_a2DK @f_a1tB v_B1
                                $cproduct_a2DZ @f_a1tB v_B1]
Main.$fFoldableFList
  = \ (@(f_a2z8 :: * -> *)) ($dFoldable_a2z9 :: Foldable f_a2z8) ->
      Data.Foldable.C:Foldable
        @(FList f_a2z8)
        ($cfold_a2zd @f_a2z8 $dFoldable_a2z9)
        ($cfoldMap_a2zs @f_a2z8 $dFoldable_a2z9)
        ($cfoldMap'_a2A1 @f_a2z8 $dFoldable_a2z9)
        ($cfoldr_a2Ah @f_a2z8 $dFoldable_a2z9)
        ($cfoldr'_a2B2 @f_a2z8 $dFoldable_a2z9)
        ($cfoldl_a2Bj @f_a2z8 $dFoldable_a2z9)
        ($cfoldl'_a2BA @f_a2z8 $dFoldable_a2z9)
        ($cfoldr1_a2BQ @f_a2z8 $dFoldable_a2z9)
        ($cfoldl1_a2C3 @f_a2z8 $dFoldable_a2z9)
        ($ctoList_a2Cg @f_a2z8 $dFoldable_a2z9)
        ($cnull_a2Cr @f_a2z8 $dFoldable_a2z9)
        ($clength_a2CO @f_a2z8 $dFoldable_a2z9)
        ($celem_a2D1 @f_a2z8 $dFoldable_a2z9)
        ($cmaximum_a2Dg @f_a2z8 $dFoldable_a2z9)
        ($cminimum_a2Dv @f_a2z8 $dFoldable_a2z9)
        ($csum_a2DK @f_a2z8 $dFoldable_a2z9)
        ($cproduct_a2DZ @f_a2z8 $dFoldable_a2z9)

-- RHS size: {terms: 17, types: 24, coercions: 25, joins: 0/0}
$csum_a2DK [Occ=LoopBreaker]
  :: forall (f :: * -> *) a. (Foldable f, Num a) => FList f a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 140 60}]
$csum_a2DK
  = \ (@(f_a2z8 :: * -> *))
      ($dFoldable_a2z9 :: Foldable f_a2z8)
      (@a_a2DO)
      ($dNum_a2DP :: Num a_a2DO) ->
      ((\ (@(t_a4WR :: * -> *))
          ($dFoldable_a4WS :: Foldable t_a4WR)
          (@a_a4WT)
          ($dNum_a4WU :: Num a_a4WT) ->
          Data.Foldable.foldMap'
            @t_a4WR
            $dFoldable_a4WS
            @(base:Data.Semigroup.Internal.Sum a_a4WT)
            @a_a4WT
            (base:Data.Semigroup.Internal.$fMonoidSum @a_a4WT $dNum_a4WU)
            ((\ (ds_a52f :: a_a4WT) -> ds_a52f)
             `cast` (<a_a4WT>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Sum[0]
                                              <a_a4WT>_R)
                     :: (a_a4WT -> a_a4WT)
                        ~R# (a_a4WT -> base:Data.Semigroup.Internal.Sum a_a4WT))))
       `cast` (forall (t :: <* -> *>_N).
               <Foldable t>_R
               %<'Many>_N ->_R forall (a :: <*>_N).
                               <Num a>_R
                               %<'Many>_N ->_R <t a>_R
                               %<'Many>_N ->_R base:Data.Semigroup.Internal.N:Sum[0] <a>_R
               :: (forall {t :: * -> *} {a}.
                   (Foldable t, Num a) =>
                   t a -> base:Data.Semigroup.Internal.Sum a)
                  ~R# (forall {t :: * -> *} {a}. (Foldable t, Num a) => t a -> a)))
        @(FList f_a2z8)
        (Main.$fFoldableFList @f_a2z8 $dFoldable_a2z9)
        @a_a2DO
        $dNum_a2DP

-- RHS size: {terms: 27, types: 33, coercions: 8, joins: 0/2}
$cminimum_a2Dv [Occ=LoopBreaker]
  :: forall (f :: * -> *) a. (Foldable f, Ord a) => FList f a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 280 60}]
$cminimum_a2Dv
  = \ (@(f_a2z8 :: * -> *))
      ($dFoldable_a2z9 :: Foldable f_a2z8)
      (@a_a2Dz)
      ($dOrd_a2DA :: Ord a_a2Dz) ->
      let {
        d_a52o :: a_a2Dz
        [LclId,
         Str=b,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 110 0}]
        d_a52o
          = errorWithoutStackTrace
              @GHC.Types.LiftedRep
              @a_a2Dz
              (GHC.Base.build
                 @Char
                 (\ (@b_a52t) ->
                    GHC.CString.unpackFoldrCString#
                      @b_a52t "minimum: empty structure"#)) } in
      let {
        g_a52v :: FList f_a2z8 a_a2Dz -> base:Data.Functor.Utils.Min a_a2Dz
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 100 0}]
        g_a52v
          = Data.Foldable.foldMap'
              @(FList f_a2z8)
              (Main.$fFoldableFList @f_a2z8 $dFoldable_a2z9)
              @(base:Data.Functor.Utils.Min a_a2Dz)
              @a_a2Dz
              (base:Data.Functor.Utils.$fMonoidMin @a_a2Dz $dOrd_a2DA)
              ((\ (ds_a53M :: a_a2Dz) -> GHC.Maybe.Just @a_a2Dz ds_a53M)
               `cast` (<a_a2Dz>_R
                       %<'Many>_N ->_R Sym (base:Data.Functor.Utils.N:Min[0]) <a_a2Dz>_N
                       :: (a_a2Dz -> GHC.Maybe.Maybe a_a2Dz)
                          ~R# (a_a2Dz -> base:Data.Functor.Utils.Min a_a2Dz))) } in
      \ (x_a53N :: FList f_a2z8 a_a2Dz) ->
        case (g_a52v x_a53N)
             `cast` (base:Data.Functor.Utils.N:Min[0] <a_a2Dz>_N
                     :: base:Data.Functor.Utils.Min a_a2Dz ~R# GHC.Maybe.Maybe a_a2Dz)
        of {
          GHC.Maybe.Nothing -> d_a52o;
          GHC.Maybe.Just v_a54h -> v_a54h
        }

-- RHS size: {terms: 27, types: 33, coercions: 8, joins: 0/2}
$cmaximum_a2Dg [Occ=LoopBreaker]
  :: forall (f :: * -> *) a. (Foldable f, Ord a) => FList f a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 280 60}]
$cmaximum_a2Dg
  = \ (@(f_a2z8 :: * -> *))
      ($dFoldable_a2z9 :: Foldable f_a2z8)
      (@a_a2Dk)
      ($dOrd_a2Dl :: Ord a_a2Dk) ->
      let {
        d_a54n :: a_a2Dk
        [LclId,
         Str=b,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 110 0}]
        d_a54n
          = errorWithoutStackTrace
              @GHC.Types.LiftedRep
              @a_a2Dk
              (GHC.Base.build
                 @Char
                 (\ (@b_a54o) ->
                    GHC.CString.unpackFoldrCString#
                      @b_a54o "maximum: empty structure"#)) } in
      let {
        g_a54p :: FList f_a2z8 a_a2Dk -> base:Data.Functor.Utils.Max a_a2Dk
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 100 0}]
        g_a54p
          = Data.Foldable.foldMap'
              @(FList f_a2z8)
              (Main.$fFoldableFList @f_a2z8 $dFoldable_a2z9)
              @(base:Data.Functor.Utils.Max a_a2Dk)
              @a_a2Dk
              (base:Data.Functor.Utils.$fMonoidMax @a_a2Dk $dOrd_a2Dl)
              ((\ (ds_a54r :: a_a2Dk) -> GHC.Maybe.Just @a_a2Dk ds_a54r)
               `cast` (<a_a2Dk>_R
                       %<'Many>_N ->_R Sym (base:Data.Functor.Utils.N:Max[0]) <a_a2Dk>_N
                       :: (a_a2Dk -> GHC.Maybe.Maybe a_a2Dk)
                          ~R# (a_a2Dk -> base:Data.Functor.Utils.Max a_a2Dk))) } in
      \ (x_a54s :: FList f_a2z8 a_a2Dk) ->
        case (g_a54p x_a54s)
             `cast` (base:Data.Functor.Utils.N:Max[0] <a_a2Dk>_N
                     :: base:Data.Functor.Utils.Max a_a2Dk ~R# GHC.Maybe.Maybe a_a2Dk)
        of {
          GHC.Maybe.Nothing -> d_a54n;
          GHC.Maybe.Just v_a54x -> v_a54x
        }

-- RHS size: {terms: 18, types: 23, coercions: 26, joins: 0/0}
$celem_a2D1 [Occ=LoopBreaker]
  :: forall (f :: * -> *) a.
     (Foldable f, Eq a) =>
     a -> FList f a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 150 60}]
$celem_a2D1
  = \ (@(f_a2z8 :: * -> *))
      ($dFoldable_a2z9 :: Foldable f_a2z8)
      (@a_a2D5)
      ($dEq_a2D6 :: Eq a_a2D5) ->
      ((\ (@(t_a54z :: * -> *))
          ($dFoldable_a54A :: Foldable t_a54z)
          (@a_a54B)
          ($dEq_a54C :: Eq a_a54B)
          (eta_a54D :: a_a54B) ->
          foldMap
            @t_a54z
            $dFoldable_a54A
            @base:Data.Semigroup.Internal.Any
            @a_a54B
            base:Data.Semigroup.Internal.$fMonoidAny
            ((== @a_a54B $dEq_a54C eta_a54D)
             `cast` (<a_a54B>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Any[0])
                     :: (a_a54B -> Bool)
                        ~R# (a_a54B -> base:Data.Semigroup.Internal.Any))))
       `cast` (forall (t :: <* -> *>_N).
               <Foldable t>_R
               %<'Many>_N ->_R forall (a :: <*>_N).
                               <Eq a>_R
                               %<'Many>_N ->_R <a>_R
                               %<'Many>_N ->_R <t a>_R
                               %<'Many>_N ->_R base:Data.Semigroup.Internal.N:Any[0]
               :: (forall {t :: * -> *} {a}.
                   (Foldable t, Eq a) =>
                   a -> t a -> base:Data.Semigroup.Internal.Any)
                  ~R# (forall {t :: * -> *} {a}.
                       (Foldable t, Eq a) =>
                       a -> t a -> Bool)))
        @(FList f_a2z8)
        (Main.$fFoldableFList @f_a2z8 $dFoldable_a2z9)
        @a_a2D5
        $dEq_a2D6

-- RHS size: {terms: 17, types: 14, coercions: 0, joins: 0/0}
$clength_a2CO [Occ=LoopBreaker]
  :: forall (f :: * -> *) a. Foldable f => FList f a -> Int
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 111 0}]
$clength_a2CO
  = \ (@(f_a2z8 :: * -> *))
      ($dFoldable_a2z9 :: Foldable f_a2z8)
      (@a_a2CS) ->
      Data.Foldable.foldl'
        @(FList f_a2z8)
        (Main.$fFoldableFList @f_a2z8 $dFoldable_a2z9)
        @Int
        @a_a2CS
        (\ (c_a54K :: Int) _ [Occ=Dead] ->
           case c_a54K of { GHC.Types.I# x_a54N ->
           GHC.Types.I# (GHC.Prim.+# x_a54N 1#)
           })
        (GHC.Types.I# 0#)

-- RHS size: {terms: 21, types: 30, coercions: 0, joins: 0/1}
$cnull_a2Cr [Occ=LoopBreaker]
  :: forall (f :: * -> *) a. Foldable f => FList f a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30] 180 60}]
$cnull_a2Cr
  = \ (@(f_a2z8 :: * -> *))
      ($dFoldable_a2z9 :: Foldable f_a2z8)
      (@a_a2Cv) ->
      let {
        $dFoldable_a2CI :: Foldable (FList f_a2z8)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dFoldable_a2CI = Main.$fFoldableFList @f_a2z8 $dFoldable_a2z9 } in
      \ (ds_d4GV :: FList f_a2z8 a_a2Cv) ->
        case ds_d4GV of {
          FNil -> GHC.Types.True;
          FCons a1_a29o a2_a29p ->
            &&
              (null @f_a2z8 $dFoldable_a2z9 @a_a2Cv a1_a29o)
              (all
                 @f_a2z8
                 @(FList f_a2z8 a_a2Cv)
                 $dFoldable_a2z9
                 (null @(FList f_a2z8) $dFoldable_a2CI @a_a2Cv)
                 a2_a29p)
        }

-- RHS size: {terms: 16, types: 22, coercions: 0, joins: 0/1}
$ctoList_a2Cg [Occ=LoopBreaker]
  :: forall (f :: * -> *) a. Foldable f => FList f a -> [a]
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 110 60}]
$ctoList_a2Cg
  = \ (@(f_a2z8 :: * -> *))
      ($dFoldable_a2z9 :: Foldable f_a2z8)
      (@a_a2Ck) ->
      let {
        $dFoldable_a54Q :: Foldable (FList f_a2z8)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dFoldable_a54Q = Main.$fFoldableFList @f_a2z8 $dFoldable_a2z9 } in
      \ (t1_a54S :: FList f_a2z8 a_a2Ck) ->
        GHC.Base.build
          @a_a2Ck
          (\ (@b_a54T)
             (c_a54U [OS=OneShot] :: a_a2Ck -> b_a54T -> b_a54T)
             (n_a54V [OS=OneShot] :: b_a54T) ->
             foldr
               @(FList f_a2z8)
               $dFoldable_a54Q
               @a_a2Ck
               @b_a54T
               c_a54U
               n_a54V
               t1_a54S)

-- RHS size: {terms: 32, types: 36, coercions: 0, joins: 0/1}
$cfoldl1_a2C3 [Occ=LoopBreaker]
  :: forall (f :: * -> *) a.
     Foldable f =>
     (a -> a -> a) -> FList f a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 310 60}]
$cfoldl1_a2C3
  = \ (@(f_a2z8 :: * -> *))
      ($dFoldable_a2z9 :: Foldable f_a2z8)
      (@a_a2C7) ->
      let {
        $dFoldable_a54X :: Foldable (FList f_a2z8)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dFoldable_a54X = Main.$fFoldableFList @f_a2z8 $dFoldable_a2z9 } in
      \ (f_a54Z :: a_a2C7 -> a_a2C7 -> a_a2C7)
        (xs_a550 :: FList f_a2z8 a_a2C7) ->
        case foldl
               @(FList f_a2z8)
               $dFoldable_a54X
               @(GHC.Maybe.Maybe a_a2C7)
               @a_a2C7
               (\ (m_a551 :: GHC.Maybe.Maybe a_a2C7) (y_a552 :: a_a2C7) ->
                  GHC.Maybe.Just
                    @a_a2C7
                    (case m_a551 of {
                       GHC.Maybe.Nothing -> y_a552;
                       GHC.Maybe.Just x_a555 -> f_a54Z x_a555 y_a552
                     }))
               (GHC.Maybe.Nothing @a_a2C7)
               xs_a550
        of {
          GHC.Maybe.Nothing ->
            errorWithoutStackTrace
              @GHC.Types.LiftedRep
              @a_a2C7
              (GHC.Base.build
                 @Char
                 (\ (@b_a558) ->
                    GHC.CString.unpackFoldrCString#
                      @b_a558 "foldl1: empty structure"#));
          GHC.Maybe.Just v_a559 -> v_a559
        }

-- RHS size: {terms: 32, types: 36, coercions: 0, joins: 0/1}
$cfoldr1_a2BQ [Occ=LoopBreaker]
  :: forall (f :: * -> *) a.
     Foldable f =>
     (a -> a -> a) -> FList f a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 310 60}]
$cfoldr1_a2BQ
  = \ (@(f_a2z8 :: * -> *))
      ($dFoldable_a2z9 :: Foldable f_a2z8)
      (@a_a2BU) ->
      let {
        $dFoldable_a55d :: Foldable (FList f_a2z8)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dFoldable_a55d = Main.$fFoldableFList @f_a2z8 $dFoldable_a2z9 } in
      \ (f_a55f :: a_a2BU -> a_a2BU -> a_a2BU)
        (xs_a55g :: FList f_a2z8 a_a2BU) ->
        case foldr
               @(FList f_a2z8)
               $dFoldable_a55d
               @a_a2BU
               @(GHC.Maybe.Maybe a_a2BU)
               (\ (x_a55h :: a_a2BU) (m_a55i :: GHC.Maybe.Maybe a_a2BU) ->
                  GHC.Maybe.Just
                    @a_a2BU
                    (case m_a55i of {
                       GHC.Maybe.Nothing -> x_a55h;
                       GHC.Maybe.Just y_a55l -> f_a55f x_a55h y_a55l
                     }))
               (GHC.Maybe.Nothing @a_a2BU)
               xs_a55g
        of {
          GHC.Maybe.Nothing ->
            errorWithoutStackTrace
              @GHC.Types.LiftedRep
              @a_a2BU
              (GHC.Base.build
                 @Char
                 (\ (@b_a55o) ->
                    GHC.CString.unpackFoldrCString#
                      @b_a55o "foldr1: empty structure"#));
          GHC.Maybe.Just v_a55p -> v_a55p
        }

-- RHS size: {terms: 25, types: 28, coercions: 0, joins: 0/1}
$cfoldl'_a2BA [Occ=LoopBreaker]
  :: forall (f :: * -> *) b a.
     Foldable f =>
     (b -> a -> b) -> b -> FList f a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 210 60}]
$cfoldl'_a2BA
  = \ (@(f_a2z8 :: * -> *))
      ($dFoldable_a2z9 :: Foldable f_a2z8)
      (@b_a2BF)
      (@a_a2BG) ->
      let {
        $dFoldable_a55t :: Foldable (FList f_a2z8)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dFoldable_a55t = Main.$fFoldableFList @f_a2z8 $dFoldable_a2z9 } in
      \ (f_a55w :: b_a2BF -> a_a2BG -> b_a2BF)
        (z0_a55x :: b_a2BF)
        (xs_a55y :: FList f_a2z8 a_a2BG) ->
        foldr
          @(FList f_a2z8)
          $dFoldable_a55t
          @a_a2BG
          @(b_a2BF -> b_a2BF)
          (\ (ds_a55z :: a_a2BG)
             (ds1_a55A :: b_a2BF -> b_a2BF)
             (v_a55B [OS=OneShot] :: b_a2BF) ->
             case v_a55B of z_a55C { __DEFAULT ->
             ds1_a55A (f_a55w z_a55C ds_a55z)
             })
          (id @b_a2BF)
          xs_a55y
          z0_a55x

-- RHS size: {terms: 21, types: 28, coercions: 10, joins: 0/1}
$cfoldl_a2Bj [Occ=LoopBreaker]
  :: forall (f :: * -> *) b a.
     Foldable f =>
     (b -> a -> b) -> b -> FList f a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 190 60}]
$cfoldl_a2Bj
  = \ (@(f_a2z8 :: * -> *))
      ($dFoldable_a2z9 :: Foldable f_a2z8)
      (@b_a2Bo)
      (@a_a2Bp) ->
      let {
        $dFoldable_a55F :: Foldable (FList f_a2z8)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dFoldable_a55F = Main.$fFoldableFList @f_a2z8 $dFoldable_a2z9 } in
      \ (eta_a55I :: b_a2Bo -> a_a2Bp -> b_a2Bo)
        (eta1_a55J :: b_a2Bo)
        (eta2_a55K :: FList f_a2z8 a_a2Bp) ->
        ((foldMap
            @(FList f_a2z8)
            $dFoldable_a55F
            @(base:Data.Semigroup.Internal.Dual
                (base:Data.Semigroup.Internal.Endo b_a2Bo))
            @a_a2Bp
            (base:Data.Semigroup.Internal.$fMonoidDual
               @(base:Data.Semigroup.Internal.Endo b_a2Bo)
               (base:Data.Semigroup.Internal.$fMonoidEndo @b_a2Bo))
            ((\ (x_a55N :: a_a2Bp) (y_a55O :: b_a2Bo) ->
                eta_a55I y_a55O x_a55N)
             `cast` (<a_a2Bp>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Dual[0]
                                              (base:Data.Semigroup.Internal.N:Endo[0] <b_a2Bo>_R))
                     :: (a_a2Bp -> b_a2Bo -> b_a2Bo)
                        ~R# (a_a2Bp
                             -> base:Data.Semigroup.Internal.Dual
                                  (base:Data.Semigroup.Internal.Endo b_a2Bo))))
            eta2_a55K)
         `cast` (base:Data.Semigroup.Internal.N:Dual[0]
                     (base:Data.Semigroup.Internal.N:Endo[0] <b_a2Bo>_R)
                 :: base:Data.Semigroup.Internal.Dual
                      (base:Data.Semigroup.Internal.Endo b_a2Bo)
                    ~R# (b_a2Bo -> b_a2Bo)))
          eta1_a55J

-- RHS size: {terms: 25, types: 28, coercions: 0, joins: 0/1}
$cfoldr'_a2B2 [Occ=LoopBreaker]
  :: forall (f :: * -> *) a b.
     Foldable f =>
     (a -> b -> b) -> b -> FList f a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 210 60}]
$cfoldr'_a2B2
  = \ (@(f_a2z8 :: * -> *))
      ($dFoldable_a2z9 :: Foldable f_a2z8)
      (@a_a2B7)
      (@b_a2B8) ->
      let {
        $dFoldable_a55U :: Foldable (FList f_a2z8)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dFoldable_a55U = Main.$fFoldableFList @f_a2z8 $dFoldable_a2z9 } in
      \ (f_a55X :: a_a2B7 -> b_a2B8 -> b_a2B8)
        (z0_a55Y :: b_a2B8)
        (xs_a55Z :: FList f_a2z8 a_a2B7) ->
        foldl
          @(FList f_a2z8)
          $dFoldable_a55U
          @(b_a2B8 -> b_a2B8)
          @a_a2B7
          (\ (ds_a560 :: b_a2B8 -> b_a2B8)
             (ds1_a561 :: a_a2B7)
             (v_a562 [OS=OneShot] :: b_a2B8) ->
             case v_a562 of z_a563 { __DEFAULT ->
             ds_a560 (f_a55X ds1_a561 z_a563)
             })
          (id @b_a2B8)
          xs_a55Z
          z0_a55Y

-- RHS size: {terms: 30, types: 42, coercions: 0, joins: 0/1}
$cfoldr_a2Ah [Occ=LoopBreaker]
  :: forall (f :: * -> *) a b.
     Foldable f =>
     (a -> b -> b) -> b -> FList f a -> b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60] 250 60}]
$cfoldr_a2Ah
  = \ (@(f_a2z8 :: * -> *))
      ($dFoldable_a2z9 :: Foldable f_a2z8)
      (@a_a2Am)
      (@b_a2An) ->
      let {
        $dFoldable_a2AU :: Foldable (FList f_a2z8)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dFoldable_a2AU = Main.$fFoldableFList @f_a2z8 $dFoldable_a2z9 } in
      \ (f_a298 :: a_a2Am -> b_a2An -> b_a2An)
        (z_a299 :: b_a2An)
        (ds_d4GG :: FList f_a2z8 a_a2Am) ->
        case ds_d4GG of {
          FNil -> z_a299;
          FCons a1_a29c a2_a29d ->
            foldr
              @f_a2z8
              $dFoldable_a2z9
              @a_a2Am
              @b_a2An
              f_a298
              (foldr
                 @f_a2z8
                 $dFoldable_a2z9
                 @(FList f_a2z8 a_a2Am)
                 @b_a2An
                 (\ (b3_a29i :: FList f_a2z8 a_a2Am) (b4_a29j :: b_a2An) ->
                    foldr
                      @(FList f_a2z8)
                      $dFoldable_a2AU
                      @a_a2Am
                      @b_a2An
                      f_a298
                      b4_a29j
                      b3_a29i)
                 z_a299
                 a2_a29d)
              a1_a29c
        }

-- RHS size: {terms: 23, types: 25, coercions: 0, joins: 0/2}
$cfoldMap'_a2A1 [Occ=LoopBreaker]
  :: forall (f :: * -> *) m a.
     (Foldable f, Monoid m) =>
     (a -> m) -> FList f a -> m
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 60] 210 60}]
$cfoldMap'_a2A1
  = \ (@(f_a2z8 :: * -> *))
      ($dFoldable_a2z9 :: Foldable f_a2z8)
      (@m_a2A6)
      (@a_a2A7)
      ($dMonoid_a2A8 :: Monoid m_a2A6) ->
      let {
        $dFoldable_a565 :: Foldable (FList f_a2z8)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dFoldable_a565 = Main.$fFoldableFList @f_a2z8 $dFoldable_a2z9 } in
      \ (eta_a569 :: a_a2A7 -> m_a2A6) ->
        let {
          $dSemigroup_a56a :: Semigroup m_a2A6
          [LclId,
           Unf=Unf{Src=<vanilla>, TopLvl=False,
                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                   Guidance=IF_ARGS [] 20 0}]
          $dSemigroup_a56a = GHC.Base.$p1Monoid @m_a2A6 $dMonoid_a2A8 } in
        Data.Foldable.foldl'
          @(FList f_a2z8)
          $dFoldable_a565
          @m_a2A6
          @a_a2A7
          (\ (acc_a56b :: m_a2A6) (a1_a56c :: a_a2A7) ->
             <> @m_a2A6 $dSemigroup_a56a acc_a56b (eta_a569 a1_a56c))
          (mempty @m_a2A6 $dMonoid_a2A8)

-- RHS size: {terms: 31, types: 40, coercions: 0, joins: 0/1}
$cfoldMap_a2zs [Occ=LoopBreaker]
  :: forall (f :: * -> *) m a.
     (Foldable f, Monoid m) =>
     (a -> m) -> FList f a -> m
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 60] 270 60}]
$cfoldMap_a2zs
  = \ (@(f_a2z8 :: * -> *))
      ($dFoldable_a2z9 :: Foldable f_a2z8)
      (@m_a2zx)
      (@a_a2zy)
      ($dMonoid_a2zz :: Monoid m_a2zx) ->
      let {
        $dFoldable_a2zS :: Foldable (FList f_a2z8)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dFoldable_a2zS = Main.$fFoldableFList @f_a2z8 $dFoldable_a2z9 } in
      \ (f_a29k :: a_a2zy -> m_a2zx) (ds_d4GB :: FList f_a2z8 a_a2zy) ->
        case ds_d4GB of {
          FNil -> mempty @m_a2zx $dMonoid_a2zz;
          FCons a1_a29m a2_a29n ->
            mappend
              @m_a2zx
              $dMonoid_a2zz
              (foldMap
                 @f_a2z8
                 $dFoldable_a2z9
                 @m_a2zx
                 @a_a2zy
                 $dMonoid_a2zz
                 f_a29k
                 a1_a29m)
              (foldMap
                 @f_a2z8
                 $dFoldable_a2z9
                 @m_a2zx
                 @(FList f_a2z8 a_a2zy)
                 $dMonoid_a2zz
                 (foldMap
                    @(FList f_a2z8)
                    $dFoldable_a2zS
                    @m_a2zx
                    @a_a2zy
                    $dMonoid_a2zz
                    f_a29k)
                 a2_a29n)
        }

-- RHS size: {terms: 17, types: 24, coercions: 25, joins: 0/0}
$cproduct_a2DZ [Occ=LoopBreaker]
  :: forall (f :: * -> *) a. (Foldable f, Num a) => FList f a -> a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 140 60}]
$cproduct_a2DZ
  = \ (@(f_a2z8 :: * -> *))
      ($dFoldable_a2z9 :: Foldable f_a2z8)
      (@a_a2E3)
      ($dNum_a2E4 :: Num a_a2E3) ->
      ((\ (@(t_a56d :: * -> *))
          ($dFoldable_a56e :: Foldable t_a56d)
          (@a_a56f)
          ($dNum_a56g :: Num a_a56f) ->
          Data.Foldable.foldMap'
            @t_a56d
            $dFoldable_a56e
            @(base:Data.Semigroup.Internal.Product a_a56f)
            @a_a56f
            (base:Data.Semigroup.Internal.$fMonoidProduct @a_a56f $dNum_a56g)
            ((\ (ds_a56i :: a_a56f) -> ds_a56i)
             `cast` (<a_a56f>_R
                     %<'Many>_N ->_R Sym (base:Data.Semigroup.Internal.N:Product[0]
                                              <a_a56f>_R)
                     :: (a_a56f -> a_a56f)
                        ~R# (a_a56f -> base:Data.Semigroup.Internal.Product a_a56f))))
       `cast` (forall (t :: <* -> *>_N).
               <Foldable t>_R
               %<'Many>_N ->_R forall (a :: <*>_N).
                               <Num a>_R
                               %<'Many>_N ->_R <t a>_R
                               %<'Many>_N ->_R base:Data.Semigroup.Internal.N:Product[0] <a>_R
               :: (forall {t :: * -> *} {a}.
                   (Foldable t, Num a) =>
                   t a -> base:Data.Semigroup.Internal.Product a)
                  ~R# (forall {t :: * -> *} {a}. (Foldable t, Num a) => t a -> a)))
        @(FList f_a2z8)
        (Main.$fFoldableFList @f_a2z8 $dFoldable_a2z9)
        @a_a2E3
        $dNum_a2E4

-- RHS size: {terms: 9, types: 13, coercions: 0, joins: 0/0}
$cfold_a2zd [Occ=LoopBreaker]
  :: forall (f :: * -> *) m. (Foldable f, Monoid m) => FList f m -> m
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 60 0}]
$cfold_a2zd
  = \ (@(f_a2z8 :: * -> *))
      ($dFoldable_a2z9 :: Foldable f_a2z8)
      (@m_a2zj)
      ($dMonoid_a2zk :: Monoid m_a2zj) ->
      foldMap
        @(FList f_a2z8)
        (Main.$fFoldableFList @f_a2z8 $dFoldable_a2z9)
        @m_a2zj
        @m_a2zj
        $dMonoid_a2zk
        (id @m_a2zj)
end Rec }

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
$cp2Traversable_a45l
  :: forall {f :: * -> *}. Traversable f => Foldable (FList f)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30] 40 0}]
$cp2Traversable_a45l
  = \ (@(f_a45c :: * -> *))
      ($dTraversable_a45d :: Traversable f_a45c) ->
      Main.$fFoldableFList
        @f_a45c
        (Data.Traversable.$p2Traversable @f_a45c $dTraversable_a45d)

Rec {
-- RHS size: {terms: 7, types: 8, coercions: 0, joins: 0/0}
Main.$fFunctorFList [InlPrag=CONLIKE]
  :: forall (f :: * -> *). Functor f => Functor (FList f)
[LclIdX[DFunId],
 Unf=DFun: \ (@(f_a1ts :: * -> *)) (v_B1 :: Functor f_a1ts) ->
       GHC.Base.C:Functor TYPE: FList f_a1ts
                          $cfmap_a2ya @f_a1ts v_B1
                          $c<$_a2yC @f_a1ts v_B1]
Main.$fFunctorFList
  = \ (@(f_a2y7 :: * -> *)) ($dFunctor_a2y8 :: Functor f_a2y7) ->
      GHC.Base.C:Functor
        @(FList f_a2y7)
        ($cfmap_a2ya @f_a2y7 $dFunctor_a2y8)
        ($c<$_a2yC @f_a2y7 $dFunctor_a2y8)

-- RHS size: {terms: 27, types: 44, coercions: 0, joins: 0/1}
$c<$_a2yC [Occ=LoopBreaker]
  :: forall (f :: * -> *) a b.
     Functor f =>
     a -> FList f b -> FList f a
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60] 210 60}]
$c<$_a2yC
  = \ (@(f_a2y7 :: * -> *))
      ($dFunctor_a2y8 :: Functor f_a2y7)
      (@a_a2yH)
      (@b_a2yI) ->
      let {
        $dFunctor_a2z1 :: Functor (FList f_a2y7)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dFunctor_a2z1 = Main.$fFunctorFList @f_a2y7 $dFunctor_a2y8 } in
      \ (z_a293 :: a_a2yH) (ds_d4Gs :: FList f_a2y7 b_a2yI) ->
        case ds_d4Gs of {
          FNil -> Main.FNil @f_a2y7 @a_a2yH;
          FCons a1_a295 a2_a296 ->
            Main.FCons
              @f_a2y7
              @a_a2yH
              (<$ @f_a2y7 $dFunctor_a2y8 @a_a2yH @b_a2yI z_a293 a1_a295)
              (fmap
                 @f_a2y7
                 $dFunctor_a2y8
                 @(FList f_a2y7 b_a2yI)
                 @(FList f_a2y7 a_a2yH)
                 (\ (b1_a297 :: FList f_a2y7 b_a2yI) ->
                    <$ @(FList f_a2y7) $dFunctor_a2z1 @a_a2yH @b_a2yI z_a293 b1_a297)
                 a2_a296)
        }

-- RHS size: {terms: 27, types: 45, coercions: 0, joins: 0/1}
$cfmap_a2ya [Occ=LoopBreaker]
  :: forall (f :: * -> *) a b.
     Functor f =>
     (a -> b) -> FList f a -> FList f b
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60] 210 60}]
$cfmap_a2ya
  = \ (@(f_a2y7 :: * -> *))
      ($dFunctor_a2y8 :: Functor f_a2y7)
      (@a_a2yd)
      (@b_a2ye) ->
      let {
        $dFunctor_a2yx :: Functor (FList f_a2y7)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dFunctor_a2yx = Main.$fFunctorFList @f_a2y7 $dFunctor_a2y8 } in
      \ (f_a28Y :: a_a2yd -> b_a2ye) (ds_d4Gn :: FList f_a2y7 a_a2yd) ->
        case ds_d4Gn of {
          FNil -> Main.FNil @f_a2y7 @b_a2ye;
          FCons a1_a290 a2_a291 ->
            Main.FCons
              @f_a2y7
              @b_a2ye
              (fmap @f_a2y7 $dFunctor_a2y8 @a_a2yd @b_a2ye f_a28Y a1_a290)
              (fmap
                 @f_a2y7
                 $dFunctor_a2y8
                 @(FList f_a2y7 a_a2yd)
                 @(FList f_a2y7 b_a2ye)
                 (\ (b1_a292 :: FList f_a2y7 a_a2yd) ->
                    fmap @(FList f_a2y7) $dFunctor_a2yx @a_a2yd @b_a2ye f_a28Y b1_a292)
                 a2_a291)
        }
end Rec }

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
$cp1Traversable_a45h
  :: forall {f :: * -> *}. Traversable f => Functor (FList f)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30] 40 0}]
$cp1Traversable_a45h
  = \ (@(f_a45c :: * -> *))
      ($dTraversable_a45d :: Traversable f_a45c) ->
      Main.$fFunctorFList
        @f_a45c
        (Data.Traversable.$p1Traversable @f_a45c $dTraversable_a45d)

Rec {
-- RHS size: {terms: 15, types: 12, coercions: 0, joins: 0/0}
Main.$fTraversableFList [InlPrag=CONLIKE]
  :: forall (f :: * -> *). Traversable f => Traversable (FList f)
[LclIdX[DFunId],
 Unf=DFun: \ (@(f_aUn :: * -> *)) (v_B1 :: Traversable f_aUn) ->
       Data.Traversable.C:Traversable TYPE: FList f_aUn
                                      $cp1Traversable_a45h @f_aUn v_B1
                                      $cp2Traversable_a45l @f_aUn v_B1
                                      $ctraverse_a45r @f_aUn v_B1
                                      $csequenceA_a45N @f_aUn v_B1
                                      $cmapM_a467 @f_aUn v_B1
                                      $csequence_a46t @f_aUn v_B1]
Main.$fTraversableFList
  = \ (@(f_a45c :: * -> *))
      ($dTraversable_a45d :: Traversable f_a45c) ->
      Data.Traversable.C:Traversable
        @(FList f_a45c)
        ($cp1Traversable_a45h @f_a45c $dTraversable_a45d)
        ($cp2Traversable_a45l @f_a45c $dTraversable_a45d)
        ($ctraverse_a45r @f_a45c $dTraversable_a45d)
        ($csequenceA_a45N @f_a45c $dTraversable_a45d)
        ($cmapM_a467 @f_a45c $dTraversable_a45d)
        ($csequence_a46t @f_a45c $dTraversable_a45d)

-- RHS size: {terms: 11, types: 17, coercions: 0, joins: 0/0}
$cmapM_a467 [Occ=LoopBreaker]
  :: forall (f :: * -> *) (m :: * -> *) a b.
     (Traversable f, Monad m) =>
     (a -> m b) -> FList f a -> m (FList f b)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 30] 70 0}]
$cmapM_a467
  = \ (@(f_a45c :: * -> *))
      ($dTraversable_a45d :: Traversable f_a45c)
      (@(m_a46d :: * -> *))
      (@a_a46e)
      (@b_a46f)
      ($dMonad_a46g :: Monad m_a46d) ->
      traverse
        @(FList f_a45c)
        (Main.$fTraversableFList @f_a45c $dTraversable_a45d)
        @m_a46d
        @a_a46e
        @b_a46f
        (GHC.Base.$p1Monad @m_a46d $dMonad_a46g)

-- RHS size: {terms: 10, types: 18, coercions: 0, joins: 0/0}
$csequenceA_a45N [Occ=LoopBreaker]
  :: forall (f :: * -> *) (f :: * -> *) a.
     (Traversable f, Applicative f) =>
     FList f (f a) -> f (FList f a)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 60 0}]
$csequenceA_a45N
  = \ (@(f_a45c :: * -> *))
      ($dTraversable_a45d :: Traversable f_a45c)
      (@(f_a45S :: * -> *))
      (@a_a45T)
      ($dApplicative_a45U :: Applicative f_a45S) ->
      traverse
        @(FList f_a45c)
        (Main.$fTraversableFList @f_a45c $dTraversable_a45d)
        @f_a45S
        @(f_a45S a_a45T)
        @a_a45T
        $dApplicative_a45U
        (id @(f_a45S a_a45T))

-- RHS size: {terms: 10, types: 15, coercions: 0, joins: 0/0}
$csequence_a46t [Occ=LoopBreaker]
  :: forall (f :: * -> *) (m :: * -> *) a.
     (Traversable f, Monad m) =>
     FList f (m a) -> m (FList f a)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 30] 70 0}]
$csequence_a46t
  = \ (@(f_a45c :: * -> *))
      ($dTraversable_a45d :: Traversable f_a45c)
      (@(m_a46y :: * -> *))
      (@a_a46z)
      ($dMonad_a46A :: Monad m_a46y) ->
      sequenceA
        @(FList f_a45c)
        (Main.$fTraversableFList @f_a45c $dTraversable_a45d)
        @m_a46y
        @a_a46z
        (GHC.Base.$p1Monad @m_a46y $dMonad_a46A)

-- RHS size: {terms: 23, types: 46, coercions: 0, joins: 0/3}
$ctraverse_a45r [Occ=LoopBreaker]
  :: forall (f :: * -> *) (f :: * -> *) a b.
     (Traversable f, Applicative f) =>
     (a -> f b) -> FList f a -> f (FList f b)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 190 60}]
$ctraverse_a45r
  = \ (@(f_a45c :: * -> *))
      ($dTraversable_a45d :: Traversable f_a45c)
      (@(f_a45x :: * -> *))
      (@a_a45y)
      (@b_a45z)
      ($dApplicative_a45A :: Applicative f_a45x) ->
      let {
        $dTraversable_a56I :: Traversable (FList f_a45c)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dTraversable_a56I
          = Main.$fTraversableFList @f_a45c $dTraversable_a45d } in
      \ (eta1_a56N :: a_a45y -> f_a45x b_a45z) ->
        let {
          f1_a56O
            :: FList f_a45c (f_a45x b_a45z) -> f_a45x (FList f_a45c b_a45z)
          [LclId,
           Unf=Unf{Src=<vanilla>, TopLvl=False,
                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                   Guidance=IF_ARGS [] 30 0}]
          f1_a56O
            = sequenceA
                @(FList f_a45c)
                $dTraversable_a56I
                @f_a45x
                @b_a45z
                $dApplicative_a45A } in
        let {
          g_a56P :: FList f_a45c a_a45y -> FList f_a45c (f_a45x b_a45z)
          [LclId,
           Unf=Unf{Src=<vanilla>, TopLvl=False,
                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                   Guidance=IF_ARGS [] 50 0}]
          g_a56P
            = fmap
                @(FList f_a45c)
                (Data.Traversable.$p1Traversable
                   @(FList f_a45c) $dTraversable_a56I)
                @a_a45y
                @(f_a45x b_a45z)
                eta1_a56N } in
        \ (x_a56Q :: FList f_a45c a_a45y) -> f1_a56O (g_a56P x_a56Q)
end Rec }

Rec {
-- RHS size: {terms: 11, types: 19, coercions: 0, joins: 0/0}
Main.$fEqFix [InlPrag=CONLIKE]
  :: forall a (f :: * -> *).
     (Eq a, forall a. Eq a => Eq (f a)) =>
     Eq (Fix f a)
[LclIdX[DFunId],
 Unf=DFun: \ (@a_a1ik)
             (@(f_a1il :: * -> *))
             (v_B1 :: Eq a_a1ik)
             (v_B2 :: forall a. Eq a => Eq (f_a1il a)) ->
       GHC.Classes.C:Eq TYPE: Fix f_a1il a_a1ik
                        $c==_a2xP @a_a1ik @f_a1il v_B1 v_B2
                        $c/=_a2xY @a_a1ik @f_a1il v_B1 v_B2]
Main.$fEqFix
  = \ (@a_a2xK)
      (@(f_a2xL :: * -> *))
      ($dEq_a2xM :: Eq a_a2xK)
      (df_a2xN :: forall a. Eq a => Eq (f_a2xL a)) ->
      GHC.Classes.C:Eq
        @(Fix f_a2xL a_a2xK)
        ($c==_a2xP @a_a2xK @f_a2xL $dEq_a2xM df_a2xN)
        ($c/=_a2xY @a_a2xK @f_a2xL $dEq_a2xM df_a2xN)

-- RHS size: {terms: 19, types: 31, coercions: 0, joins: 0/1}
$c/=_a2xY [Occ=LoopBreaker]
  :: forall a (f :: * -> *).
     (Eq a, forall a. Eq a => Eq (f a)) =>
     Fix f a -> Fix f a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 120 60}]
$c/=_a2xY
  = \ (@a_a2xK)
      (@(f_a2xL :: * -> *))
      ($dEq_a2xM :: Eq a_a2xK)
      (df_a2xN :: forall a. Eq a => Eq (f_a2xL a)) ->
      let {
        $dEq_a570 :: Eq (Fix f_a2xL a_a2xK)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 30 0}]
        $dEq_a570 = Main.$fEqFix @a_a2xK @f_a2xL $dEq_a2xM df_a2xN } in
      \ (x_a571 :: Fix f_a2xL a_a2xK) (y_a572 :: Fix f_a2xL a_a2xK) ->
        case == @(Fix f_a2xL a_a2xK) $dEq_a570 x_a571 y_a572 of {
          False -> GHC.Types.True;
          True -> GHC.Types.False
        }

-- RHS size: {terms: 23, types: 59, coercions: 0, joins: 0/2}
$c==_a2xP [Occ=LoopBreaker]
  :: forall a (f :: * -> *).
     (Eq a, forall a. Eq a => Eq (f a)) =>
     Fix f a -> Fix f a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 60] 150 60}]
$c==_a2xP
  = \ (@a_a2xK)
      (@(f_a2xL :: * -> *))
      ($dEq_a2xM :: Eq a_a2xK)
      (df_a2xN :: forall a. Eq a => Eq (f_a2xL a)) ->
      let {
        $dEq_a4yu :: Eq (Fix f_a2xL a_a2xK)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 30 0}]
        $dEq_a4yu = Main.$fEqFix @a_a2xK @f_a2xL $dEq_a2xM df_a2xN } in
      let {
        $dEq_a2xW :: Eq (f_a2xL (Fix f_a2xL a_a2xK))
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dEq_a2xW = df_a2xN @(Fix f_a2xL a_a2xK) $dEq_a4yu } in
      \ (ds_d4Ge :: Fix f_a2xL a_a2xK) (ds_d4Gf :: Fix f_a2xL a_a2xK) ->
        case ds_d4Ge of { MkFix a1_a28W ->
        case ds_d4Gf of { MkFix b1_a28X ->
        == @(f_a2xL (Fix f_a2xL a_a2xK)) $dEq_a2xW a1_a28W b1_a28X
        }
        }
end Rec }

Rec {
-- RHS size: {terms: 14, types: 21, coercions: 0, joins: 0/0}
Main.$fShowFix [InlPrag=CONLIKE]
  :: forall a (f :: * -> *).
     (Show a, forall a. Show a => Show (f a)) =>
     Show (Fix f a)
[LclIdX[DFunId],
 Unf=DFun: \ (@a_a1ih)
             (@(f_a1ii :: * -> *))
             (v_B1 :: Show a_a1ih)
             (v_B2 :: forall a. Show a => Show (f_a1ii a)) ->
       GHC.Show.C:Show TYPE: Fix f_a1ii a_a1ih
                       $cshowsPrec_a2xh @a_a1ih @f_a1ii v_B1 v_B2
                       $cshow_a2xu @a_a1ih @f_a1ii v_B1 v_B2
                       $cshowList_a2xB @a_a1ih @f_a1ii v_B1 v_B2]
Main.$fShowFix
  = \ (@a_a2xc)
      (@(f_a2xd :: * -> *))
      ($dShow_a2xe :: Show a_a2xc)
      (df_a2xf :: forall a. Show a => Show (f_a2xd a)) ->
      GHC.Show.C:Show
        @(Fix f_a2xd a_a2xc)
        ($cshowsPrec_a2xh @a_a2xc @f_a2xd $dShow_a2xe df_a2xf)
        ($cshow_a2xu @a_a2xc @f_a2xd $dShow_a2xe df_a2xf)
        ($cshowList_a2xB @a_a2xc @f_a2xd $dShow_a2xe df_a2xf)

-- RHS size: {terms: 15, types: 27, coercions: 0, joins: 0/1}
$cshow_a2xu [Occ=LoopBreaker]
  :: forall a (f :: * -> *).
     (Show a, forall a. Show a => Show (f a)) =>
     Fix f a -> String
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 110 60}]
$cshow_a2xu
  = \ (@a_a2xc)
      (@(f_a2xd :: * -> *))
      ($dShow_a2xe :: Show a_a2xc)
      (df_a2xf :: forall a. Show a => Show (f_a2xd a)) ->
      let {
        $dShow_a56X :: Show (Fix f_a2xd a_a2xc)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 30 0}]
        $dShow_a56X
          = Main.$fShowFix @a_a2xc @f_a2xd $dShow_a2xe df_a2xf } in
      \ (x_a56Y :: Fix f_a2xd a_a2xc) ->
        showsPrec
          @(Fix f_a2xd a_a2xc)
          $dShow_a56X
          (GHC.Types.I# 0#)
          x_a56Y
          (GHC.Types.[] @Char)

-- RHS size: {terms: 17, types: 32, coercions: 0, joins: 0/1}
$cshowList_a2xB [Occ=LoopBreaker]
  :: forall a (f :: * -> *).
     (Show a, forall a. Show a => Show (f a)) =>
     [Fix f a] -> ShowS
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 140 60}]
$cshowList_a2xB
  = \ (@a_a2xc)
      (@(f_a2xd :: * -> *))
      ($dShow_a2xe :: Show a_a2xc)
      (df_a2xf :: forall a. Show a => Show (f_a2xd a)) ->
      let {
        $dShow_a56S :: Show (Fix f_a2xd a_a2xc)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 30 0}]
        $dShow_a56S
          = Main.$fShowFix @a_a2xc @f_a2xd $dShow_a2xe df_a2xf } in
      \ (ls_a56T :: [Fix f_a2xd a_a2xc]) (s_a56U :: String) ->
        GHC.Show.showList__
          @(Fix f_a2xd a_a2xc)
          (showsPrec @(Fix f_a2xd a_a2xc) $dShow_a56S (GHC.Types.I# 0#))
          ls_a56T
          s_a56U

-- RHS size: {terms: 31, types: 51, coercions: 0, joins: 0/2}
$cshowsPrec_a2xh [Occ=LoopBreaker]
  :: forall a (f :: * -> *).
     (Show a, forall a. Show a => Show (f a)) =>
     Int -> Fix f a -> ShowS
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 60] 330 60}]
$cshowsPrec_a2xh
  = \ (@a_a2xc)
      (@(f_a2xd :: * -> *))
      ($dShow_a2xe :: Show a_a2xc)
      (df_a2xf :: forall a. Show a => Show (f_a2xd a)) ->
      let {
        $dShow_a4yb :: Show (Fix f_a2xd a_a2xc)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 30 0}]
        $dShow_a4yb
          = Main.$fShowFix @a_a2xc @f_a2xd $dShow_a2xe df_a2xf } in
      let {
        $dShow_a2xs :: Show (f_a2xd (Fix f_a2xd a_a2xc))
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dShow_a2xs = df_a2xf @(Fix f_a2xd a_a2xc) $dShow_a4yb } in
      \ (a_a28U :: Int) (ds_d4G1 :: Fix f_a2xd a_a2xc) ->
        case ds_d4G1 of { MkFix b1_a28V ->
        showParen
          (>= @Int GHC.Classes.$fOrdInt a_a28U (GHC.Types.I# 11#))
          (. @String
             @String
             @String
             (showString (GHC.CString.unpackCString# "MkFix "#))
             (showsPrec
                @(f_a2xd (Fix f_a2xd a_a2xc))
                $dShow_a2xs
                (GHC.Types.I# 11#)
                b1_a28V))
        }
end Rec }

Rec {
-- RHS size: {terms: 11, types: 18, coercions: 0, joins: 0/0}
Main.$fEqFList [InlPrag=CONLIKE]
  :: forall a (f :: * -> *).
     (Eq a, forall a. Eq a => Eq (f a)) =>
     Eq (FList f a)
[LclIdX[DFunId],
 Unf=DFun: \ (@a_a1ie)
             (@(f_a1if :: * -> *))
             (v_B1 :: Eq a_a1ie)
             (v_B2 :: forall a. Eq a => Eq (f_a1if a)) ->
       GHC.Classes.C:Eq TYPE: FList f_a1if a_a1ie
                        $c==_a2wF @a_a1ie @f_a1if v_B1 v_B2
                        $c/=_a2x3 @a_a1ie @f_a1if v_B1 v_B2]
Main.$fEqFList
  = \ (@a_a2wA)
      (@(f_a2wB :: * -> *))
      ($dEq_a2wC :: Eq a_a2wA)
      (df_a2wD :: forall a. Eq a => Eq (f_a2wB a)) ->
      GHC.Classes.C:Eq
        @(FList f_a2wB a_a2wA)
        ($c==_a2wF @a_a2wA @f_a2wB $dEq_a2wC df_a2wD)
        ($c/=_a2x3 @a_a2wA @f_a2wB $dEq_a2wC df_a2wD)

-- RHS size: {terms: 19, types: 27, coercions: 0, joins: 0/1}
$c/=_a2x3 [Occ=LoopBreaker]
  :: forall a (f :: * -> *).
     (Eq a, forall a. Eq a => Eq (f a)) =>
     FList f a -> FList f a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 120 60}]
$c/=_a2x3
  = \ (@a_a2wA)
      (@(f_a2wB :: * -> *))
      ($dEq_a2wC :: Eq a_a2wA)
      (df_a2wD :: forall a. Eq a => Eq (f_a2wB a)) ->
      let {
        $dEq_a570 :: Eq (FList f_a2wB a_a2wA)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 30 0}]
        $dEq_a570 = Main.$fEqFList @a_a2wA @f_a2wB $dEq_a2wC df_a2wD } in
      \ (x_a571 :: FList f_a2wB a_a2wA)
        (y_a572 :: FList f_a2wB a_a2wA) ->
        case == @(FList f_a2wB a_a2wA) $dEq_a570 x_a571 y_a572 of {
          False -> GHC.Types.True;
          True -> GHC.Types.False
        }

-- RHS size: {terms: 55, types: 72, coercions: 0, joins: 0/3}
$c==_a2wF [Occ=LoopBreaker]
  :: forall a (f :: * -> *).
     (Eq a, forall a. Eq a => Eq (f a)) =>
     FList f a -> FList f a -> Bool
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 120] 393 60}]
$c==_a2wF
  = \ (@a_a2wA)
      (@(f_a2wB :: * -> *))
      ($dEq_a2wC :: Eq a_a2wA)
      (df_a2wD :: forall a. Eq a => Eq (f_a2wB a)) ->
      let {
        $dEq_a4xY :: Eq (FList f_a2wB a_a2wA)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 30 0}]
        $dEq_a4xY = Main.$fEqFList @a_a2wA @f_a2wB $dEq_a2wC df_a2wD } in
      let {
        $dEq_a2x0 :: Eq (f_a2wB (FList f_a2wB a_a2wA))
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dEq_a2x0 = df_a2wD @(FList f_a2wB a_a2wA) $dEq_a4xY } in
      let {
        $dEq_a2wY :: Eq (f_a2wB a_a2wA)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dEq_a2wY = df_a2wD @a_a2wA $dEq_a2wC } in
      \ (a_a28M :: FList f_a2wB a_a2wA)
        (b_a28N :: FList f_a2wB a_a2wA) ->
        case case GHC.Prim.dataToTag# @(FList f_a2wB a_a2wA) a_a28M
             of a#_a28O
             { __DEFAULT ->
             case GHC.Prim.dataToTag# @(FList f_a2wB a_a2wA) b_a28N of b#_a28P
             { __DEFAULT ->
             GHC.Prim./=# a#_a28O b#_a28P
             }
             }
        of ds_d4FF
        { __DEFAULT ->
        case ds_d4FF of {
          __DEFAULT ->
            case a_a28M of {
              __DEFAULT -> GHC.Types.True;
              FCons a1_a28Q a2_a28R ->
                case b_a28N of {
                  __DEFAULT ->
                    case Control.Exception.Base.patError
                           @GHC.Types.LiftedRep @() "Gy08.hs:193:1-70|case"#
                    of {
                    };
                  FCons b1_a28S b2_a28T ->
                    &&
                      (== @(f_a2wB a_a2wA) $dEq_a2wY a1_a28Q b1_a28S)
                      (== @(f_a2wB (FList f_a2wB a_a2wA)) $dEq_a2x0 a2_a28R b2_a28T)
                }
            };
          1# -> GHC.Types.False
        }
        }
end Rec }

Rec {
-- RHS size: {terms: 14, types: 20, coercions: 0, joins: 0/0}
Main.$fShowFList [InlPrag=CONLIKE]
  :: forall a (f :: * -> *).
     (Show a, forall a. Show a => Show (f a)) =>
     Show (FList f a)
[LclIdX[DFunId],
 Unf=DFun: \ (@a_a1ib)
             (@(f_a1ic :: * -> *))
             (v_B1 :: Show a_a1ib)
             (v_B2 :: forall a. Show a => Show (f_a1ic a)) ->
       GHC.Show.C:Show TYPE: FList f_a1ic a_a1ib
                       $cshowsPrec_a2vR @a_a1ib @f_a1ic v_B1 v_B2
                       $cshow_a2wj @a_a1ib @f_a1ic v_B1 v_B2
                       $cshowList_a2wr @a_a1ib @f_a1ic v_B1 v_B2]
Main.$fShowFList
  = \ (@a_a2vM)
      (@(f_a2vN :: * -> *))
      ($dShow_a2vO :: Show a_a2vM)
      (df_a2vP :: forall a. Show a => Show (f_a2vN a)) ->
      GHC.Show.C:Show
        @(FList f_a2vN a_a2vM)
        ($cshowsPrec_a2vR @a_a2vM @f_a2vN $dShow_a2vO df_a2vP)
        ($cshow_a2wj @a_a2vM @f_a2vN $dShow_a2vO df_a2vP)
        ($cshowList_a2wr @a_a2vM @f_a2vN $dShow_a2vO df_a2vP)

-- RHS size: {terms: 15, types: 24, coercions: 0, joins: 0/1}
$cshow_a2wj [Occ=LoopBreaker]
  :: forall a (f :: * -> *).
     (Show a, forall a. Show a => Show (f a)) =>
     FList f a -> String
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 110 60}]
$cshow_a2wj
  = \ (@a_a2vM)
      (@(f_a2vN :: * -> *))
      ($dShow_a2vO :: Show a_a2vM)
      (df_a2vP :: forall a. Show a => Show (f_a2vN a)) ->
      let {
        $dShow_a56X :: Show (FList f_a2vN a_a2vM)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 30 0}]
        $dShow_a56X
          = Main.$fShowFList @a_a2vM @f_a2vN $dShow_a2vO df_a2vP } in
      \ (x_a56Y :: FList f_a2vN a_a2vM) ->
        showsPrec
          @(FList f_a2vN a_a2vM)
          $dShow_a56X
          (GHC.Types.I# 0#)
          x_a56Y
          (GHC.Types.[] @Char)

-- RHS size: {terms: 17, types: 28, coercions: 0, joins: 0/1}
$cshowList_a2wr [Occ=LoopBreaker]
  :: forall a (f :: * -> *).
     (Show a, forall a. Show a => Show (f a)) =>
     [FList f a] -> ShowS
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 140 60}]
$cshowList_a2wr
  = \ (@a_a2vM)
      (@(f_a2vN :: * -> *))
      ($dShow_a2vO :: Show a_a2vM)
      (df_a2vP :: forall a. Show a => Show (f_a2vN a)) ->
      let {
        $dShow_a56S :: Show (FList f_a2vN a_a2vM)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 30 0}]
        $dShow_a56S
          = Main.$fShowFList @a_a2vM @f_a2vN $dShow_a2vO df_a2vP } in
      \ (ls_a56T :: [FList f_a2vN a_a2vM]) (s_a56U :: String) ->
        GHC.Show.showList__
          @(FList f_a2vN a_a2vM)
          (showsPrec @(FList f_a2vN a_a2vM) $dShow_a56S (GHC.Types.I# 0#))
          ls_a56T
          s_a56U

-- RHS size: {terms: 46, types: 58, coercions: 0, joins: 0/3}
$cshowsPrec_a2vR [Occ=LoopBreaker]
  :: forall a (f :: * -> *).
     (Show a, forall a. Show a => Show (f a)) =>
     Int -> FList f a -> ShowS
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 120] 540 60}]
$cshowsPrec_a2vR
  = \ (@a_a2vM)
      (@(f_a2vN :: * -> *))
      ($dShow_a2vO :: Show a_a2vM)
      (df_a2vP :: forall a. Show a => Show (f_a2vN a)) ->
      let {
        $dShow_a4xF :: Show (FList f_a2vN a_a2vM)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=True, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 30 0}]
        $dShow_a4xF
          = Main.$fShowFList @a_a2vM @f_a2vN $dShow_a2vO df_a2vP } in
      let {
        $dShow_a2wg :: Show (f_a2vN (FList f_a2vN a_a2vM))
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dShow_a2wg = df_a2vP @(FList f_a2vN a_a2vM) $dShow_a4xF } in
      let {
        $dShow_a2wb :: Show (f_a2vN a_a2vM)
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dShow_a2wb = df_a2vP @a_a2vM $dShow_a2vO } in
      \ (ds_d4Fr :: Int) (ds_d4Fs :: FList f_a2vN a_a2vM) ->
        case ds_d4Fs of {
          FNil -> showString (GHC.CString.unpackCString# "FNil"#);
          FCons b1_a28K b2_a28L ->
            showParen
              (>= @Int GHC.Classes.$fOrdInt ds_d4Fr (GHC.Types.I# 11#))
              (. @String
                 @String
                 @String
                 (showString (GHC.CString.unpackCString# "FCons "#))
                 (. @String
                    @String
                    @String
                    (showsPrec @(f_a2vN a_a2vM) $dShow_a2wb (GHC.Types.I# 11#) b1_a28K)
                    (. @String
                       @String
                       @String
                       GHC.Show.showSpace
                       (showsPrec
                          @(f_a2vN (FList f_a2vN a_a2vM))
                          $dShow_a2wg
                          (GHC.Types.I# 11#)
                          b2_a28L))))
        }
end Rec }

-- RHS size: {terms: 56, types: 32, coercions: 8, joins: 0/2}
mapMList
  :: forall (m :: * -> *) a b. Monad m => (a -> m b) -> [a] -> m [b]
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 660 60}]
mapMList
  = \ (@(m_a2vx :: * -> *)) (@a_a2vy) (@b_a2vz) _ [Occ=Dead] ->
      let {
        $dIP_a2vJ :: GHC.Stack.Types.HasCallStack
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 280 0}]
        $dIP_a2vJ
          = (GHC.Stack.Types.pushCallStack
               (GHC.CString.unpackCString# "undefined"#,
                GHC.Stack.Types.SrcLoc
                  (GHC.CString.unpackCString# "main"#)
                  (GHC.CString.unpackCString# "Main"#)
                  (GHC.CString.unpackCString# "Gy08.hs"#)
                  (GHC.Types.I# 11#)
                  (GHC.Types.I# 21#)
                  (GHC.Types.I# 11#)
                  (GHC.Types.I# 30#))
               GHC.Stack.Types.emptyCallStack)
            `cast` (Sym (GHC.Classes.N:IP[0]
                             <"callStack">_N <GHC.Stack.Types.CallStack>_N)
                    :: GHC.Stack.Types.CallStack
                       ~R# (?callStack::GHC.Stack.Types.CallStack)) } in
      let {
        $dIP_a2vF :: GHC.Stack.Types.HasCallStack
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 280 0}]
        $dIP_a2vF
          = (GHC.Stack.Types.pushCallStack
               (GHC.CString.unpackCString# "undefined"#,
                GHC.Stack.Types.SrcLoc
                  (GHC.CString.unpackCString# "main"#)
                  (GHC.CString.unpackCString# "Main"#)
                  (GHC.CString.unpackCString# "Gy08.hs"#)
                  (GHC.Types.I# 10#)
                  (GHC.Types.I# 17#)
                  (GHC.Types.I# 10#)
                  (GHC.Types.I# 26#))
               GHC.Stack.Types.emptyCallStack)
            `cast` (Sym (GHC.Classes.N:IP[0]
                             <"callStack">_N <GHC.Stack.Types.CallStack>_N)
                    :: GHC.Stack.Types.CallStack
                       ~R# (?callStack::GHC.Stack.Types.CallStack)) } in
      \ _ [Occ=Dead] (ds_d4Fe :: [a_a2vy]) ->
        case ds_d4Fe of {
          [] -> undefined @GHC.Types.LiftedRep @(m_a2vx [b_a2vz]) $dIP_a2vF;
          : _ [Occ=Dead] _ [Occ=Dead] ->
            undefined @GHC.Types.LiftedRep @(m_a2vx [b_a2vz]) $dIP_a2vJ
        }

-- RHS size: {terms: 25, types: 18, coercions: 4, joins: 0/0}
mapMSingle
  :: forall (m :: * -> *) a b.
     Monad m =>
     (a -> m b) -> Single a -> m (Single b)
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 300 0}]
mapMSingle
  = \ (@(m_a2tu :: * -> *)) (@a_a2tv) (@b_a2tw) _ [Occ=Dead] ->
      undefined
        @GHC.Types.LiftedRep
        @((a_a2tv -> m_a2tu b_a2tw)
          -> Single a_a2tv -> m_a2tu (Single b_a2tw))
        ((GHC.Stack.Types.pushCallStack
            (GHC.CString.unpackCString# "undefined"#,
             GHC.Stack.Types.SrcLoc
               (GHC.CString.unpackCString# "main"#)
               (GHC.CString.unpackCString# "Main"#)
               (GHC.CString.unpackCString# "Gy08.hs"#)
               (GHC.Types.I# 49#)
               (GHC.Types.I# 14#)
               (GHC.Types.I# 49#)
               (GHC.Types.I# 23#))
            GHC.Stack.Types.emptyCallStack)
         `cast` (Sym (GHC.Classes.N:IP[0]
                          <"callStack">_N <GHC.Stack.Types.CallStack>_N)
                 :: GHC.Stack.Types.CallStack
                    ~R# (?callStack::GHC.Stack.Types.CallStack)))

-- RHS size: {terms: 25, types: 18, coercions: 4, joins: 0/0}
mapMTuple
  :: forall (m :: * -> *) a b.
     Monad m =>
     (a -> m b) -> Tuple a -> m (Tuple b)
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 300 0}]
mapMTuple
  = \ (@(m_a2tk :: * -> *)) (@a_a2tl) (@b_a2tm) _ [Occ=Dead] ->
      undefined
        @GHC.Types.LiftedRep
        @((a_a2tl -> m_a2tk b_a2tm)
          -> Tuple a_a2tl -> m_a2tk (Tuple b_a2tm))
        ((GHC.Stack.Types.pushCallStack
            (GHC.CString.unpackCString# "undefined"#,
             GHC.Stack.Types.SrcLoc
               (GHC.CString.unpackCString# "main"#)
               (GHC.CString.unpackCString# "Main"#)
               (GHC.CString.unpackCString# "Gy08.hs"#)
               (GHC.Types.I# 52#)
               (GHC.Types.I# 13#)
               (GHC.Types.I# 52#)
               (GHC.Types.I# 22#))
            GHC.Stack.Types.emptyCallStack)
         `cast` (Sym (GHC.Classes.N:IP[0]
                          <"callStack">_N <GHC.Stack.Types.CallStack>_N)
                 :: GHC.Stack.Types.CallStack
                    ~R# (?callStack::GHC.Stack.Types.CallStack)))

-- RHS size: {terms: 25, types: 18, coercions: 4, joins: 0/0}
mapMQuintuple
  :: forall (m :: * -> *) a b.
     Monad m =>
     (a -> m b) -> Quintuple a -> m (Quintuple b)
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 300 0}]
mapMQuintuple
  = \ (@(m_a2ta :: * -> *)) (@a_a2tb) (@b_a2tc) _ [Occ=Dead] ->
      undefined
        @GHC.Types.LiftedRep
        @((a_a2tb -> m_a2ta b_a2tc)
          -> Quintuple a_a2tb -> m_a2ta (Quintuple b_a2tc))
        ((GHC.Stack.Types.pushCallStack
            (GHC.CString.unpackCString# "undefined"#,
             GHC.Stack.Types.SrcLoc
               (GHC.CString.unpackCString# "main"#)
               (GHC.CString.unpackCString# "Main"#)
               (GHC.CString.unpackCString# "Gy08.hs"#)
               (GHC.Types.I# 55#)
               (GHC.Types.I# 17#)
               (GHC.Types.I# 55#)
               (GHC.Types.I# 26#))
            GHC.Stack.Types.emptyCallStack)
         `cast` (Sym (GHC.Classes.N:IP[0]
                          <"callStack">_N <GHC.Stack.Types.CallStack>_N)
                 :: GHC.Stack.Types.CallStack
                    ~R# (?callStack::GHC.Stack.Types.CallStack)))

-- RHS size: {terms: 24, types: 28, coercions: 0, joins: 0/1}
mapMMaybe
  :: forall (m :: * -> *) a b.
     Monad m =>
     (a -> m b) -> Maybe a -> m (Maybe b)
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60] 200 60}]
mapMMaybe
  = \ (@(m_a2sO :: * -> *))
      (@a_a2sP)
      (@b_a2sQ)
      ($dMonad_a2sR :: Monad m_a2sO) ->
      let {
        $dFunctor_a2t3 :: Functor m_a2sO
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 40 0}]
        $dFunctor_a2t3
          = GHC.Base.$p1Applicative
              @m_a2sO (GHC.Base.$p1Monad @m_a2sO $dMonad_a2sR) } in
      \ (f_a1hX :: a_a2sP -> m_a2sO b_a2sQ) (ds_d4EP :: Maybe a_a2sP) ->
        case ds_d4EP of {
          Just x_a1hZ ->
            fmap
              @m_a2sO
              $dFunctor_a2t3
              @b_a2sQ
              @(Maybe b_a2sQ)
              (\ (x'_a1i0 :: b_a2sQ) -> Main.Just @b_a2sQ x'_a1i0)
              (f_a1hX x_a1hZ);
          Nothing ->
            return @m_a2sO $dMonad_a2sR @(Maybe b_a2sQ) (Main.Nothing @b_a2sQ)
        }

-- RHS size: {terms: 23, types: 33, coercions: 0, joins: 0/1}
liftA4
  :: forall (f :: * -> *) a b c d.
     Applicative f =>
     (a -> b -> c -> d) -> f a -> f b -> f c -> f d
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [90] 190 60}]
liftA4
  = \ (@(f_a2sq :: * -> *))
      (@a_a2sr)
      (@b_a2ss)
      (@c_a2st)
      (@d_a2su)
      ($dApplicative_a2sv :: Applicative f_a2sq) ->
      let {
        $dFunctor_a2sL :: Functor f_a2sq
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dFunctor_a2sL
          = GHC.Base.$p1Applicative @f_a2sq $dApplicative_a2sv } in
      \ (func_a1i1 :: a_a2sr -> b_a2ss -> c_a2st -> d_a2su)
        (fa_a1i2 :: f_a2sq a_a2sr)
        (fb_a1i3 :: f_a2sq b_a2ss)
        (fc_a1i4 :: f_a2sq c_a2st) ->
        <*>
          @f_a2sq
          $dApplicative_a2sv
          @c_a2st
          @d_a2su
          (<*>
             @f_a2sq
             $dApplicative_a2sv
             @b_a2ss
             @(c_a2st -> d_a2su)
             (<$>
                @f_a2sq
                @a_a2sr
                @(b_a2ss -> c_a2st -> d_a2su)
                $dFunctor_a2sL
                func_a1i1
                fa_a1i2)
             fb_a1i3)
          fc_a1i4

-- RHS size: {terms: 25, types: 18, coercions: 4, joins: 0/0}
mapA
  :: forall (f :: * -> *) a b.
     Applicative f =>
     (a -> f b) -> List a -> f (List b)
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0] 300 0}]
mapA
  = \ (@(f_a2ru :: * -> *)) (@a_a2rv) (@b_a2rw) _ [Occ=Dead] ->
      undefined
        @GHC.Types.LiftedRep
        @((a_a2rv -> f_a2ru b_a2rw) -> List a_a2rv -> f_a2ru (List b_a2rw))
        ((GHC.Stack.Types.pushCallStack
            (GHC.CString.unpackCString# "undefined"#,
             GHC.Stack.Types.SrcLoc
               (GHC.CString.unpackCString# "main"#)
               (GHC.CString.unpackCString# "Main"#)
               (GHC.CString.unpackCString# "Gy08.hs"#)
               (GHC.Types.I# 106#)
               (GHC.Types.I# 8#)
               (GHC.Types.I# 106#)
               (GHC.Types.I# 17#))
            GHC.Stack.Types.emptyCallStack)
         `cast` (Sym (GHC.Classes.N:IP[0]
                          <"callStack">_N <GHC.Stack.Types.CallStack>_N)
                 :: GHC.Stack.Types.CallStack
                    ~R# (?callStack::GHC.Stack.Types.CallStack)))

Rec {
-- RHS size: {terms: 7, types: 1, coercions: 0, joins: 0/0}
Main.$fTraversableList [InlPrag=CONLIKE] :: Traversable List
[LclIdX[DFunId],
 Unf=DFun: \ ->
       Data.Traversable.C:Traversable TYPE: List
                                      Main.$fFunctorList
                                      Main.$fFoldableList
                                      mapA
                                      $csequenceA_a4n0
                                      $cmapM_a4o3
                                      $csequence_a4oj]
Main.$fTraversableList
  = Data.Traversable.C:Traversable
      @List
      Main.$fFunctorList
      Main.$fFoldableList
      mapA
      $csequenceA_a4n0
      $cmapM_a4o3
      $csequence_a4oj

-- RHS size: {terms: 8, types: 11, coercions: 0, joins: 0/0}
$cmapM_a4o3 [Occ=LoopBreaker]
  :: forall (m :: * -> *) a b.
     Monad m =>
     (a -> m b) -> List a -> m (List b)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30] 50 0}]
$cmapM_a4o3
  = \ (@(m_a4o6 :: * -> *))
      (@a_a4o7)
      (@b_a4o8)
      ($dMonad_a4o9 :: Monad m_a4o6) ->
      traverse
        @List
        Main.$fTraversableList
        @m_a4o6
        @a_a4o7
        @b_a4o8
        (GHC.Base.$p1Monad @m_a4o6 $dMonad_a4o9)

-- RHS size: {terms: 7, types: 9, coercions: 0, joins: 0/0}
$csequence_a4oj [Occ=LoopBreaker]
  :: forall (m :: * -> *) a. Monad m => List (m a) -> m (List a)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30] 50 0}]
$csequence_a4oj
  = \ (@(m_a4om :: * -> *))
      (@a_a4on)
      ($dMonad_a4oo :: Monad m_a4om) ->
      sequenceA
        @List
        Main.$fTraversableList
        @m_a4om
        @a_a4on
        (GHC.Base.$p1Monad @m_a4om $dMonad_a4oo)

-- RHS size: {terms: 28, types: 41, coercions: 0, joins: 0/1}
$csequenceA_a4n0 [Occ=LoopBreaker]
  :: forall (f :: * -> *) a.
     Applicative f =>
     List (f a) -> f (List a)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [90] 240 60}]
$csequenceA_a4n0
  = \ (@(f_a4nq :: * -> *))
      (@a_a4nr)
      ($dApplicative_a4ns :: Applicative f_a4nq) ->
      let {
        $dFunctor_a4nS :: Functor f_a4nq
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dFunctor_a4nS
          = GHC.Base.$p1Applicative @f_a4nq $dApplicative_a4ns } in
      \ (ds_d4WJ :: List (f_a4nq a_a4nr)) ->
        case ds_d4WJ of {
          Nil ->
            pure @f_a4nq $dApplicative_a4ns @(List a_a4nr) (Main.Nil @a_a4nr);
          Cons x_aUG xs_aUH ->
            <*>
              @f_a4nq
              $dApplicative_a4ns
              @(List a_a4nr)
              @(List a_a4nr)
              (<$>
                 @f_a4nq
                 @a_a4nr
                 @(List a_a4nr -> List a_a4nr)
                 $dFunctor_a4nS
                 (\ (ds_d4WP :: a_a4nr) (ds_d4WQ :: List a_a4nr) ->
                    Main.Cons @a_a4nr ds_d4WP ds_d4WQ)
                 x_aUG)
              (sequenceA
                 @List
                 Main.$fTraversableList
                 @f_a4nq
                 @a_a4nr
                 $dApplicative_a4ns
                 xs_aUH)
        }
end Rec }

-- (\x y -> x || y) <$> m 'a' <*> m 'b'

-- RHS size: {terms: 21, types: 19, coercions: 0, joins: 0/1}
f :: forall {f :: * -> *}.
     Applicative f =>
     (Char -> f Bool) -> f Bool
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60] 230 60}]
f = \ (@(f_a2r1 :: * -> *))
      ($dApplicative_a2ri :: Applicative f_a2r1) ->
      let {
        $dFunctor_a2qW :: Functor f_a2r1
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 20 0}]
        $dFunctor_a2qW
          = GHC.Base.$p1Applicative @f_a2r1 $dApplicative_a2ri } in
      \ (m_a1i5 :: Char -> f_a2r1 Bool) ->
        <*>
          @f_a2r1
          $dApplicative_a2ri
          @Bool
          @Bool
          (fmap
             @f_a2r1
             $dFunctor_a2qW
             @Bool
             @(Bool -> Bool)
             (\ (x_a1i6 :: Bool) (y_a1i7 :: Bool) -> || x_a1i6 y_a1i7)
             (m_a1i5 (GHC.Types.C# 'a'#)))
          (m_a1i5 (GHC.Types.C# 'b'#))

f = \ (m :: Char -> f Bool) ->
  <*>
  (fmap
    (\ (x :: Bool) (y :: Bool) ->  x || y)
      (m (GHC.Types.C# 'a'#)))
      (m (GHC.Types.C# 'b'#))


-- RHS size: {terms: 20, types: 19, coercions: 0, joins: 0/1}
f' :: forall {m :: * -> *}. Monad m => (Bool -> m Bool) -> m Bool
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60] 230 60}]
f'
  = \ (@(m_a2q3 :: * -> *)) ($dMonad_a2qx :: Monad m_a2q3) ->
      let {
        $dFunctor_a2qj :: Functor m_a2q3
        [LclId,
         Unf=Unf{Src=<vanilla>, TopLvl=False,
                 Value=False, ConLike=False, WorkFree=False, Expandable=True,
                 Guidance=IF_ARGS [] 40 0}]
        $dFunctor_a2qj
          = GHC.Base.$p1Applicative
              @m_a2q3 (GHC.Base.$p1Monad @m_a2q3 $dMonad_a2qx) } in
      \ (m_a1i8 :: Bool -> m_a2q3 Bool) ->
        >>=
          @m_a2q3
          $dMonad_a2qx
          @Bool
          @Bool
          (m_a1i8 GHC.Types.True)
          (\ (x_a1i9 :: Bool) ->
             fmap
               @m_a2q3
               $dFunctor_a2qj
               @Bool
               @Bool
               (\ (y_a1ia :: Bool) -> || x_a1i9 y_a1ia)
               (m_a1i8 x_a1i9))

-- RHS size: {terms: 5, types: 0, coercions: 0, joins: 0/0}
Main.$trModule :: GHC.Types.Module
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 70 10}]
Main.$trModule
  = GHC.Types.Module
      (GHC.Types.TrNameS "main"#) (GHC.Types.TrNameS "Main"#)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4De [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
$krep_a4De
  = GHC.Types.KindRepFun GHC.Types.krep$* GHC.Types.krep$*->*->*

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4Cu [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
$krep_a4Cu
  = GHC.Types.KindRepFun GHC.Types.krep$*Arr* GHC.Types.krep$*Arr*

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4Dh [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=False, ConLike=True, WorkFree=False, Expandable=True,
         Guidance=IF_ARGS [] 30 0}]
$krep_a4Dh = GHC.Types.$WKindRepVar (GHC.Types.I# 2#)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4Cx [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=False, ConLike=True, WorkFree=False, Expandable=True,
         Guidance=IF_ARGS [] 30 0}]
$krep_a4Cx = GHC.Types.$WKindRepVar (GHC.Types.I# 1#)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4CU [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
$krep_a4CU = GHC.Types.KindRepFun $krep_a4Cx GHC.Types.krep$*

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4CE [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=False, ConLike=True, WorkFree=False, Expandable=True,
         Guidance=IF_ARGS [] 30 0}]
$krep_a4CE = GHC.Types.$WKindRepVar (GHC.Types.I# 0#)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4CD [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
$krep_a4CD = GHC.Types.KindRepFun $krep_a4CE GHC.Types.krep$*

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4CF [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
$krep_a4CF = GHC.Types.KindRepFun $krep_a4CE $krep_a4CD

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4CC [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
$krep_a4CC = GHC.Types.KindRepFun $krep_a4CD $krep_a4CF

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4D7 [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
$krep_a4D7 = GHC.Types.KindRepFun $krep_a4CD $krep_a4CD

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4D2 [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
$krep_a4D2 = GHC.Types.KindRepFun GHC.Types.krep$*Arr* $krep_a4CD

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4CT [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
$krep_a4CT = GHC.Types.KindRepFun $krep_a4Cx $krep_a4CE

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4CS [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
$krep_a4CS = GHC.Types.KindRepFun $krep_a4CT $krep_a4CU

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4CR [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
$krep_a4CR = GHC.Types.KindRepFun $krep_a4CD $krep_a4CS

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4D5 [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=False, ConLike=True, WorkFree=False, Expandable=True,
         Guidance=IF_ARGS [] 30 0}]
$krep_a4D5 = GHC.Types.$WKindRepVar (GHC.Types.I# 1#)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4Cw [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=False, ConLike=True, WorkFree=False, Expandable=True,
         Guidance=IF_ARGS [] 30 0}]
$krep_a4Cw = GHC.Types.$WKindRepVar (GHC.Types.I# 0#)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4Cz [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
$krep_a4Cz = GHC.Types.KindRepApp $krep_a4Cw $krep_a4Cx

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4CZ [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=False, ConLike=True, WorkFree=False, Expandable=True,
         Guidance=IF_ARGS [] 30 0}]
$krep_a4CZ = GHC.Types.$WKindRepVar (GHC.Types.I# 3#)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4CX [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=False, ConLike=True, WorkFree=False, Expandable=True,
         Guidance=IF_ARGS [] 30 0}]
$krep_a4CX = GHC.Types.$WKindRepVar (GHC.Types.I# 2#)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4CI [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=False, ConLike=True, WorkFree=False, Expandable=True,
         Guidance=IF_ARGS [] 30 0}]
$krep_a4CI = GHC.Types.$WKindRepVar (GHC.Types.I# 1#)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4D0 [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=False, ConLike=True, WorkFree=False, Expandable=True,
         Guidance=IF_ARGS [] 30 0}]
$krep_a4D0 = GHC.Types.$WKindRepVar (GHC.Types.I# 4#)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4CY [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
$krep_a4CY = GHC.Types.KindRepApp $krep_a4CZ $krep_a4D0

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4CW [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
$krep_a4CW = GHC.Types.KindRepApp $krep_a4CX $krep_a4CY

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4CM [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=False, ConLike=True, WorkFree=False, Expandable=True,
         Guidance=IF_ARGS [] 30 0}]
$krep_a4CM = GHC.Types.$WKindRepVar (GHC.Types.I# 3#)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4CL [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
$krep_a4CL = GHC.Types.KindRepApp $krep_a4CI $krep_a4CM

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4CJ [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=False, ConLike=True, WorkFree=False, Expandable=True,
         Guidance=IF_ARGS [] 30 0}]
$krep_a4CJ = GHC.Types.$WKindRepVar (GHC.Types.I# 2#)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4CH [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
$krep_a4CH = GHC.Types.KindRepApp $krep_a4CI $krep_a4CJ

-- RHS size: {terms: 8, types: 0, coercions: 0, joins: 0/0}
Main.$tcSingle :: GHC.Types.TyCon
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 50 10}]
Main.$tcSingle
  = GHC.Types.TyCon
      3376327050227598423##64
      17733973228501108435##64
      Main.$trModule
      (GHC.Types.TrNameS "Single"#)
      0#
      GHC.Types.krep$*Arr*

-- RHS size: {terms: 5, types: 2, coercions: 0, joins: 0/0}
$krep_a4DR [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 20 10}]
$krep_a4DR
  = GHC.Types.KindRepTyConApp
      Main.$tcSingle
      (GHC.Types.:
         @GHC.Types.KindRep $krep_a4CE (GHC.Types.[] @GHC.Types.KindRep))

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4DQ [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
$krep_a4DQ = GHC.Types.KindRepFun $krep_a4CE $krep_a4DR

-- RHS size: {terms: 8, types: 0, coercions: 0, joins: 0/0}
Main.$tc'Single :: GHC.Types.TyCon
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 50 10}]
Main.$tc'Single
  = GHC.Types.TyCon
      16420742000726075554##64
      9723641729832908764##64
      Main.$trModule
      (GHC.Types.TrNameS "'Single"#)
      1#
      $krep_a4DQ

-- RHS size: {terms: 8, types: 0, coercions: 0, joins: 0/0}
Main.$tcTuple :: GHC.Types.TyCon
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 50 10}]
Main.$tcTuple
  = GHC.Types.TyCon
      1101860677610401473##64
      11396532933811309706##64
      Main.$trModule
      (GHC.Types.TrNameS "Tuple"#)
      0#
      GHC.Types.krep$*Arr*

-- RHS size: {terms: 5, types: 2, coercions: 0, joins: 0/0}
$krep_a4DP [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 20 10}]
$krep_a4DP
  = GHC.Types.KindRepTyConApp
      Main.$tcTuple
      (GHC.Types.:
         @GHC.Types.KindRep $krep_a4CE (GHC.Types.[] @GHC.Types.KindRep))

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4DO [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
$krep_a4DO = GHC.Types.KindRepFun $krep_a4CE $krep_a4DP

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4DN [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
$krep_a4DN = GHC.Types.KindRepFun $krep_a4CE $krep_a4DO

-- RHS size: {terms: 8, types: 0, coercions: 0, joins: 0/0}
Main.$tc'Tuple :: GHC.Types.TyCon
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 50 10}]
Main.$tc'Tuple
  = GHC.Types.TyCon
      17315402204857149888##64
      3958840298296508507##64
      Main.$trModule
      (GHC.Types.TrNameS "'Tuple"#)
      1#
      $krep_a4DN

-- RHS size: {terms: 8, types: 0, coercions: 0, joins: 0/0}
Main.$tcQuintuple :: GHC.Types.TyCon
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 60 10}]
Main.$tcQuintuple
  = GHC.Types.TyCon
      15917699484782037316##64
      3144242367423785140##64
      Main.$trModule
      (GHC.Types.TrNameS "Quintuple"#)
      0#
      GHC.Types.krep$*Arr*

-- RHS size: {terms: 5, types: 2, coercions: 0, joins: 0/0}
$krep_a4DM [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 20 10}]
$krep_a4DM
  = GHC.Types.KindRepTyConApp
      Main.$tcQuintuple
      (GHC.Types.:
         @GHC.Types.KindRep $krep_a4CE (GHC.Types.[] @GHC.Types.KindRep))

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4DL [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
$krep_a4DL = GHC.Types.KindRepFun $krep_a4CE $krep_a4DM

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4DK [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
$krep_a4DK = GHC.Types.KindRepFun $krep_a4CE $krep_a4DL

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4DJ [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
$krep_a4DJ = GHC.Types.KindRepFun $krep_a4CE $krep_a4DK

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4DI [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
$krep_a4DI = GHC.Types.KindRepFun $krep_a4CE $krep_a4DJ

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4DH [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
$krep_a4DH = GHC.Types.KindRepFun $krep_a4CE $krep_a4DI

-- RHS size: {terms: 8, types: 0, coercions: 0, joins: 0/0}
Main.$tc'Quintuple :: GHC.Types.TyCon
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 60 10}]
Main.$tc'Quintuple
  = GHC.Types.TyCon
      13503713627787984023##64
      13156168892515852048##64
      Main.$trModule
      (GHC.Types.TrNameS "'Quintuple"#)
      1#
      $krep_a4DH

-- RHS size: {terms: 8, types: 0, coercions: 0, joins: 0/0}
Main.$tcList :: GHC.Types.TyCon
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 40 10}]
Main.$tcList
  = GHC.Types.TyCon
      10620418784423137533##64
      12893453702791775935##64
      Main.$trModule
      (GHC.Types.TrNameS "List"#)
      0#
      GHC.Types.krep$*Arr*

-- RHS size: {terms: 5, types: 2, coercions: 0, joins: 0/0}
$krep_a4Dx [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 20 10}]
$krep_a4Dx
  = GHC.Types.KindRepTyConApp
      Main.$tcList
      (GHC.Types.:
         @GHC.Types.KindRep $krep_a4CE (GHC.Types.[] @GHC.Types.KindRep))

-- RHS size: {terms: 8, types: 0, coercions: 0, joins: 0/0}
Main.$tc'Nil :: GHC.Types.TyCon
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 40 10}]
Main.$tc'Nil
  = GHC.Types.TyCon
      15703065417820164806##64
      7212711407268931041##64
      Main.$trModule
      (GHC.Types.TrNameS "'Nil"#)
      1#
      $krep_a4Dx

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4DG [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
$krep_a4DG = GHC.Types.KindRepFun $krep_a4Dx $krep_a4Dx

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4DF [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
$krep_a4DF = GHC.Types.KindRepFun $krep_a4CE $krep_a4DG

-- RHS size: {terms: 8, types: 0, coercions: 0, joins: 0/0}
Main.$tc'Cons :: GHC.Types.TyCon
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 50 10}]
Main.$tc'Cons
  = GHC.Types.TyCon
      84279454294130128##64
      18387703141874706943##64
      Main.$trModule
      (GHC.Types.TrNameS "'Cons"#)
      1#
      $krep_a4DF

-- RHS size: {terms: 8, types: 0, coercions: 0, joins: 0/0}
Main.$tcMaybe :: GHC.Types.TyCon
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 50 10}]
Main.$tcMaybe
  = GHC.Types.TyCon
      13798499617969275230##64
      5189846110987909322##64
      Main.$trModule
      (GHC.Types.TrNameS "Maybe"#)
      0#
      GHC.Types.krep$*Arr*

-- RHS size: {terms: 5, types: 2, coercions: 0, joins: 0/0}
$krep_a4DE [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 20 10}]
$krep_a4DE
  = GHC.Types.KindRepTyConApp
      Main.$tcMaybe
      (GHC.Types.:
         @GHC.Types.KindRep $krep_a4CE (GHC.Types.[] @GHC.Types.KindRep))

-- RHS size: {terms: 8, types: 0, coercions: 0, joins: 0/0}
Main.$tc'Nothing :: GHC.Types.TyCon
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 50 10}]
Main.$tc'Nothing
  = GHC.Types.TyCon
      15242170477140031811##64
      8050434727693053559##64
      Main.$trModule
      (GHC.Types.TrNameS "'Nothing"#)
      1#
      $krep_a4DE

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4DD [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
$krep_a4DD = GHC.Types.KindRepFun $krep_a4CE $krep_a4DE

-- RHS size: {terms: 8, types: 0, coercions: 0, joins: 0/0}
Main.$tc'Just :: GHC.Types.TyCon
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 50 10}]
Main.$tc'Just
  = GHC.Types.TyCon
      8987143417357576665##64
      4877264585000795748##64
      Main.$trModule
      (GHC.Types.TrNameS "'Just"#)
      1#
      $krep_a4DD

-- RHS size: {terms: 8, types: 0, coercions: 0, joins: 0/0}
Main.$tcNonEmpty :: GHC.Types.TyCon
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 50 10}]
Main.$tcNonEmpty
  = GHC.Types.TyCon
      14345746323967234299##64
      11444761829866910610##64
      Main.$trModule
      (GHC.Types.TrNameS "NonEmpty"#)
      0#
      GHC.Types.krep$*Arr*

-- RHS size: {terms: 5, types: 2, coercions: 0, joins: 0/0}
$krep_a4DA [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 20 10}]
$krep_a4DA
  = GHC.Types.KindRepTyConApp
      Main.$tcNonEmpty
      (GHC.Types.:
         @GHC.Types.KindRep $krep_a4CE (GHC.Types.[] @GHC.Types.KindRep))

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4Dz [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
$krep_a4Dz = GHC.Types.KindRepFun $krep_a4CE $krep_a4DA

-- RHS size: {terms: 8, types: 0, coercions: 0, joins: 0/0}
Main.$tc'Last :: GHC.Types.TyCon
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 50 10}]
Main.$tc'Last
  = GHC.Types.TyCon
      2025005741232496944##64
      12841667643835667171##64
      Main.$trModule
      (GHC.Types.TrNameS "'Last"#)
      1#
      $krep_a4Dz

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4DC [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
$krep_a4DC = GHC.Types.KindRepFun $krep_a4DA $krep_a4DA

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4DB [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
$krep_a4DB = GHC.Types.KindRepFun $krep_a4CE $krep_a4DC

-- RHS size: {terms: 8, types: 0, coercions: 0, joins: 0/0}
Main.$tc'NECons :: GHC.Types.TyCon
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 50 10}]
Main.$tc'NECons
  = GHC.Types.TyCon
      1839318470383449207##64
      7811437176197864370##64
      Main.$trModule
      (GHC.Types.TrNameS "'NECons"#)
      1#
      $krep_a4DB

-- RHS size: {terms: 8, types: 0, coercions: 0, joins: 0/0}
Main.$tcNonEmpty2 :: GHC.Types.TyCon
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 60 10}]
Main.$tcNonEmpty2
  = GHC.Types.TyCon
      7080961969859019145##64
      5093461307208844813##64
      Main.$trModule
      (GHC.Types.TrNameS "NonEmpty2"#)
      0#
      GHC.Types.krep$*Arr*

-- RHS size: {terms: 5, types: 2, coercions: 0, joins: 0/0}
$krep_a4Dy [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 20 10}]
$krep_a4Dy
  = GHC.Types.KindRepTyConApp
      Main.$tcNonEmpty2
      (GHC.Types.:
         @GHC.Types.KindRep $krep_a4CE (GHC.Types.[] @GHC.Types.KindRep))

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4Dw [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
$krep_a4Dw = GHC.Types.KindRepFun $krep_a4Dx $krep_a4Dy

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4Dv [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
$krep_a4Dv = GHC.Types.KindRepFun $krep_a4CE $krep_a4Dw

-- RHS size: {terms: 8, types: 0, coercions: 0, joins: 0/0}
Main.$tc'NECons2 :: GHC.Types.TyCon
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 50 10}]
Main.$tc'NECons2
  = GHC.Types.TyCon
      12760485948649380815##64
      5817797828241103222##64
      Main.$trModule
      (GHC.Types.TrNameS "'NECons2"#)
      1#
      $krep_a4Dv

-- RHS size: {terms: 8, types: 0, coercions: 0, joins: 0/0}
Main.$tcTree :: GHC.Types.TyCon
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 40 10}]
Main.$tcTree
  = GHC.Types.TyCon
      9208051040442588375##64
      2694919957537544827##64
      Main.$trModule
      (GHC.Types.TrNameS "Tree"#)
      0#
      GHC.Types.krep$*Arr*

-- RHS size: {terms: 5, types: 2, coercions: 0, joins: 0/0}
$krep_a4Dr [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 20 10}]
$krep_a4Dr
  = GHC.Types.KindRepTyConApp
      Main.$tcTree
      (GHC.Types.:
         @GHC.Types.KindRep $krep_a4CE (GHC.Types.[] @GHC.Types.KindRep))

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4Dq [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
$krep_a4Dq = GHC.Types.KindRepFun $krep_a4CE $krep_a4Dr

-- RHS size: {terms: 8, types: 0, coercions: 0, joins: 0/0}
Main.$tc'Leaf :: GHC.Types.TyCon
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 50 10}]
Main.$tc'Leaf
  = GHC.Types.TyCon
      2429462324830996089##64
      3103893512769260469##64
      Main.$trModule
      (GHC.Types.TrNameS "'Leaf"#)
      1#
      $krep_a4Dq

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4Du [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
$krep_a4Du = GHC.Types.KindRepFun $krep_a4Dr $krep_a4Dr

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4Dt [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
$krep_a4Dt = GHC.Types.KindRepFun $krep_a4CE $krep_a4Du

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4Ds [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
$krep_a4Ds = GHC.Types.KindRepFun $krep_a4Dr $krep_a4Dt

-- RHS size: {terms: 8, types: 0, coercions: 0, joins: 0/0}
Main.$tc'Node :: GHC.Types.TyCon
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 50 10}]
Main.$tc'Node
  = GHC.Types.TyCon
      11019788924731710585##64
      649625707236464705##64
      Main.$trModule
      (GHC.Types.TrNameS "'Node"#)
      1#
      $krep_a4Ds

-- RHS size: {terms: 8, types: 0, coercions: 0, joins: 0/0}
Main.$tcEither :: GHC.Types.TyCon
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 50 10}]
Main.$tcEither
  = GHC.Types.TyCon
      9398798581746879658##64
      16768688802056297741##64
      Main.$trModule
      (GHC.Types.TrNameS "Either"#)
      0#
      GHC.Types.krep$*->*->*

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
$krep_a4Do [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 30 10}]
$krep_a4Do
  = GHC.Types.KindRepTyConApp
      Main.$tcEither
      (GHC.Types.:
         @GHC.Types.KindRep
         $krep_a4CE
         (GHC.Types.:
            @GHC.Types.KindRep $krep_a4Cx (GHC.Types.[] @GHC.Types.KindRep)))

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4Dn [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
$krep_a4Dn = GHC.Types.KindRepFun $krep_a4CE $krep_a4Do

-- RHS size: {terms: 8, types: 0, coercions: 0, joins: 0/0}
Main.$tc'Left :: GHC.Types.TyCon
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 50 10}]
Main.$tc'Left
  = GHC.Types.TyCon
      15548129393242508997##64
      13579807792262051397##64
      Main.$trModule
      (GHC.Types.TrNameS "'Left"#)
      2#
      $krep_a4Dn

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4Dp [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
$krep_a4Dp = GHC.Types.KindRepFun $krep_a4Cx $krep_a4Do

-- RHS size: {terms: 8, types: 0, coercions: 0, joins: 0/0}
Main.$tc'Right :: GHC.Types.TyCon
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 50 10}]
Main.$tc'Right
  = GHC.Types.TyCon
      12164269749746858690##64
      4768019436722143294##64
      Main.$trModule
      (GHC.Types.TrNameS "'Right"#)
      2#
      $krep_a4Dp

-- RHS size: {terms: 8, types: 0, coercions: 0, joins: 0/0}
Main.$tcBiTuple :: GHC.Types.TyCon
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 50 10}]
Main.$tcBiTuple
  = GHC.Types.TyCon
      1056466965797016404##64
      16565782545585600952##64
      Main.$trModule
      (GHC.Types.TrNameS "BiTuple"#)
      0#
      GHC.Types.krep$*->*->*

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
$krep_a4Dm [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 30 10}]
$krep_a4Dm
  = GHC.Types.KindRepTyConApp
      Main.$tcBiTuple
      (GHC.Types.:
         @GHC.Types.KindRep
         $krep_a4CE
         (GHC.Types.:
            @GHC.Types.KindRep $krep_a4Cx (GHC.Types.[] @GHC.Types.KindRep)))

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4Dl [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
$krep_a4Dl = GHC.Types.KindRepFun $krep_a4Cx $krep_a4Dm

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4Dk [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
$krep_a4Dk = GHC.Types.KindRepFun $krep_a4CE $krep_a4Dl

-- RHS size: {terms: 8, types: 0, coercions: 0, joins: 0/0}
Main.$tc'BiTuple :: GHC.Types.TyCon
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 50 10}]
Main.$tc'BiTuple
  = GHC.Types.TyCon
      12885575114856800395##64
      2458152812656462674##64
      Main.$trModule
      (GHC.Types.TrNameS "'BiTuple"#)
      2#
      $krep_a4Dk

-- RHS size: {terms: 8, types: 0, coercions: 0, joins: 0/0}
Main.$tcTriEither :: GHC.Types.TyCon
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 60 10}]
Main.$tcTriEither
  = GHC.Types.TyCon
      3971617724887907729##64
      12902747675912530856##64
      Main.$trModule
      (GHC.Types.TrNameS "TriEither"#)
      0#
      $krep_a4De

-- RHS size: {terms: 9, types: 4, coercions: 0, joins: 0/0}
$krep_a4Dg [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 40 10}]
$krep_a4Dg
  = GHC.Types.KindRepTyConApp
      Main.$tcTriEither
      (GHC.Types.:
         @GHC.Types.KindRep
         $krep_a4CE
         (GHC.Types.:
            @GHC.Types.KindRep
            $krep_a4Cx
            (GHC.Types.:
               @GHC.Types.KindRep $krep_a4Dh (GHC.Types.[] @GHC.Types.KindRep))))

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4Df [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
$krep_a4Df = GHC.Types.KindRepFun $krep_a4CE $krep_a4Dg

-- RHS size: {terms: 8, types: 0, coercions: 0, joins: 0/0}
Main.$tc'LeftT :: GHC.Types.TyCon
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 50 10}]
Main.$tc'LeftT
  = GHC.Types.TyCon
      7565317285792116729##64
      16879603396527171862##64
      Main.$trModule
      (GHC.Types.TrNameS "'LeftT"#)
      3#
      $krep_a4Df

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4Di [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
$krep_a4Di = GHC.Types.KindRepFun $krep_a4Cx $krep_a4Dg

-- RHS size: {terms: 8, types: 0, coercions: 0, joins: 0/0}
Main.$tc'MiddleT :: GHC.Types.TyCon
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 50 10}]
Main.$tc'MiddleT
  = GHC.Types.TyCon
      3861187268980907360##64
      8447728471085659476##64
      Main.$trModule
      (GHC.Types.TrNameS "'MiddleT"#)
      3#
      $krep_a4Di

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4Dj [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
$krep_a4Dj = GHC.Types.KindRepFun $krep_a4Dh $krep_a4Dg

-- RHS size: {terms: 8, types: 0, coercions: 0, joins: 0/0}
Main.$tc'RightT :: GHC.Types.TyCon
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 50 10}]
Main.$tc'RightT
  = GHC.Types.TyCon
      13621031008840651839##64
      6165423199527388351##64
      Main.$trModule
      (GHC.Types.TrNameS "'RightT"#)
      3#
      $krep_a4Dj

-- RHS size: {terms: 8, types: 0, coercions: 0, joins: 0/0}
Main.$tcBiList :: GHC.Types.TyCon
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 50 10}]
Main.$tcBiList
  = GHC.Types.TyCon
      12826053998414573415##64
      10459822580187486452##64
      Main.$trModule
      (GHC.Types.TrNameS "BiList"#)
      0#
      GHC.Types.krep$*->*->*

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
$krep_a4Dc [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 30 10}]
$krep_a4Dc
  = GHC.Types.KindRepTyConApp
      Main.$tcBiList
      (GHC.Types.:
         @GHC.Types.KindRep
         $krep_a4CE
         (GHC.Types.:
            @GHC.Types.KindRep $krep_a4Cx (GHC.Types.[] @GHC.Types.KindRep)))

-- RHS size: {terms: 8, types: 0, coercions: 0, joins: 0/0}
Main.$tc'ABNill :: GHC.Types.TyCon
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 50 10}]
Main.$tc'ABNill
  = GHC.Types.TyCon
      10401386598073216514##64
      8883666490202964811##64
      Main.$trModule
      (GHC.Types.TrNameS "'ABNill"#)
      2#
      $krep_a4Dc

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4Db [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
$krep_a4Db = GHC.Types.KindRepFun $krep_a4Dc $krep_a4Dc

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4Da [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
$krep_a4Da = GHC.Types.KindRepFun $krep_a4CE $krep_a4Db

-- RHS size: {terms: 8, types: 0, coercions: 0, joins: 0/0}
Main.$tc'ACons :: GHC.Types.TyCon
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 50 10}]
Main.$tc'ACons
  = GHC.Types.TyCon
      217768904226318465##64
      746013356311019944##64
      Main.$trModule
      (GHC.Types.TrNameS "'ACons"#)
      2#
      $krep_a4Da

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4Dd [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
$krep_a4Dd = GHC.Types.KindRepFun $krep_a4Cx $krep_a4Db

-- RHS size: {terms: 8, types: 0, coercions: 0, joins: 0/0}
Main.$tc'BCons :: GHC.Types.TyCon
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 50 10}]
Main.$tc'BCons
  = GHC.Types.TyCon
      8900512793165916573##64
      3300910185335327286##64
      Main.$trModule
      (GHC.Types.TrNameS "'BCons"#)
      2#
      $krep_a4Dd

-- RHS size: {terms: 8, types: 0, coercions: 0, joins: 0/0}
Main.$tcApply :: GHC.Types.TyCon
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 50 10}]
Main.$tcApply
  = GHC.Types.TyCon
      3168500344242090999##64
      6659804991723910089##64
      Main.$trModule
      (GHC.Types.TrNameS "Apply"#)
      1#
      $krep_a4D7

-- RHS size: {terms: 9, types: 4, coercions: 0, joins: 0/0}
$krep_a4D9 [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 40 10}]
$krep_a4D9
  = GHC.Types.KindRepTyConApp
      Main.$tcApply
      (GHC.Types.:
         @GHC.Types.KindRep
         $krep_a4CE
         (GHC.Types.:
            @GHC.Types.KindRep
            $krep_a4CI
            (GHC.Types.:
               @GHC.Types.KindRep $krep_a4CJ (GHC.Types.[] @GHC.Types.KindRep))))

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4D8 [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
$krep_a4D8 = GHC.Types.KindRepFun $krep_a4CH $krep_a4D9

-- RHS size: {terms: 8, types: 0, coercions: 0, joins: 0/0}
Main.$tc'MkApply :: GHC.Types.TyCon
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 50 10}]
Main.$tc'MkApply
  = GHC.Types.TyCon
      5980508831709042192##64
      1588063467481233589##64
      Main.$trModule
      (GHC.Types.TrNameS "'MkApply"#)
      3#
      $krep_a4D8

-- RHS size: {terms: 8, types: 0, coercions: 0, joins: 0/0}
Main.$tcFix :: GHC.Types.TyCon
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 40 10}]
Main.$tcFix
  = GHC.Types.TyCon
      4810903780012070250##64
      13230522949258734077##64
      Main.$trModule
      (GHC.Types.TrNameS "Fix"#)
      1#
      $krep_a4D2

-- RHS size: {terms: 9, types: 4, coercions: 0, joins: 0/0}
$krep_a4D6 [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 40 10}]
$krep_a4D6
  = GHC.Types.KindRepTyConApp
      Main.$tcFix
      (GHC.Types.:
         @GHC.Types.KindRep
         $krep_a4CE
         (GHC.Types.:
            @GHC.Types.KindRep
            $krep_a4D5
            (GHC.Types.:
               @GHC.Types.KindRep $krep_a4CJ (GHC.Types.[] @GHC.Types.KindRep))))

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4D4 [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
$krep_a4D4 = GHC.Types.KindRepApp $krep_a4D5 $krep_a4D6

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4D3 [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
$krep_a4D3 = GHC.Types.KindRepFun $krep_a4D4 $krep_a4D6

-- RHS size: {terms: 8, types: 0, coercions: 0, joins: 0/0}
Main.$tc'MkFix :: GHC.Types.TyCon
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 50 10}]
Main.$tc'MkFix
  = GHC.Types.TyCon
      18414897602161956117##64
      2300261481917850203##64
      Main.$trModule
      (GHC.Types.TrNameS "'MkFix"#)
      3#
      $krep_a4D3

-- RHS size: {terms: 8, types: 0, coercions: 0, joins: 0/0}
Main.$tcCompose :: GHC.Types.TyCon
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 50 10}]
Main.$tcCompose
  = GHC.Types.TyCon
      16148479591948524507##64
      285109885096541796##64
      Main.$trModule
      (GHC.Types.TrNameS "Compose"#)
      2#
      $krep_a4CR

-- RHS size: {terms: 13, types: 6, coercions: 0, joins: 0/0}
$krep_a4D1 [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 60 10}]
$krep_a4D1
  = GHC.Types.KindRepTyConApp
      Main.$tcCompose
      (GHC.Types.:
         @GHC.Types.KindRep
         $krep_a4CE
         (GHC.Types.:
            @GHC.Types.KindRep
            $krep_a4Cx
            (GHC.Types.:
               @GHC.Types.KindRep
               $krep_a4CX
               (GHC.Types.:
                  @GHC.Types.KindRep
                  $krep_a4CZ
                  (GHC.Types.:
                     @GHC.Types.KindRep
                     $krep_a4D0
                     (GHC.Types.[] @GHC.Types.KindRep))))))

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4CV [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
$krep_a4CV = GHC.Types.KindRepFun $krep_a4CW $krep_a4D1

-- RHS size: {terms: 8, types: 0, coercions: 0, joins: 0/0}
Main.$tc'MkCompose :: GHC.Types.TyCon
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 60 10}]
Main.$tc'MkCompose
  = GHC.Types.TyCon
      5431446784065257472##64
      3712457155370225177##64
      Main.$trModule
      (GHC.Types.TrNameS "'MkCompose"#)
      5#
      $krep_a4CV

-- RHS size: {terms: 8, types: 0, coercions: 0, joins: 0/0}
Main.$tcSum :: GHC.Types.TyCon
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 40 10}]
Main.$tcSum
  = GHC.Types.TyCon
      416570950259011555##64
      9170498074825679109##64
      Main.$trModule
      (GHC.Types.TrNameS "Sum"#)
      1#
      $krep_a4CC

-- RHS size: {terms: 11, types: 5, coercions: 0, joins: 0/0}
$krep_a4CP [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 50 10}]
$krep_a4CP
  = GHC.Types.KindRepTyConApp
      Main.$tcSum
      (GHC.Types.:
         @GHC.Types.KindRep
         $krep_a4CE
         (GHC.Types.:
            @GHC.Types.KindRep
            $krep_a4CI
            (GHC.Types.:
               @GHC.Types.KindRep
               $krep_a4CJ
               (GHC.Types.:
                  @GHC.Types.KindRep $krep_a4CM (GHC.Types.[] @GHC.Types.KindRep)))))

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4CO [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
$krep_a4CO = GHC.Types.KindRepFun $krep_a4CH $krep_a4CP

-- RHS size: {terms: 8, types: 0, coercions: 0, joins: 0/0}
Main.$tc'FLeft :: GHC.Types.TyCon
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 50 10}]
Main.$tc'FLeft
  = GHC.Types.TyCon
      8620585586739481073##64
      8688017617092957545##64
      Main.$trModule
      (GHC.Types.TrNameS "'FLeft"#)
      4#
      $krep_a4CO

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4CQ [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
$krep_a4CQ = GHC.Types.KindRepFun $krep_a4CL $krep_a4CP

-- RHS size: {terms: 8, types: 0, coercions: 0, joins: 0/0}
Main.$tc'FRight :: GHC.Types.TyCon
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 50 10}]
Main.$tc'FRight
  = GHC.Types.TyCon
      12736566507022145783##64
      8597555397415809813##64
      Main.$trModule
      (GHC.Types.TrNameS "'FRight"#)
      4#
      $krep_a4CQ

-- RHS size: {terms: 8, types: 0, coercions: 0, joins: 0/0}
Main.$tcProd :: GHC.Types.TyCon
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 40 10}]
Main.$tcProd
  = GHC.Types.TyCon
      6658522858072378367##64
      16863752985103473225##64
      Main.$trModule
      (GHC.Types.TrNameS "Prod"#)
      1#
      $krep_a4CC

-- RHS size: {terms: 11, types: 5, coercions: 0, joins: 0/0}
$krep_a4CN [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 50 10}]
$krep_a4CN
  = GHC.Types.KindRepTyConApp
      Main.$tcProd
      (GHC.Types.:
         @GHC.Types.KindRep
         $krep_a4CE
         (GHC.Types.:
            @GHC.Types.KindRep
            $krep_a4CI
            (GHC.Types.:
               @GHC.Types.KindRep
               $krep_a4CJ
               (GHC.Types.:
                  @GHC.Types.KindRep $krep_a4CM (GHC.Types.[] @GHC.Types.KindRep)))))

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4CK [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
$krep_a4CK = GHC.Types.KindRepFun $krep_a4CL $krep_a4CN

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4CG [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
$krep_a4CG = GHC.Types.KindRepFun $krep_a4CH $krep_a4CK

-- RHS size: {terms: 8, types: 0, coercions: 0, joins: 0/0}
Main.$tc'FProd :: GHC.Types.TyCon
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 50 10}]
Main.$tc'FProd
  = GHC.Types.TyCon
      1718065787584925133##64
      217383381344417430##64
      Main.$trModule
      (GHC.Types.TrNameS "'FProd"#)
      4#
      $krep_a4CG

-- RHS size: {terms: 8, types: 0, coercions: 0, joins: 0/0}
Main.$tcFList :: GHC.Types.TyCon
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 50 10}]
Main.$tcFList
  = GHC.Types.TyCon
      10530228769803324141##64
      7315522872769781989##64
      Main.$trModule
      (GHC.Types.TrNameS "FList"#)
      0#
      $krep_a4Cu

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
$krep_a4Cv [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 30 10}]
$krep_a4Cv
  = GHC.Types.KindRepTyConApp
      Main.$tcFList
      (GHC.Types.:
         @GHC.Types.KindRep
         $krep_a4Cw
         (GHC.Types.:
            @GHC.Types.KindRep $krep_a4Cx (GHC.Types.[] @GHC.Types.KindRep)))

-- RHS size: {terms: 8, types: 0, coercions: 0, joins: 0/0}
Main.$tc'FNil :: GHC.Types.TyCon
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 50 10}]
Main.$tc'FNil
  = GHC.Types.TyCon
      15967292541569783486##64
      2797522381213237660##64
      Main.$trModule
      (GHC.Types.TrNameS "'FNil"#)
      2#
      $krep_a4Cv

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4CB [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
$krep_a4CB = GHC.Types.KindRepApp $krep_a4Cw $krep_a4Cv

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4CA [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
$krep_a4CA = GHC.Types.KindRepFun $krep_a4CB $krep_a4Cv

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep_a4Cy [InlPrag=[~]] :: GHC.Types.KindRep
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 10}]
$krep_a4Cy = GHC.Types.KindRepFun $krep_a4Cz $krep_a4CA

-- RHS size: {terms: 8, types: 0, coercions: 0, joins: 0/0}
Main.$tc'FCons :: GHC.Types.TyCon
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 50 10}]
Main.$tc'FCons
  = GHC.Types.TyCon
      8612691959191654105##64
      17159992253949801160##64
      Main.$trModule
      (GHC.Types.TrNameS "'FCons"#)
      2#
      $krep_a4Cy

-- RHS size: {terms: 2, types: 3, coercions: 0, joins: 0/0}
$dMonad_a2vq
  :: Monad (ExceptT String Data.Functor.Identity.Identity)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=False, ConLike=False, WorkFree=False, Expandable=True,
         Guidance=IF_ARGS [] 20 0}]
$dMonad_a2vq
  = Control.Monad.Trans.Except.$fMonadExceptT
      @Data.Functor.Identity.Identity
      @[Char]
      Data.Functor.Identity.$fMonadIdentity

-- RHS size: {terms: 2, types: 3, coercions: 0, joins: 0/0}
$dMonadError_a2vn
  :: MonadError
       String (ExceptT String Data.Functor.Identity.Identity)
[LclId,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=False, ConLike=False, WorkFree=False, Expandable=True,
         Guidance=IF_ARGS [] 20 0}]
$dMonadError_a2vn
  = Control.Monad.Error.Class.$fMonadErroreExceptT
      @Data.Functor.Identity.Identity
      @[Char]
      Data.Functor.Identity.$fMonadIdentity

-- RHS size: {terms: 19, types: 15, coercions: 0, joins: 0/0}
safeDiv :: Int -> Int -> Except String Int
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=True, ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 20] 170 0}]
safeDiv
  = \ (n_a1bx :: Int) (ds_d4F8 :: Int) ->
      case ds_d4F8 of { GHC.Types.I# ds_d4F9 ->
      case ds_d4F9 of {
        __DEFAULT ->
          return
            @(ExceptT String Data.Functor.Identity.Identity)
            $dMonad_a2vq
            @Int
            (div @Int GHC.Real.$fIntegralInt n_a1bx ds_d4F8);
        0# ->
          throwError
            @String
            @(ExceptT String Data.Functor.Identity.Identity)
            $dMonadError_a2vn
            @Int
            (GHC.CString.unpackCString# "Hiba"#)
      }
      }

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
main :: IO ()
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=False, ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 30 0}]
main = return @IO GHC.Base.$fMonadIO @() GHC.Tuple.()

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
:Main.main :: IO ()
[LclIdX,
 Unf=Unf{Src=<vanilla>, TopLvl=True,
         Value=False, ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 20 0}]
:Main.main = GHC.TopHandler.runMainIO @() main



[2 of 2] Linking 08.out [Objects changed]
